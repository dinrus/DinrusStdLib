topic "Chameleon Rendering & Создание своих хамелоенизированных контролов";
[ $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[s0; [*R@5;6 Chameleon Rendering `& Создание своих хамелоенизир
ованных контролов]&]
[s0; &]
[s0; [2 В Ultimate`+`+ используется ключевая фишка, 
позволяющая получать почти идентичный 
внешний вид на целевых платформах. 
Она называется `'Chameleon`' и является 
лишь тонкой прослойкой для воссоздания 
внешнего вида на целевой платформе. 
Собственные кастомные контролы могут 
создаваться довольно быстро, но в 
них часто отсутствует надлежащая 
поддержка технологии Chameleon. Поэтому 
при использовании других стандартных 
контролов Ultimate`+`+, `"знакомых`" с `"Хамелеоном`"
, кастомные контролы могут проявлять 
неадекватное поведение.]&]
[s0; [2 Вот почему здесь `- далее `- описывается 
то, как можно расширить/правильно 
создать какой`-либо Ctrl, производный 
от контрола Ultimate`+`+, с поддержкой `"Хамелеон`".
]&]
[s0;2 &]
[s0; [*@(128.0.255)2 1) Определение стиля для контрола 
(Style)]&]
[s0;2 &]
[s0; [2 В файле .h]&]
[s0;C1 &]
[s0; [C1 struct Style : ChStyle<Style> `{]&]
[s0; [C1 -|Color paper;]&]
[s0; [C1 -|Color disabled;]&]
[s0; [C1 -|Color focus;]&]
[s0; [C1 -|Color invalid;]&]
[s0; [C1 -|Color text, textdisabled;]&]
[s0; [C1 -|Color selected, selectedtext;]&]
[s0; [C1 -|Value edge`[4`];]&]
[s0; [C1 -|bool  activeedge;]&]
[s0; [C1 -|int   vfm;]&]
[s0; [C1 `};]&]
[s0;2 &]
[s0; [2 Это, вероятнее всего, наиболее важная 
из задач. Продвигаясь в создании собственног
о Ctrl, вы уже, конечно же, научились 
использовать соответствующие свойства... 
Вот почему это первостепенной важности 
задача при разработке! Позднее портирование
 может оказаться не из лёгких... Те 
части, которые создадут стиль вашего 
контрола, `- это цвета элементов`-деталей, 
продуманность состояний, `- ваш Ctrl 
может быть в нескольких (активном, 
неактивном..),`- общие размеры баров 
 (брусов), кромок (margins) и т.п. Шрифт 
к этому не относится. Его нужно задавать 
через API (позднее включение этого 
Ctrl в DinrusIDE можно будет легко выполнить, 
обеспечив его методом SetFont()).]&]
[s0;2 &]
[s0; [2 Основа ChStyle обогащает ваш собственный 
стиль некоторой обработкой, относящейся 
к статическим экземплярам Style, и касающейся 
 всех экземпляров Ctrl данного типа. 
Не стоит забывать про это!]&]
[s0;2 &]
[s0; [2 И придерживаться конвенции (договорённости
) об именовании `- Style...]&]
[s0;2 &]
[s0; [*@(128.0.255)2 2) Установка дефолтного стиля 
(`= стиля по умолчанию)]&]
[s0;2 &]
[s0; [2 Он регистрируется в базе данных 
Chameleon глобально для конкретного контрола 
(элемента управления, упрэлта)(поэтому 
макросу нужны имя класса Ctrl, имя класса 
Style `- он генерирует функцию `'StyleDefault`'`' 
`- `"дефолт стиля`"). Используйте, по 
врзможности, описания дефолтным системных 
цветов (System), типа SColorFace, SColorPaper, чтобы 
сохранять соответствие глобальному 
дизайну ГИП (GUI). Они производятся 
из текущих целевых настроек Platform 
(платформы).]&]
[s0;2 &]
[s0; [2 В файле .cpp]&]
[s0; [C1 CH`_STYLE(EditField, Style, StyleDefault)]&]
[s0; [C1 `{]&]
[s0; [C1 -|paper `= SColorPaper();]&]
[s0; [C1 -|disabled `= SColorFace();]&]
[s0; [C1 -|focus `= paper;]&]
[s0; [C1 -|invalid `= Blend(paper, Color(255, 0, 0), 32);]&]
[s0; [C1 -|text `= SColorText();]&]
[s0; [C1 -|textdisabled `= SColorDisabled();]&]
[s0; [C1 -|selected `= SColorHighlight();]&]
[s0; [C1 -|selectedtext `= SColorHighlightText();]&]
[s0; [C1 -|for(int i `= 0; i < 4; i`+`+)]&]
[s0; [C1 -|-|edge`[i`] `= CtrlsImg`::EFE();]&]
[s0; [C1 -|activeedge `= false;]&]
[s0; [C1 -|vfm `= 2;]&]
[s0; [C1 `}]&]
[s0;2 &]
[s0; [*@(128.0.255)2 3) Использование стиля const 
Style `* для ссылки]&]
[s0;2 &]
[s0; [2 Это текущий используемый стиль в 
коде контрола. Не забывате инициализировать
 указатель на ваш дефолтный стиль.Теперь, 
когда у вас есть функция StyleDefault(), 
её можно использовать как средство 
для  перезаписи настроек Style, используемых 
в вашем Ctrl (SetStyle). Конечно, стиль Style 
под ссылкой должен существовать жо 
тех пор, пока его использует Ctrl.]&]
[s0;2 &]
[s0; В файле .h&]
[s0; [C1 -|const Style `*style;]&]
[s0; [C1 -|static const Style`& StyleDefault();]&]
[s0; [C1 -|EditField`&  SetStyle(const Style`& s);]&]
[s0; &]
[s0; В файле .cpp&]
[s0; [C1 -|style `= `&StyleDefault(); //ctor]&]
[s0; &]
[s0; [C1 EditField`& EditField`::SetStyle(const Style`& s)]&]
[s0; [C1 `{]&]
[s0; [C1 -|style `= `&s;]&]
[s0; [C1 -|RefreshLayout();]&]
[s0; [C1 -|RefreshFrame();]&]
[s0; [C1 -|return `*this;]&]
[s0; [C1 `}]&]
[s0;2 &]
[s0; [*@(128.0.255)2 4) Использование собственной 
информации о стиле для отрисовки 
контрола]&]
[s0;2 &]
[s0; [2 Либо используйте её непосредственно, 
либо обеспечьте некоторые вспомогательные 
функции Chameleon с вашей информацией 
о стиле]&]
[s0;2 &]
[s0; [C1 void EditField`::Paint(Draw`& w)]&]
[s0; [C1 `{]&]
[s0; [C1 -|Size sz `= GetSize();]&]
[s0;C1 &]
[s0; [C1 -|bool enabled `= IsShowEnabled();]&]
[s0; [C1 -|Color paper `= enabled `&`& !IsReadOnly() ? (HasFocus() ? 
style`->focus : style`->paper) : style`->disabled;]&]
[s0; [C1 -|if(nobg)]&]
[s0; [C1 -|-|paper `= Null;]&]
[s0; [C1 -|Color ink `= enabled ? style`->text : style`->textdisabled;]&]
[s0; [C1 ....]&]
[s0; [C1 `}]&]
[s0; &]
[s0; [2 другими контролами это используется 
так (ScrollBar)]&]
[s0; &]
[s0; [C1 -|-|if(i !`= 2 `|`| thumbsize >`= style`->thumbmin)]&]
[s0; [C1 -|-|-|ChPaint(w, pr, l`[i`]`[p `=`= i ? CTRL`_PRESSED : light 
`=`= i ? CTRL`_HOT : CTRL`_NORMAL`]);]&]
[s0; [C1 -|-|if(i !`= 2)]&]
[s0; [C1 -|-|-|w.End();]&]
[s0; [C1 -|`}]&]
[s0; [C1 `}]&]
[s0; [C1 else]&]
[s0; [C1 -|if(style`->through) `{]&]
[s0; [C1 -|-|ChPaint(w, sz, l`[0`]`[CTRL`_DISABLED`]);]&]
[s0; [C1 -|`}]&]
[s0; [C1 -|else]&]
[s0; [C1 -|if(IsHorz()) `{]&]
[s0; [C1 -|-|-|ChPaint(w, style`->arrowsize, 0, sz.cx / 2, sz.cy, l`[0`]`[CTRL`_DISABLED`]
);]&]
[s0; [C1 -|-|-|ChPaint(w, style`->arrowsize `+ sz.cx / 2, 0, sz.cx `- 
sz.cx / 2, sz.cy, l`[1`]`[CTRL`_DISABLED`]);]&]
[s0; [C1 -|-|`}]&]
[s0; [C1 -|-|else `{]&]
[s0; [C1 -|-|-|ChPaint(w, 0, style`->arrowsize, sz.cx, sz.cy / 2, l`[0`]`[CTRL`_DISABLED`]
);]&]
[s0; [C1 -|-|-|ChPaint(w, 0, style`->arrowsize `+ sz.cy / 2, sz.cx, sz.cy 
`- sz.cy / 2, l`[1`]`[CTRL`_DISABLED`]);]&]
[s0; [C1 ...-|-|`}]&]
[s0;2 &]
[s0; [*@(128.0.255)2 Советы по Использованию:]&]
[s0;2 &]
[s0; [2 Как правило, мспользуемая структура 
Style `"неальтерабильна`" (поэтому и const 
Style `*`') `- можно только полностью заменить 
её, как сущность, (SetStyle) указав на другой 
стиль. Указываемая структура должна 
существовать всё время жизни использующего 
её контрола.]&]
[s0;2 &]
[s0; [2 Емли требуется навсегда изменить 
дефолный Style для `*всех`* контролов 
данного типа, можно отключить const 
lock, чтобы отредактировать статический 
глобальный экземпляр дефолтного 
стиля вашего кастомного контрола 
(или иных, если эти контролы поддерживают 
несколько глобальных стиле, о чём 
смотри ниже). Можно всегда выполнить 
преинициализацию стиля Standard(), определённого
 как`-то как копия от первого зарегистрирован
ного глобального стиля (т.е. StyleDefault()) 
для вашего контрола. Преиниц Standard() 
позволяет не писать много кода, а 
только поменять некоторые свойства. 
Также надо уметь восстановить изменённый 
StyleDefault  в предыдущее состояние.]&]
[s0;2 &]
[s0; [C1 -|EditField`::Style`& es `= EditField`::StyleDefault().Write();]&]
[s0;C1 &]
[s0; [C1 -|es `= es.Standard();]&]
[s0; [C1 -|es.paper `= SColorPaper();]&]
[s0; [C1 -|es.disabled `= SColorFace();]&]
[s0; [C1 -|es.focus `= Blend(Green(), Black(), 192);]&]
[s0;2 &]
[s0; [2 главное приложение должно обновить 
 все экземпляры контролов по окончании 
обновления нужных стилей]&]
[s0; [C1  -|RefreshLayoutDeep();]&]
[s0;2 &]
[s0; [2 У некоторых Ctrl`'ов могут иметься 
несколько глобальных стилей (напр., 
у Button). Если и вашим Ctrl`'ам нужно большего, 
просто примените другой макрос CH`_STYLE, 
обеспечив это. Не забудьте определить 
его в .h точно так же, как и StyleDefault. 
Теперь ваш Ctrl может быть построен 
`"параметрированно`", либо использовать 
другой дефолтный стиль Style (Button`::StyleNormal, 
Button`::StyleOk..)]&]
[s0;2 &]
[s0; [2 Что касается `"хамелионизированных`" 
вспомогательных функций, ][C2 ChPaint,][2 возможно, 
единственная, которая вам понадобится. 
Другие применяются для внутреннего 
пользования в движке OS theming. Краса 
и краеугольный камень ChPaint и Chameleon 
в том, что ChPaint ожидает Value и может 
быть расширен w.r.t. Value, типами, которые 
он способен отображать. Есть два основных 
типа, прямо поддерживаемых в Draw: Color 
и Image. Image (Отображение) имеет логику 
`"hotspots`" (`"горячие точки`"), чтобы определять 
`"интеллегентное масштабирование`", 
а цвет (Color) говорит сам за себя, не 
требуя пояснений. Распознаваемые 
типы можно расширять с помощью ChLookFn. 
Так, напр., XP chameleon регистрирует свой 
внутренний тип Value,`"XpElement`", и способен 
использовать систему отображения 
в стиле XP , чтобы отображать Values из 
Styles. (благодаря Mirek`'у)]&]
[s0;2 &]
[s0; [2 Для отрисовку фонового цвета используется 
SColorFace, для текста `-  SColorText, для контролов 
`- SColorPaper, реально отрисовывающие некоторые 
данные (графы, фон текст в Editfields (полях 
редактирования)). Вот список общих 
дериватов SColor...:]&]
[s0; [2 (iт.е. значения, используемые для 
тёмного dark look, BLENDIT `= 180, должны с самого 
начала быть установлены в приложении, 
но они отнюдь не используются во всех 
Ctrl`'ах upp.)]&]
[s0;2 &]
[s0; [C2 -|SColorPaper`_Write(Blend(White(), Black(), BLENDIT`-20));]&]
[s0; [C2 -|SColorText`_Write(LtGray());]&]
[s0; [C2 -|SColorHighlight`_Write(Gray());]&]
[s0; [C2 -|SColorHighlightText`_Write(White());]&]
[s0; [C2 -|SColorMenu`_Write(SColorPaper());]&]
[s0; [C2 -|SColorMenuText`_Write(SColorText());]&]
[s0; [C2 -|SColorInfo`_Write(SColorPaper());]&]
[s0; [C2 -|SColorInfoText`_Write(SColorText());]&]
[s0; [C2 -|SColorMark`_Write(SColorText());]&]
[s0; [C2 -|SColorDisabled`_Write(Blend(White(), Black(), BLENDIT/2));]&]
[s0; [C2 -|SColorLight`_Write(SColorText());]&]
[s0; [C2 -|SColorFace`_Write(Blend(White(), Black(), BLENDIT));]&]
[s0; [C2 -|SColorLabel`_Write(SColorText());]&]
[s0; [C2 -|SColorShadow`_Write(Black());]&]
[s0;C2 &]
[s0; [C2 -|SColorLtFace`_Write(LtGray());]&]
[s0; [C2 -|SColorDkShadow`_Write(Gray());]&]
[s0;C2 &]
[s0; [C2 -|LabelBoxTextColor`_Write(SColorText());]&]
[s0; [C2 -|LabelBoxColor`_Write(SColorHighlight());]&]
[s0;2 &]
[s0; [2 `"Поиграйтесь`" (`=потренируйтесь) 
с этими Colors (колорами), чтобы узнать, 
как они влияют на uppsrc :)]&]
[s0;2 &]
[s0; [2 Chameleon не так уж и сложен, проблема 
в том, что код под ним очень замысловат, 
что и затрудняет данное документирование....]]]