topic "Класс Index";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,0#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[ {{10000@(113.42.0) [s0; [*@7;4 Класс Index]]}}&]
[s3; &]
[s1;:noref:%- [@(0.0.255)3 template][3 _<][@(0.0.255)3 class][3 _][*@4;3 T][3 >]&]
[s1;:Index`:`:class:%- [@(0.0.255) class]_[* Index]&]
[s8; [*@4 T]-|Тип элемента, сохраняемого в Index. 
T обязательно должен быть [/^topic`:`/`/Core`/srcdoc`/Moveable`_ru`-ru^ m
oveable][/  ]и иметь [/^topic`:`/`/Core`/srcdoc`/pick`_`_ru`-ru^ констру
ктор глубокой копии] и присваивание 
глубокой копии.&]
[s0; &]
[s0; Подобно всем прочим контейнерам 
NTL, Index имеет тип [*/^topic`:`/`/Core`/srcdoc`/Moveable`$en`-us^ moveabl
e][*/  ]с семантикой трансфера [*/^topic`:`/`/Core`/srcdoc`/pick`_`$en`-us^ p
ick and optional deep copy].&]
[s9; Index добавляет в Vector ассоциативные 
способности.&]
[s9; Он позволяет добавлять элементы 
в конец последовательности за константное 
`"аммортизированное`" время, как в 
базовый контейнер случайного доступа. 
Дополнительно позволяет быстро получать 
позицию элемента с указанным значением. 
Реализация основана на хэш`-таблицах. 
Index сохраняет хэш`-значения элементов, 
ему не приходится кэшировать их на 
стороне.&]
[s9; Удаление элементов из Index проявляет 
интересную проблему. Хотя и возможно 
просто удалить (или вставить) элемент 
по заданной позиции, но такой операции 
приходится перемещать много элементов, 
к тому же она повреждает внутренние 
хэш`-мапы. В итоге подобное удаление 
оказывается медленным, особенно в 
сочетании с поиском.&]
[s9; Решением данной проблемы является 
[* отлинковывание ]([*/ unlinking)] элементов. 
Отлинкованные элементы не удаляются 
из Index`'а, но [*/ игнорируются][/  ]операциями 
поиска. Отлинковывание является простой, 
быстрой (с константным временем) операцией. 
Далее можно помещать элемент в первую 
доступную отлинкованную позицию 
(а не в конец последовательности), 
посредством метода [* Put], повторно используя 
`"отлинкнутую`" позицию в константное 
короткое время.&]
[s9; Единственной проблемой `"отлинкивания`" 
является нарушение так называемого[*  
мультиключевого упорядочивания (multi`-key 
ordering)]. Этот термин означает, что если 
в индексе много элементов с одинаковым 
значением и обход их осуществляется 
посредством метода FindNext, то их позиции 
(полученные как результат метода 
Find и последующего FindNext) находятся 
в восходящем порядке. Проблема состоит 
в том, что не удаётся реализовать 
помещение элементов, расположенных 
в отлинкнутых позициях, за короткое 
время, при этом сохраняя данное упорядочиван
ие. С другой стороны, сценарии использования
 индексов показывают, что одновременная 
необходимость в отлинкивании и мультиключев
ом упорядочивание возникает крайне 
редко. Во всяком случае, можно всегда 
восстановить упорядочивание с помощью 
метода [* Sweep].&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0; [* Список Публичных Членов]]}}&]
[s3;%- &]
[s5;:Index`:`:Index`(`):%- [* Index]()&]
[s2; Конструирует пустой Index.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:Index`:`:Index`(Upp`:`:Index`&`&`):%- [* Index]([* Index][@(0.0.255) `&`&]_[*@3 s
])&]
[s2; Пик`-конструктор.&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Index`(pick`_ Vector`<T`>`&`):%- [* Index]([@(0.128.128) pick`_]_[_^Vector^ V
ector][@(0.0.255) <][*@4 T][@(0.0.255) >`&]_[*@3 s])&]
[s2; Пик`-оператор. Переносит исходный 
Vector в Index за небольшое константное 
время, но разрушает его при пикинге.&]
[s7; [*C@3 x]-|Исходный Vector.&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Index`(const Index`&`,int`):%- [* Index]([@(0.0.255) const]_[* Index][@(0.0.255) `&
]_[*@3 s], [@(0.0.255) int])&]
[s2; Опционный конструктор глубокой копии.&]
[s6; Требует, чтобы у T имелся конструктор 
глубокой копии или опционный конструктор 
глубокой копии.&]
[s7; [*C@3 s]-|Исходный Index.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:Index`:`:Index`(Upp`:`:Vector`<T`>`&`&`):%- [@(0.0.255) explicit]_[* Index]([_^Upp`:`:Vector^ V
ector]<[*@4 T]>`&`&_[*@3 s])&]
[s2; Пик`-конструирует Index из Vector`'а.&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Index`(const Vector`<T`>`&`,int`):%- [* Index]([@(0.0.255) const]_[_^Vector^ V
ector][@(0.0.255) <][*@4 T][@(0.0.255) >`&]_[*@3 s], [@(0.0.255) int])&]
[s2; Делает глубокую копию Index`'а из Vector`'а.&]
[s6; Требует, чтобы у T имелся конструктор 
глубокой копии или опционный конструктор 
глубокой копии.&]
[s7; [*@3 s]-|Исходный Vector.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:Index`:`:operator`=`(Upp`:`:Vector`<T`>`&`&`):%- [_^Upp`:`:Index^ Index][@(0.0.255) `&
]_[* operator`=]([_^Upp`:`:Vector^ Vector]<[*@4 T]>`&`&_[*@3 x])&]
[s2; Пик`-присваивание из Vector`'а.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:Index`:`:operator`=`(Upp`:`:Index`<T`>`&`&`):%- [_^Upp`:`:Index^ Index][@(0.0.255) `&
]_[* operator`=]([_^Upp`:`:Index^ Index]<[*@4 T]>`&`&_[*@3 x])&]
[s2; Пик`-присваивание.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:Index`:`:Index`(std`:`:initializer`_list`<T`>`):%- [* Index]([_^http`:`/`/en`.cppreference`.com`/w`/cpp`/utility`/initializer`_list^ s
td`::initializer`_list]<[*@4 T]>_[*@3 init])&]
[s6;%- Инициализация C`+`+ 11.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Add`(const T`&`,unsigned`):%- [*@4 T][@(0.0.255) `&]_[* Add]([@(0.0.255) const]_
[*@4 T][@(0.0.255) `&]_[*@3 x], [@(0.0.255) unsigned]_[*@3 `_hash])&]
[s5;:Upp`:`:Index`:`:Add`(T`&`&`,unsigned`):%- [*@4 T][@(0.0.255) `&]_[* Add]([*@4 T][@(0.0.255) `&
`&]_[*@3 x], [@(0.0.255) unsigned]_[*@3 `_hash])&]
[s2; Добавляет новый элемент [%-@3 x] с предварительн
о вычисленным значением хэша [%-@3 `_hash]. 
Преимущество в производительность 
этого варианта состоит в том, что 
иногда хэш`-значение может вычисляться 
как часть другого процесса, как получение 
строк из потока ввода. Возвращает 
ссылку на этот элемент.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index..&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Add`(const T`&`):%- [*@4 T][@(0.0.255) `&]_[* Add]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&
]_[*@3 x])&]
[s5;:Upp`:`:Index`:`:Add`(T`&`&`):%- [*@4 T][@(0.0.255) `&]_[* Add]([*@4 T][@(0.0.255) `&`&]_[*@3 x
])&]
[s2; Добавляет новый элемент [%-@3 x ]в Index. 
Возвращает ссылку на элемент.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:Index`:`:operator`<`<`(const T`&`):%- [_^Upp`:`:Index^ Index][@(0.0.255) `&]_
[* operator<<]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 x])&]
[s5;:Upp`:`:Index`:`:operator`<`<`(T`&`&`):%- [_^Upp`:`:Index^ Index][@(0.0.255) `&]_[* ope
rator<<]([*@4 T][@(0.0.255) `&`&]_[*@3 x])&]
[s2; То же, что и Add([%-*@3 x]).&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Find`(const T`&`,unsigned`)const:%- [@(0.0.255) int]_[* Find]([@(0.0.255) con
st]_[*@4 T][@(0.0.255) `&]_[*@3 x], [@(0.0.255) unsigned]_[*@3 `_hash])_[@(0.0.255) const]&]
[s2; Возвращает позицию первого элемента 
со значением [%-*@3 x] в Index`'е, используя 
предварительно вычисленный [%-*@3 `_hash]. 
Если мультиключевое упорядочивание 
не повреждено и более одного элемента 
с одинаковым значением есть в AIndex, 
то возвращается наименьшая (самая 
нижняя) позиция. Если указанное значение 
отсутствует в AIndex, возвращается отрицательн
ое число. Отлинкованные элементы 
игнорируются.&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Find`(const T`&`)const:%- [@(0.0.255) int]_[* Find]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&
]_[*@3 x])_[@(0.0.255) const]&]
[s2; Возвращает позицию первого элемента 
со значением [%-*@3 x] в AIndex`'е. Если мультиключево
е упорядочивание не повреждено и 
более одного элемента с одинаковым 
значением есть в AIndex, то возвращается 
наименьшая (самая нижняя) позиция. 
Если указанное значение отсутствует 
в AIndex, возвращается отрицательное 
число. Отлинкованные элементы игнорируются.
&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:FindNext`(int`)const:%- [@(0.0.255) int]_[* FindNext]([@(0.0.255) int]_[*@3 i])
_[@(0.0.255) const]&]
[s2; Возвращает позицию следующего элемента 
с таким же значением, как у элемента 
в [%-*@3 i]. Если мультиключевое упорядочивание 
не нарушено и более одного элемента 
с этим значением находится в AIndex, 
выводится самая низкая позиция, большая 
указанной, а позиции, возвращаемые 
последующими вызовами FindNext, будут 
в восходящем порядке. Когда не остаётся 
элементов с требуемым значением, 
возвращается отрицательное число. 
Отлинкованные элементы игнорируются.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:FindLast`(const T`&`,unsigned`)const:%- [@(0.0.255) int]_[* FindLast]([@(0.0.255) c
onst]_[*@4 T][@(0.0.255) `&]_[*@3 x], [@(0.0.255) unsigned]_[*@3 `_hash])_[@(0.0.255) const]&]
[s2; Возвращает позицию последнего элемента 
со значением [%-*@3 x] в AIndex, используется 
предварительно вычисленный хэш [%-*@3 `_hash]. 
Если мультиключевое упорядочивание 
не нарушено и более одного элемента 
с одинаковым значением находится 
в AIndex, выводится наибольшая позиция. 
Если указанного значение нет в AIndex, 
возвращается отрицательное число. 
Отлинкованные элементы игнорируются.&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:FindLast`(const T`&`)const:%- [@(0.0.255) int]_[* FindLast]([@(0.0.255) const
]_[*@4 T][@(0.0.255) `&]_[*@3 x])_[@(0.0.255) const]&]
[s2; Возвращает позицию последнего элемента 
со значением [%-*@3 x] в AIndex. Если мультиключевое 
упорядочивание не нарушено и более 
одного элемента с одинаковым значением 
находится в AIndex, выводится наибольшая 
позиция. Если указанного значение 
больше нет в AIndex, возвращается отрицательное
 число. Отлинкованные элементы игнорируются
.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:FindPrev`(int`)const:%- [@(0.0.255) int]_[* FindPrev]([@(0.0.255) int]_[*@3 i])
_[@(0.0.255) const]&]
[s2; Возвращает позицию предыдущего элемента 
с тем же значением, что у элемента 
в [%- _][%-*@3 i]. Если мультиключевое упорядочивание
 не нарушено и более одного элемента 
с одинаковым значением находится 
в AIndex, выводится наибольшая позиция, 
расположенная ниже, чем указанная 
(так, что позиции, получаемые при последующих
 вызовах FindNext, располагаются в нисходящем 
порядке). Если указанного значение 
больше нет в AIndex, возвращается отрицательное
 число. Отлинкованные элементы игнорируются
.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:FindAdd`(const T`&`,unsigned`):%- [@(0.0.255) int]_[* FindAdd]([@(0.0.255) co
nst]_[*@4 T][@(0.0.255) `&]_[*@3 key], [@(0.0.255) unsigned]_[*@3 `_hash])&]
[s5;:Upp`:`:Index`:`:FindAdd`(T`&`&`,unsigned`):%- [@(0.0.255) int]_[* FindAdd]([*@4 T][@(0.0.255) `&
`&]_[*@3 `_key], [@(0.0.255) unsigned]_[*@3 `_hash])&]
[s2; Получает позицию первого элемента 
со значением [%-*@3 key] в AIndex, используя 
предварительно вычисленный хэш [%-*@3 `_hash]. 
Если мультиключевое упорядочивание 
не нарушено и более одного элемента 
с одинаковым значением находится 
в AIndex, то выводится наибольшая позиция. 
Если элемента нет в AIndex, то он добавляется 
и возвращается позиция этого, вновь 
добавленного, элемента. Отлинкованные 
элементы игнорируются.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:FindAdd`(const T`&`):%- [@(0.0.255) int]_[* FindAdd]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&
]_[*@3 key])&]
[s5;:Upp`:`:Index`:`:FindAdd`(T`&`&`):%- [@(0.0.255) int]_[* FindAdd]([*@4 T]`&`&_[*@3 key])&]
[s2; Получает позицию первого элемента 
со значением [%-*@3 key] в AIndex. Если мультиключевое
 упорядочивание не повреждено и более 
одного элемента с одинаковым значением 
есть в AIndex, то возвращается наименьшая 
(самая нижняя) позиция. Если элемента 
нет в AIndex, то он добавляется в него 
и возвращается позиция этого, вновь 
добавленного, элемента. Отлинкованные 
элементы игнорируются.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Unlink`(int`):%- [@(0.0.255) void]_[* Unlink]([@(0.0.255) int]_[*@3 i])&]
[s2; Отлинковывает элемент, расположенный 
в [%-*@3 i]. Отлинкованные элементы остаются 
в AIndex, но игнорируются любой операцией 
поиска Find.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Put`(const T`&`,unsigned`):%- [@(0.0.255) int]_[* Put]([@(0.0.255) const]_[*@4 T
][@(0.0.255) `&]_[*@3 x], [@(0.0.255) unsigned]_[*@3 `_hash])&]
[s5;:Upp`:`:Index`:`:Put`(T`&`&`,unsigned`):%- [@(0.0.255) template]_<[@(0.0.255) class]_
[*@4 T]>_[@(0.0.255) int]_[* Put]([*@4 T][@(0.0.255) `&`&]_[*@3 x], [@(0.0.255) unsigned]_[*@3 `_
hash])&]
[s2; Если в Индексе есть какие`-либо отлинкованны
е элементы, один из них заменяется 
на [%-*@3 x]. Если таких элементов нет, 
то элемент с заданным значением приставляет
ся в конце AIndex посредством [* Add]. Возвращается 
позиция вновь добавленного элемента.&]
[s6; Повреждает мультиключевое упорядочивание.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s2;  [%-*@3 x] .&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Put`(const T`&`):%- [@(0.0.255) int]_[* Put]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&
]_[*@3 x])&]
[s5;:Upp`:`:Index`:`:Put`(T`&`&`):%- [@(0.0.255) int]_[* Put]([*@4 T][@(0.0.255) `&`&]_[*@3 x])
&]
[s2; Если в Индексе есть какие`-либо отлинкованны
е элементы, один из них заменяется 
на [%-*@3 x]. Если таких элементов нет, 
то элемент с заданным значением приставляет
ся в конце AIndex посредством [* Add]. Возвращается 
позиция вновь добавленного элемента.&]
[s6; Повреждает мультиключевое упорядочивание.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:FindPut`(const T`&`,unsigned`):%- [@(0.0.255) int]_[* FindPut]([@(0.0.255) co
nst]_[*@4 T][@(0.0.255) `&]_[*@3 key], [@(0.0.255) unsigned]_[*@3 `_hash])&]
[s5;:Upp`:`:Index`:`:FindPut`(T`&`&`,unsigned`):%- [@(0.0.255) int]_[* FindPut]([*@4 T][@(0.0.255) `&
`&]_[*@3 key], [@(0.0.255) unsigned]_[*@3 hash])&]
[s2; Получает позицию первого элемента 
со значением [%-*@3 key] в AIndex, используя 
предварительно вычисленный хэш [%-*@3 `_hash]. 
Предварительно вычисленное хэш`-значение 
должно быть таким же, как получаемое 
при помощи HashFn. Если указанное значение 
отсутствует в AIndex, то оно помещается 
в него посредством [* Put(const T`& x, unsigned 
`_hash).] Возвращается позиция найденного 
или размещённого элемента.&]
[s6;~~~.992; Повреждает мультиключевое упорядочива
ние.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s2;  [%-*@3 key] .&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:FindPut`(const T`&`):%- [@(0.0.255) int]_[* FindPut]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&
]_[*@3 key])&]
[s5;:Upp`:`:Index`:`:FindPut`(T`&`&`):%- [@(0.0.255) int]_[* FindPut]([*@4 T][@(0.0.255) `&`&
]_[*@3 key])&]
[s2; Получает позицию первого элемента 
со значением [%-*@3 key] в AIndex. Если указанное 
значение отсутствует в AIndex, то оно 
помещается в него посредством [* Put(const 
T`& x).] Возвращается позиция найденного 
или размещённого элемента.&]
[s6; Повреждает мультиключевое упорядочивание.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Set`(int`,const T`&`,unsigned`):%- [*@4 T][@(0.0.255) `&]_[* Set]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 x], [@(0.0.255) unsigned]_[*@3 `_ha
sh])&]
[s5;:Upp`:`:Index`:`:Set`(int`,T`&`&`,unsigned`):%- [*@4 T][@(0.0.255) `&]_[* Set]([@(0.0.255) i
nt]_[*@3 i], [*@4 T][@(0.0.255) `&`&]_[*@3 x], [@(0.0.255) unsigned]_[*@3 `_hash])&]
[s2; Заменяет элемент в заданной позиции 
на новый элемент со значением [%-*@3 x], 
используя предварительно вычисленный 
хэш [%-*@3 `_hash]. Скорость этой операции 
зависит от общего числа элементов 
с одинаковыми значениями, такими 
же, как указанное. Возвращает ссылку 
на этот элемент.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Set`(int`,const T`&`):%- [*@4 T][@(0.0.255) `&]_[* Set]([@(0.0.255) int]_[*@3 i],
 [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 x])&]
[s5;:Upp`:`:Index`:`:Set`(int`,T`&`&`):%- [*@4 T][@(0.0.255) `&]_[* Set]([@(0.0.255) int]_[*@3 i
], [*@4 T][@(0.0.255) `&`&]_[*@3 x])&]
[s2; Заменяет элемент в указанной позиции 
на новый элемент со значением [%-*@3 x]. 
Скорость этой операции зависит от 
общего числа элементов с одинаковыми 
значениями, такими же, как указанное. 
Возвращает ссылку на этот элемент.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:operator`[`]`(int`)const:%- [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[* operat
or`[`]]([@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2; Возвращает элемент в заданной позиции.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:GetCount`(`)const:%- [@(0.0.255) int]_[* GetCount]()_[@(0.0.255) const]&]
[s2; Возвращает число элементов в AIndex.&]
[s3;%- &]
[s4;%- &]
[s5;:Upp`:`:Index`:`:begin`(`)const:%- [_^Upp`:`:Index`:`:ConstIterator^ ConstIterator]_
[* begin]()_[@(0.0.255) const]&]
[s5;:Upp`:`:Index`:`:end`(`)const:%- [_^Upp`:`:Index`:`:ConstIterator^ ConstIterator]_[* e
nd]()_[@(0.0.255) const]&]
[s2;%- Стандартный методы begin/end (начало/конец).&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:IsEmpty`(`)const:%- [@(0.0.255) bool]_[* IsEmpty]()_[@(0.0.255) const]&]
[s2; Проверяет, пуст ли AIndex. То же, что 
и GetCount() `=`= 0.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:GetHash`(int`)const:%- [@(0.0.255) unsigned]_[* GetHash]([@(0.0.255) int]_[*@3 i
])_[@(0.0.255) const]&]
[s2; Возвращает хэш элемента [%-*@3 i]. TПрименимо, 
пожалуй, только при точном копировании 
Index`'а, напр., в постоянное хранилище.&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Clear`(`):%- [@(0.0.255) void]_[* Clear]()&]
[s2; Удаляет все элементы из AIndex.&]
[s3; &]
[s4; &]
[s5;:Index`:`:UnlinkKey`(const T`&`,unsigned`):%- [@(0.0.255) int]_[* UnlinkKey]([@(0.0.255) c
onst]_[*@4 T][@(0.0.255) `&]_[*@3 k], [@(0.0.255) unsigned]_[*@3 `_hash])&]
[s2; Отлинковывает все элементы со значением 
[%-*@3 k], используя предварительно вычисленный 
[%-*@3 `_hash]. Отлинкованные элементы остаются 
в этом AIndex`'е, но игнорируются всякими 
операциями поиска Find.&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:UnlinkKey`(const T`&`):%- [@(0.0.255) int]_[* UnlinkKey]([@(0.0.255) const]_[*@4 T
][@(0.0.255) `&]_[*@3 k])&]
[s2; Отлинковывает все элементы со значением 
[%-*@3 k]. Отлинкованные элементы остаются 
в этом AIndex`'е, но игнорируются всякими 
операциями поиска Find.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:IsUnlinked`(int`)const:%- [@(0.0.255) bool]_[* IsUnlinked]([@(0.0.255) int]_[*@3 i
])_[@(0.0.255) const]&]
[s2; Проверяет, `"отлинкован`" ли элемент 
по индексу [%-*@3 i].&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:GetUnlinked`(`)const:%- [_^Vector^ Vector]<[@(0.0.255) int]>_[* GetUnlinked](
)_[@(0.0.255) const]&]
[s2; Возвращает индексы всех `"отлинкованных`" 
элементов.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Sweep`(`):%- [@(0.0.255) void]_[* Sweep]()&]
[s2; Удаляет все отлинкованные элементы 
из AIndex. Сложность операции зависит 
от числа элементов в AIndex, а не от числа 
отлинкованных элементов. Также восстанавлив
ается мультключевое упорядочивание.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:HasUnlinked`(`)const:%- [@(0.0.255) bool]_[* HasUnlinked]()_[@(0.0.255) const
]&]
[s2; Возвращает true, если в AIndex есть какие`-либо 
отлинкованные элементы.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Insert`(int`,const T`&`,unsigned`):%- [*@4 T][@(0.0.255) `&]_[* Insert]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 k], [@(0.0.255) unsigned]_[*@3 h])&]
[s2; Вставляет элемент со значением [%-*@3 k] 
в заданной позиции [%-*@3 i], используя 
предварительно вычисленный хэш [%-*@3 h]. 
Это медленная операция O(n). Возвращает 
ссылку на элемент.&]
[s6; Требует, чтобы у T имелся конструктор 
глубокой копии.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Insert`(int`,const T`&`):%- [*@4 T][@(0.0.255) `&]_[* Insert]([@(0.0.255) int]_
[*@3 i], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 k])&]
[s2; Вставляет элемент со значением [%-*@3 k] 
у заданной позиции [%-*@3 i]. Это медленная 
операция O(n). Возвращает ссылку на 
этот элемент.&]
[s6; Требует, чтобы у T имелся конструктор 
глубокой копии.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Remove`(int`):%- [@(0.0.255) void]_[* Remove]([@(0.0.255) int]_[*@3 i])&]
[s2; Удаляет элемент в заданной позиции 
[%-*@3 i]. Это медленная операция O(n).&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index..&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Remove`(int`,int`):%- [@(0.0.255) void]_[* Remove]([@(0.0.255) int]_[*@3 i], 
[@(0.0.255) int]_[*@3 count])&]
[s2; Удаляет [%-*@3 count] элементов, начиная 
с [%-*@3 i]. Это медленная операция O(n).&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index..&]
[s3; &]
[s4;%- &]
[s5;:Index`:`:Remove`(const int`*`,int`):%- [@(0.0.255) void]_[* Remove]([@(0.0.255) const]_
[@(0.0.255) int]_`*[*@3 sorted`_list], [@(0.0.255) int]_[*@3 count])&]
[s2; Удаляет несколько элементов из AIndex. 
Время операции немного зависит от 
числа удаляемых элементов. Это медленная 
операция O(n). [%-*@3 sorted`_list] должен указывать 
на [%-*@3 count] позиций, отсортированных 
в восходящем порядке.&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index..&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Remove`(const Vector`<int`>`&`):%- [@(0.0.255) void]_[* Remove]([@(0.0.255) c
onst]_Vector[@(0.0.255) <int>`&]_[*@3 sorted`_list])&]
[s2; Удаляет несколько элементов из AIndex. 
То же, что и Remove(sorted`_list, sorted`_list.GetCount()).&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:RemoveKey`(const T`&`,unsigned`):%- [@(0.0.255) int]_[* RemoveKey]([@(0.0.255) c
onst]_[*@4 T][@(0.0.255) `&]_[*@3 k], [@(0.0.255) unsigned]_[*@3 h])&]
[s2; Удаляет все элементы со значением 
[%-*@3 k], используя предварительно вычисленный 
хэш [%-*@3 h]. Это медленная операция O(n).&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s6;%- Предварительно вычисленный [@3 `_hash] 
должен совпадать с хэшем, определённым 
посредством HashFn.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:RemoveKey`(const T`&`):%- [@(0.0.255) int]_[* RemoveKey]([@(0.0.255) const]_[*@4 T
][@(0.0.255) `&]_[*@3 k])&]
[s2; Удаляет все элементы со значением 
[%-*@3 k]. Это медленная операция O(n).&]
[s6; Повреждает итераторы к AIndex.&]
[s6; Повреждает ссылки на Index.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Trim`(int`):%- [@(0.0.255) void]_[* Trim]([@(0.0.255) int]_[*@3 n])&]
[s2; Снижает число элементов в AIndex до 
[%-*@3 n]. Требуемое число должно быть 
меньше или равно действительному 
числу элементов в AIndex.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Drop`(int`):%- [@(0.0.255) void]_[* Drop]([@(0.0.255) int]_[*@3 n]_`=_[@3 1])&]
[s2; `"Роняет`" [%-*@3 n] элементов в конце AIndex 
(то же, что Trim(GetCount() `- n)).&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Top`(`)const:%- [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[* Top]()_[@(0.0.255) c
onst]&]
[s2; Возвращает ссылку на последний элемент 
в AIndex.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Pop`(`):%- [*@4 T]_[* Pop]()&]
[s2; `"Роняет`" последний элемент в Index 
и возвращает его значение.&]
[s6; Требует, чтобы у T имелся конструктор 
глубокой копии.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Reserve`(int`):%- [@(0.0.255) void]_[* Reserve]([@(0.0.255) int]_[*@3 n])&]
[s2; Резервирует ёмкость. Если [%-*@3 n] больше 
текущей ёмкости, ёмкость увеличивается 
до требуемого значения.&]
[s0; &]
[s4;%- &]
[s5;:Index`:`:Shrink`(`):%- [@(0.0.255) void]_[* Shrink]()&]
[s2; Минимизирует использование памяти 
AIndex`'ом, уменьшением ёмкости до числа 
элементов.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:GetAlloc`(`)const:%- [@(0.0.255) int]_[* GetAlloc]()_[@(0.0.255) const]&]
[s2; Возвращает текущую ёмкость AIndex.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:Serialize`(Stream`&`):%- [@(0.0.255) void]_[* Serialize](Stream[@(0.0.255) `&
]_[*@3 s])&]
[s2; Сериализует контент AIndex в/из потока 
Stream.&]
[s6; Требует, чтобы у T был определён оператор 
сериализации.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:PickKeys`(`):%- [*@4 V]_[* PickKeys]()&]
[s2; Возвращает базовый контейнер элементов 
случайного доступа. Разрушает AIndex 
при пикинге.&]
[s3;%- &]
[s4;%- &]
[s5;:Index`:`:GetKeys`(`)const:%- [@(0.0.255) const]_[*@4 V][@(0.0.255) `&]_[* GetKeys]()_[@(0.0.255) c
onst]&]
[s2; Возвращает константную ссылку на 
базовый контейнер элементов случайного 
доступа.&]
[s0; ]]