topic "Классы AsyncWork и Async";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,2#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_} 
[ {{10000@(113.42.0) [s0;%RU-RU [*@7;4 Классы AsyncWork и Async]]}}&]
[s3; &]
[s1;:noref: [@(0.0.255)3 template][3 _<][@(0.0.255)3 class][3 _][*@4;3 Ret][3 >]&]
[s1;:Upp`:`:AsyncWork`:`:class: [@(0.0.255) class]_[* AsyncWork]&]
[s2;%RU-RU Представляет работу (job), которая 
может быть выполнена в другом потоке, 
и может вернуть значение. Подобно 
паттерну future/promise, но допускает отмену 
и основывается на пуле потоков U`+`+, 
разделяемом с CoWork. AsyncWork имеет pick конструктор
 / оператор.&]
[s3; &]
[ {{10000F(128)G(128)@1 [s0;%RU-RU [* Список Публичных Методов]]}}&]
[s3; &]
[s5;:Upp`:`:AsyncWork`:`:Do`(Upp`:`:Function`&`&`,Args`&`&`.`.`.args`): [@(0.0.255) tem
plate]_<_[@(0.0.255) class]_[*@4 Function], [@(0.0.255) class...]_[*@4 Args]>&]
[s5;:Upp`:`:AsyncWork`:`:Do`(Upp`:`:Function`&`&`,Args`&`&`.`.`.args`): [@(0.0.255) voi
d]_[* Do]([*@4 Function][@(0.0.255) `&`&]_[*@3 f], [*@4 Args][@(0.0.255) `&`&...]_args)&]
[s2;%RU-RU Планирует работу [%-*@3 f] с параметрами 
args на асинхронное выполнение в (по 
возможности) другом потоке.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:AsyncWork`:`:Cancel`(`): [@(0.0.255) void]_[* Cancel]()&]
[s2;%RU-RU Отменяет работу.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:AsyncWork`:`:IsCanceled`(`): [@(0.0.255) static] [@(0.0.255) bool]_[* IsCancele
d]()&]
[s2;%RU-RU Возвращает true [*/ в этой рабочей 
процедуре], если master AsyncWork был отменён.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:AsyncWork`:`:IsFinished`(`): [@(0.0.255) bool]_[* IsFinished]()&]
[s2;%RU-RU Возвращает true, если работа завершена.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:AsyncWork`:`:Get`(`): [*@4 Ret]_[* Get]()&]
[s2;%RU-RU Ждёт окончания работы (при необходимости
), затем возвращает возвратное значение 
[%-*@3 f]. Если при этом были исключения, 
они перебрасываются (rethrown).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:AsyncWork`:`:operator`~`(`): [*@4 Ret]_[* operator`~]()&]
[s2;%RU-RU То же, что и Get().&]
[s2;%RU-RU &]
[s3; &]
[s4; &]
[s5;:Upp`:`:AsyncWork`:`:Pick`(`): [*@4 Ret]_[* Pick]()&]
[s2;%RU-RU Подобно Get, но используется pick`-конструкт
ор, вместо copy`-конструктора, для передачи 
возвратного значения.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:AsyncWork`:`:`~AsyncWork`(`): [@(0.0.255) `~][* AsyncWork]()&]
[s2;%RU-RU Если работа не была завершена, 
деструктор её отменяем.&]
[s3; &]
[ {{10000@(113.42.0) [s0;%RU-RU [*@7;4 Async]]}}&]
[s3; &]
[s5;:Upp`:`:Async`(Upp`:`:Function`&`&`,Args`&`&`.`.`.args`): [@(0.0.255) auto]_[* Async](
[_^Upp`:`:Function^ Function][@(0.0.255) `&`&]_[*@3 f], Args[@(0.0.255) `&`&...]_args)&]
[s2;%RU-RU Возвращает AsyncWork для данной работы 
[%-*@3 f] с аргументами [%- args].&]
[s3;%RU-RU &]
[s0;@(0.0.255)3 ]]