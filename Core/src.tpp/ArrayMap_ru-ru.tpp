topic "Класс ArrayMap";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,0#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[ {{10000@(113.42.0) [s0; [*@7;4 Класс ArrayMap]]}}&]
[s3; &]
[s1;:noref:%- [@(0.0.255)3 template][3 _<][@(0.0.255)3 class][3 _][*@4;3 K][3 , 
][@(0.0.255)3 class][3 _][*@4;3 T][3 , ][@(0.0.255)3 class][3 _][*@4;3 HashFn][3 _`=_StdHash][@(0.0.255)3 <
][*@4;3 K][@(0.0.255)3 >][3 _>]&]
[s1;:ArrayMap`:`:class:%- [@(0.0.255) class]_[* ArrayMap]_:_[@(0.0.255) public]_[*@3 MoveableA
ndDeepCopyOption][@(0.0.255) <]_[* ArrayMap][@(0.0.255) <][*@4 K], [*@4 T], 
[*@4 HashFn][@(0.0.255) >]_>, [@(0.0.255) public]_[*@3 AMap][@(0.0.255) <]_[*@4 K], 
[*@4 T], [_^topic`:`/`/Core`/src`/Array`$en`-us`#Array`:`:class^ Array][@(0.0.255) <][*@4 T
][@(0.0.255) >], [*@4 HashFn]_>_&]
[s8; [*@4 K]-|Тип ключей. K должен иметь конструктор 
глубокой копии, быть [/^dpp`:`/`/SourceDoc`/Containers`/Moveable^ m
oveable] и иметь operator`=`= определённым.&]
[s8; [*@4 T]-|Тип или базовый класс значений, 
хранимых в ArrayMap. Общие требования 
к T отсутствуют.&]
[s8; [*@4 HashFn]-|Хэширующий класс. Должен иметь 
определение беззначного оператора 
operator()(const K`& x), возвращающий хэш`-значение 
для элементов.&]
[s9; Array flavor of map. Большую часть своего 
функционала наследует от [^topic`:`/`/Core`/src`/AMap`$en`-us^ A
Map] и добавляет только члены, специфичные 
для этого flavor.&]
[s9; Как все прочие NTL`-контейнеры, ArrayMap 
является [*/^topic`:`/`/Core`/srcdoc`/Moveable`_ru`-ru^ moveable][*/  
(`"движимым`") ]типом с `"семантикой 
трансфера`" ( transfer semantics), именуемой 
`" [*/^topic`:`/`/Core`/srcdoc`/pick`_`_ru`-ru^ pick и опциональная 
глубокая копия (ОГК)] `". Вызов методов 
`"пикнутого`" VectorMap`'а является логической 
ошибкой, за исключением:&]
[s0; &]
[s0; [C+75 void ][*C+75 operator`=][C+75 (pick`_ ArrayMap`& ][*C@3+75 v][C+75 ) 
][/+75 (определено композицией)]&]
[s0; [C+75 void ][*C+75 operator<<`=][C+75 (const AMap`& ][*C@3+75 v][C+75 )][+75  
][/+75 (определено в AMap)]&]
[s0; [C+75 void ][*C+75 Clear][C+75 ()]&]
[s0; [C+75 bool ][*C+75 IsPicked][C+75 () const]&]
[s9; Опциональный оператор глубокой копии 
наследуется от класса AMap. Pick`-оператор 
косвенно определён самой `"композицией`".&]
[s0; &]
[s0;~~~.416; [* Базовые классы]&]
[s0; [^topic`:`/`/Core`/src`/AMap`$en`-us`#AMap`:`:class^ AMap< K, 
T, Array<T>, HashFn >]&]
[s3; &]
[s0;%- &]
[ {{10000F(128)G(128)@1 [s0; [* Детали Конструктора]]}}&]
[s3;%- &]
[s5;:ArrayMap`:`:ArrayMap`(`):%- [* ArrayMap]()&]
[s2; Дефолтный конструктор. Создаёт пустой 
ArrayMap.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayMap`:`:ArrayMap`(std`:`:initializer`_list`<std`:`:pair`<K`,T`>`>`):%- [* A
rrayMap]([_^http`:`/`/en`.cppreference`.com`/w`/cpp`/utility`/initializer`_list^ st
d`::initializer`_list]<[_^http`:`/`/en`.cppreference`.com`/w`/cpp`/utility`/pair^ st
d`::pair]<[*@4 K], [*@4 T]>>_[*@3 init])&]
[s2; C`+`+ 11 инициализация.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayMap`:`:operator`(`)`(KK`&`&`,TT`&`&`):%- [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 KK], [@(0.0.255) class]_[*@4 TT]>_[*_^Upp`:`:ArrayMap^ ArrayMap][@(0.0.255) `&]_
[* operator()]([*@4 KK][@(0.0.255) `&`&]_[*@3 k], [*@4 TT][@(0.0.255) `&`&]_[*@3 v])&]
[s2; То же, что и Add([%-*@3 k], [%-*@3 v]), возвращает 
`*this. Синтактический `"сахар`" для создания 
map. Заметьте, что применена универсальная 
ссылка, которая разрешается (`"резольвируетс
я`") для того, чтобы скорректировать 
вариант Add.&]
[s3; &]
[s4;%- &]
[s5;:ArrayMap`:`:ArrayMap`(const ArrayMap`&`,int`):%- [* ArrayMap]([@(0.0.255) const]_[* Ar
rayMap][@(0.0.255) `&]_[*@3 s], [@(0.0.255) int])&]
[s2; Опциональный конструктор глубокой 
копии (ОКГК).&]
[s6; Требуется, чтобы у T был конструктор 
глубокой копии (КГК) или опциональный 
КГК (ОКГК), если в массиве находятся 
только объекты типа T.&]
[s6; Требуется полиморфная глубокая копия 
(ПГК), если в Array также находятся объекты, 
производного то Т, типа.&]
[s7; [*C@3 s]-|Исходны ArrayMap.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayMap`:`:ArrayMap`(Upp`:`:Index`<K`>`&`&`,Upp`:`:Array`<T`>`&`&`):%- [* A
rrayMap]([_^Upp`:`:Index^ Index]<[*@4 K]>`&`&_[*@3 ndx], [_^Upp`:`:Array^ Array]<[*@4 T]>`&
`&_[*@3 val])&]
[s2; Pick`-конструирует ArrayMap из Index`'а ключей 
и Array`'я значений. Исходные контейнеры 
должны обладать одинаковым числом 
элементов.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayMap`:`:ArrayMap`(Upp`:`:Vector`<K`>`&`&`,Upp`:`:Array`<T`>`&`&`):%- [* A
rrayMap]([_^Upp`:`:Vector^ Vector]<[*@4 K]>`&`&_[*@3 ndx], [_^Upp`:`:Array^ Array]<[*@4 T]>
`&`&_[*@3 val])&]
[s2; Pick`-конструирует ArrayMap из Vector`'а ключей 
и Array`'я значений. Исходные контейнеры 
должны обладать одинаковым числом 
элементов.&]
[s0; &]
[ {{10000F(128)G(128)@1 [s0; [* Список Публичных Членов]]}}&]
[s3;%- &]
[s5;:ArrayMap`:`:Add`(const K`&`,const T`&`):%- [*@4 T][@(0.0.255) `&]_[* Add]([@(0.0.255) co
nst]_[*@4 K][@(0.0.255) `&]_[*@3 k], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 x])&]
[s5;:Upp`:`:ArrayMap`:`:Add`(const K`&`,T`&`&`):%- [*@4 T][@(0.0.255) `&]_[* Add]([@(0.0.255) c
onst]_[*@4 K][@(0.0.255) `&]_[*@3 k], [*@4 T][@(0.0.255) `&`&]_[*@3 x])&]
[s5;:ArrayMap`:`:Add`(const K`&`):%- [*@4 T][@(0.0.255) `&]_[* Add]([@(0.0.255) const]_[*@4 K][@(0.0.255) `&
]_[*@3 k])&]
[s5;:ArrayMap`:`:Add`(const K`&`,T`*`):%- [*@4 T][@(0.0.255) `&]_[* Add]([@(0.0.255) const]_[*@4 K
][@(0.0.255) `&]_[*@3 k], [*@4 T]_`*[*@3 newt])&]
[s5;:Upp`:`:ArrayMap`:`:Add`(K`&`&`,const T`&`):%- [*@4 T][@(0.0.255) `&]_[* Add]([*@4 K][@(0.0.255) `&
`&]_[*@3 k], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 x])&]
[s5;:Upp`:`:ArrayMap`:`:Add`(K`&`&`,T`&`&`):%- [*@4 T][@(0.0.255) `&]_[* Add]([*@4 K][@(0.0.255) `&
`&]_[*@3 k], [*@4 T][@(0.0.255) `&`&]_[*@3 x])&]
[s5;:Upp`:`:ArrayMap`:`:Add`(K`&`&`):%- [*@4 T][@(0.0.255) `&]_[* Add]([*@4 K][@(0.0.255) `&`&]_
[*@3 k])&]
[s5;:Upp`:`:ArrayMap`:`:Add`(K`&`&`,T`*`):%- [*@4 T][@(0.0.255) `&]_[* Add]([*@4 K][@(0.0.255) `&
`&]_[*@3 k], [*@4 T]_`*[*@3 newt])&]
[s2; Добавляет пару ключ`-значение в этот 
ArrayMap. [%-*@3 newt] задаёт новое значение 
как указатель на объект, созданный 
дефолтным оператором `'new`' на куче. 
ArrayMap перенимает права владения этим 
объектом. Этот вариант допускает 
использование ArrayMap как полиморфного 
контейнера, так как тип добавленных 
элементов также может производиться 
от T. Value может также копироваться 
`"пикингом`" из [%-*@3 x] или дефолтно конструирова
ться.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayMap`:`:Insert`(int`,const K`&`,T`*`):%- [*@4 T][@(0.0.255) `&]_[* Insert](
[@(0.0.255) int]_[*@3 i], [@(0.0.255) const]_[*@4 K][@(0.0.255) `&]_[*@3 k], 
[*@4 T]_`*[*@3 newt])&]
[s5;:Upp`:`:ArrayMap`:`:Insert`(int`,K`&`&`,T`*`):%- [*@4 T][@(0.0.255) `&]_[* Insert]([@(0.0.255) i
nt]_[*@3 i], [*@4 K][@(0.0.255) `&`&]_[*@3 k], [*@4 T]_`*[*@3 newt])&]
[s2; Вставляет пару ключ`-значение в ArrayMap. 
[%-*@3 newt] задаёт новое значение как указатель 
на объект, созданный дефолтным оператором 
`'new`' на куче. ArrayMap перенимает права 
владения этим объектом&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayMap`:`:Create`(const K`&`,Args`&`&`.`.`.args`):%- [@(0.0.255) template
]_<[@(0.0.255) class]_[*@4 TT], [@(0.0.255) class...]_[*@4 Args]>_[*@4 TT][@(0.0.255) `&]_[* Cr
eate]([@(0.0.255) const]_[*@4 K][@(0.0.255) `&]_[*@3 k], [*@4 Args][@(0.0.255) `&`&...]_args)
&]
[s5;:Upp`:`:ArrayMap`:`:Create`(K`&`&`,Args`&`&`.`.`.args`):%- [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 TT], [@(0.0.255) class...]_[*@4 Args]>_[*@4 TT][@(0.0.255) `&]_[* Create]([*@4 K][@(0.0.255) `&
`&]_[*@3 k], [*@4 Args][@(0.0.255) `&`&...]_args)&]
[s2;%- [%RU-RU Добавляет новый ключ ][*@3 k][%RU-RU  
с элементом значения типа ][*@4 TT][%RU-RU  
(должен быть производным от ][*@4 T]). Value 
конструируется `"на месте`", с args в 
качестве параметров конструктора.&]
[s3; &]
[s4;%- &]
[s5;:ArrayMap`:`:Set`(int`,T`*`):%- [*@4 T][@(0.0.255) `&]_[* Set]([@(0.0.255) int]_[*@3 i], 
[*@4 T]_`*[*@3 ptr])&]
[s2; Устанавливает значение по указанному 
индексу. Value определяется по указателю 
на этот объект.ArrayMap берёт `"в собственность`" 
этот объект. Возвращает ся ссылка 
на этот элемент.&]
[s3; &]
[s4;%- &]
[s5;:ArrayMap`:`:PopDetach`(`):%- [*@4 T]_`*[* PopDetach]()&]
[s2; `"Роняет`" последний элемент в ArrayMap, 
`"отвергая`" права собственности на 
это значение. Клиент ответственен 
за удаление этого элемента.&]
[s6; Повреждает итераторы в ArrayMap.&]
[s7; [* Возвратное значение]-|Значение.&]
[s3; &]
[s4;%- &]
[s5;:ArrayMap`:`:Detach`(int`):%- [*@4 T]_`*[* Detach]([@(0.0.255) int]_[*@3 i])&]
[s2; Удаляет элемент [%-*@3 i], но не рущит 
его (фактически оставляя на куче или 
в оперативной памяти). Возвращает ся 
указатель на этот элемент в куче. 
Клиент ответственен за удаление этого 
элемента.&]
[s3; &]
[s4;%- &]
[s5;:ArrayMap`:`:Swap`(int`,T`*`):%- [*@4 T]_`*[* Swap]([@(0.0.255) int]_[*@3 i], 
[*@4 T]_`*[*@3 newt])&]
[s2; Устанавливает элемент по [%-*@3 i ]на 
новое значение [%-*@3 newt ]и возвращает 
указатель на оригинальный элемент. 
Клиент ответственен за его удаление.&]
[s3; &]
[s0; ]]