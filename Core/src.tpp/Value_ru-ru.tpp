topic "Класс Value";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,2#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[ {{10000@(113.42.0) [s0; [*@7;4 Класс Value]]}}&]
[s1;@(0.0.255)3%- &]
[s1;:Value`:`:class:%- [@(0.0.255)3 class][3 _][*3 Value][3 _:_][@(0.0.255)3 private][3 _][*@3;3 Mov
eable][3 <][*3 Value][3 >_]&]
[s2; Value `- это тип конкретного значения 
(с нормальной семантикой глубокой 
копии), который предназначен для хранения 
других конкретных типов одним общим 
способом, но фактически может хранить 
почти любой иной тип данных.&]
[s2; &]
[s2; Есть два основных уровня совместимости 
Value. Данные могут сохраняться в Value 
`"сырыми`" (`"raw`") `- т.е. только рабочие 
операции такого значения могут проверять, 
содержится ли в нём значение этого 
типа, и извлекать константную ссылку 
на сохраняемое значение.&]
[s2; &]
[s2; Типы `"Rich`" Value предоставляют более 
унифицированный функционал: сравнение, 
хэширование, сериализацию, json`'изацию, 
xml`'изацию, проверку на Null, преобразование 
в текст и проч. Типы Rich также предоставляют 
некий уровень совместимости преобразований
: напр., Value, содержащее integer, может извлекаться
 в double. Заметьте, что Value, содержащее 
Null, может (обычно) извлекаться в любой 
совместимый тип (напр., Null Date можно 
присвоить integer`'у).&]
[s2; &]
[s2; В целях оптимизации имеется две подгруппы 
типов `"Rich`" `- нормальные и `"SVO`" (`"Small 
Value Optimization`" `- оптимизация небольших 
значений). Типы SVO имеют больше ограничений: 
они должны быть POD`'ами и умещаться 
в 8 байтов; такие типы сохраняются 
более эффективно (они сохраняются 
прямо в тело Value, в то время как иные 
значения сохраняются косвенно, используя 
указатель со счётчиком ссылок).&]
[s2; &]
[s2; Базовый класс Value обеспечивает поддержку 
некоторых фундаментальных типов 
и типов `"стандартного значения`": bool, 
int, int64, double, String, WString, Date и Time. Есть также 
особые типы Void (для пустого Value) и ErrorValue 
(представляет ошибку). Важная черта 
состоит в том, что ErrorValue рассматривается 
как Void, а Void рассматривается как Null 
(а не наоборот).&]
[s2; &]
[s2; Чтобы сделать какой`-либо тип Value 
совместимым, стандартный способ `- 
произвести его от вспомогательного 
класса ValueType, который присваивает 
константу номера типа значения и 
в котором определены `"пустые`" методы 
для фич rich value. Также требуется зарегистриров
ать через Register (или SvoRegister) это Value, 
чтобы оно могло быть успешно десериализован
о из потока или декодировано из JSON 
или XML.&]
[s3;%- &]
[s0;i448;a25;kKO9;@(0.0.255)%- &]
[ {{10000F(128)G(128)@1 [s0; [* Список Публичных Методов]]}}&]
[s3;%- &]
[s5;:Value`:`:Register`(const char`*`):%- [@(0.0.255) static] [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 T]>_[@(0.0.255) void]_[* Register]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 nam
e]_`=_NULL)&]
[s2; Регистрирует тип [%-*@4 T] как тип Rich Value. 
[%-*@3 name] `- имя, которое будет использовано 
с JSON или XML.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:SvoRegister`(const char`*`):%- [@(0.0.255) static] [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 T]>_[@(0.0.255) void]_[* SvoRegister]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 n
ame]_`=_NULL)&]
[s2; Регистрирует тип [%-*@4 T] как тип SVO Rich 
Value. [%-*@3 name ]`- имя, которое будет использовано 
с JSON или XML.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:GetType`(`)const:%- [_^dword^ dword]_[* GetType]()_[@(0.0.255) const]&]
[s2; Возвращает номер типа (присваиваемый 
при деривации от ValueType).&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:IsError`(`)const:%- [@(0.0.255) bool]_[* IsError]()_[@(0.0.255) const]&]
[s2; Возвращает true, если Value содержит ErrorValue.&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:IsVoid`(`)const:%- [@(0.0.255) bool]_[* IsVoid]()_[@(0.0.255) const]&]
[s2; Возвращает true, если Value является void 
(дефолтно сконструированное Value `- 
это void). IsError implies IsVoid.&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:IsNull`(`)const:%- [@(0.0.255) bool]_[* IsNull]()_[@(0.0.255) const]&]
[s2; Возвращает true, если Value равно Null. IsVoid 
implies IsNull.&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:Is`(`)const:%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[@(0.0.255) b
ool]_[* Is]()_[@(0.0.255) const]&]
[s2; Возвращает true, если Value точно содержит 
тип [%-*@4 T].&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:To`(`)const:%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[@(0.0.255) c
onst]_[*@4 T][@(0.0.255) `&]_[* To]()_[@(0.0.255) const]&]
[s2; Возвращает константную ссылку на 
данные, содержимые в Value, если Is<T> равно 
true, иначе выводит исключение ValueTypeError. 
Неопределённо, если Value содержит ValueArray 
или ValueMap (по техническим и производительным 
причинам).&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:Get`(`)const:%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[@(0.0.255) c
onst]_[*@4 T][@(0.0.255) `&]_[* Get]()_[@(0.0.255) const]&]
[s2; Возвращает константную ссылку на 
данные, содержимые в Value. В отличие 
от To, работает также, если Value содержит 
Null любого типа,`- в такое случае возвращается
 ссылка на Null типа T. Если Value не содержит 
T, выводится ValueTypeError. Неопределённо, 
если Value содержит ValueArray или ValueMap (по 
техническим и производительным причинам).&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:operator String`(`)const:%- [* operator_String]()_[@(0.0.255) const]&]
[s5;:Value`:`:operator WString`(`)const:%- [* operator_WString]()_[@(0.0.255) const]&]
[s5;:Value`:`:operator Date`(`)const:%- [* operator_Date]()_[@(0.0.255) const]&]
[s5;:Value`:`:operator Time`(`)const:%- [* operator_Time]()_[@(0.0.255) const]&]
[s5;:Value`:`:operator double`(`)const:%- [* operator_double]()_[@(0.0.255) const]&]
[s5;:Value`:`:operator int`(`)const:%- [* operator_int]()_[@(0.0.255) const]&]
[s5;:Value`:`:operator int64`(`)const:%- [* operator_int64]()_[@(0.0.255) const]&]
[s5;:Value`:`:operator bool`(`)const:%- [* operator_bool]()_[@(0.0.255) const]&]
[s5;:Upp`:`:Value`:`:ToStd`(`)const:%- [_^std`:`:string^ std`::string]_[* ToStd]()_[@(0.0.255) c
onst]&]
[s5;:Upp`:`:Value`:`:ToWStd`(`)const:%- [_^std`:`:wstring^ std`::wstring]_[* ToWStd]()_[@(0.0.255) c
onst]&]
[s5;:Value`:`:Value`(const String`&`):%- [* Value]([@(0.0.255) const]_[_^String^ String][@(0.0.255) `&
]_[*@3 s])&]
[s5;:Value`:`:Value`(const WString`&`):%- [* Value]([@(0.0.255) const]_[_^WString^ WString][@(0.0.255) `&
]_[*@3 s])&]
[s5;:Value`:`:Value`(const char`*`):%- [* Value]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 s
])&]
[s5;:Value`:`:Value`(int`):%- [* Value]([@(0.0.255) int]_[*@3 i])&]
[s5;:Value`:`:Value`(int64`):%- [* Value]([_^int64^ int64]_[*@3 i])&]
[s5;:Value`:`:Value`(double`):%- [* Value]([@(0.0.255) double]_[*@3 d])&]
[s5;:Value`:`:Value`(bool`):%- [* Value]([@(0.0.255) bool]_[*@3 b])&]
[s5;:Value`:`:Value`(Date`):%- [* Value]([_^Date^ Date]_[*@3 d])&]
[s5;:Value`:`:Value`(Time`):%- [* Value]([_^Time^ Time]_[*@3 t])&]
[s5;:Upp`:`:Value`:`:Value`(const std`:`:string`&`):%- [* Value]([@(0.0.255) const]_[_^std`:`:string^ s
td`::string][@(0.0.255) `&]_[*@3 s])&]
[s5;:Upp`:`:Value`:`:Value`(const std`:`:wstring`&`):%- [* Value]([@(0.0.255) const]_[_^std`:`:wstring^ s
td`::wstring][@(0.0.255) `&]_[*@3 s])&]
[s2; Поддержка прямых преобразований 
T`->Value и Value`->T стандартных типов Value. 
Если преобразование невозможно, выводится 
ValueTypeError.&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:Value`(const Nuller`&`):%- [* Value]([@(0.0.255) const]_[_^Nuller^ Nuller][@(0.0.255) `&
])&]
[s2; Поддержка присваивания из Null (напр., 
Value v `= Null). Создаёт Value, содержащее 
(int)Null.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`=`=`(const Value`&`)const:%- [@(0.0.255) bool]_[* operator`=`=]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])_[@(0.0.255) const]&]
[s5;:Value`:`:operator`!`=`(const Value`&`)const:%- [@(0.0.255) bool]_[* operator!`=]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])_[@(0.0.255) const]&]
[s2; Сравнение на равенство для поддерживаемых 
типов rich. Заметьте, что, определив 
функцию IsPolyEqual для этого типа, можно 
сравнивать Value, содержащее различные 
конкретные типы, напр., double с int (типы 
U`+`+ уже имеют определения функций 
IsPolyEqual).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:IsSame`(const Value`&`)const:%- [@(0.0.255) bool]_[* IsSame]([@(0.0.255) cons
t]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])_[@(0.0.255) const]&]
[s2; ValueMap упорядочивается и сравнивается, 
т.е. даже если значения ключей одинаковые, 
при разном порядке, ValueMap`'ы или Value`'и, 
содержащие их, считаются неравными 
(как с оператором `=`=). Этот метод предоставля
ет альтернативное сравнение Value`'в, 
которое предполагает, что содержимые 
ValueMap`'ы неупорядочены. Он рекурсивно 
обходит любые содержимые ValueMap`'ы, 
а также ValueArray`'и. Для иных типов Value, 
не являющихся ValueMap`'ом, используется 
обычный оператор сравнения `=`=.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:Compare`(const Value`&`)const:%- [@(0.0.255) int]_[* Compare]([@(0.0.255) con
st]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])_[@(0.0.255) const]&]
[s2; Сравнивает значение с другим значением 
[%-*@3 v]. Типы значений должны быть сравнительны
ми (напр., можно сравнивать тексты 
с текстами, числа с числами и т.д.). 
Если типы несравниваемые, возвращает 
0. Если значения равны, возвращает 
0; `-1, если Value меньше [%-*@3 v]; 1, если Value 
больше.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`<`=`(const Value`&`)const:%- [@(0.0.255) bool]_[* operator<`=]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&]_[*@3 x])_[@(0.0.255) const]&]
[s2;%- [%RU-RU То же, что и Compare(][*@3 x]) <`= 0.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`>`=`(const Value`&`)const:%- [@(0.0.255) bool]_[* operator>`=]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&]_[*@3 x])_[@(0.0.255) const]&]
[s2;%- [%RU-RU То же, что и Compare(][*@3 x]) >`= 0.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`<`(const Value`&`)const:%- [@(0.0.255) bool]_[* operator<]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&]_[*@3 x])_[@(0.0.255) const]&]
[s2;%- [%RU-RU То же, что и Compare(][*@3 x]) < 0.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`>`(const Value`&`)const:%- [@(0.0.255) bool]_[* operator>]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&]_[*@3 x])_[@(0.0.255) const]&]
[s2;%- [%RU-RU То же, что и Compare(][*@3 x]) > 0.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:ToString`(`)const:%- [_^String^ String]_[* ToString]()_[@(0.0.255) const]&]
[s2; Преобразование в текст для поддержки 
типов rich.&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:operator`~`(`)const:%- [_^String^ String]_[@(0.0.255) operator]_`~()_[@(0.0.255) c
onst]&]
[s2; То же, что и ToString().&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:GetTypeName`(`)const:%- [_^String^ String]_[* GetTypeName]()_[@(0.0.255) cons
t]&]
[s2; Возвращает текст с именем типа  для 
отладочных нужд.&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:Serialize`(Stream`&`):%- [@(0.0.255) void]_[* Serialize]([_^Stream^ Stream][@(0.0.255) `&
]_[*@3 s])&]
[s2; Сериализация для поддержки типов 
rich.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:Xmlize`(XmlIO`&`):%- [@(0.0.255) void]_[* Xmlize]([_^XmlIO^ XmlIO][@(0.0.255) `&
]_[*@3 xio])&]
[s2; Преобразование из/в XML для поддержки 
типов rich.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:Jsonize`(JsonIO`&`):%- [@(0.0.255) void]_[* Jsonize]([_^JsonIO^ JsonIO][@(0.0.255) `&
]_[*@3 jio])&]
[s2; Преобразование из/в JSON для поддержки 
типов rich.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:GetHashValue`(`)const:%- [@(0.0.255) unsigned]_[* GetHashValue]()_[@(0.0.255) c
onst]&]
[s2; Хэширование для поддержки типов 
rich.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:GetCount`(`)const:%- [@(0.0.255) int]_[* GetCount]()_[@(0.0.255) const]&]
[s2; Если Value содержит ValueArray или ValueMap, 
возвращает число элементов в нём, 
иначе `- 0.&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:operator`[`]`(int`)const:%- [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&
]_[* operator`[`]]([@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2; Если Value содержит ValueArray или ValueMap, 
возвращает элемент в позиции i.Если 
такого элемента не существует или 
нет ValueArray/ValueMap`'а, возникает ошибка 
времени выполнения (рантайма).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`[`]`(const String`&`)const:%- [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&
]_[* operator`[`]]([@(0.0.255) const]_[_^String^ String][@(0.0.255) `&]_[*@3 key])_[@(0.0.255) c
onst]&]
[s5;:Value`:`:operator`[`]`(const char`*`)const:%- [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&
]_[* operator`[`]]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 key])_[@(0.0.255) const]&]
[s5;:Value`:`:operator`[`]`(const Id`&`)const:%- [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&
]_[* operator`[`]]([@(0.0.255) const]_[_^Id^ Id][@(0.0.255) `&]_[*@3 key])_[@(0.0.255) const]&]
[s2; Если Value содержит ValueMap и в нём есть 
элемент с String [%-*@3 key], возвращает его 
значение. Если нет, возвращает void 
Value.&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:At`(int`):%- [_^Value^ Value][@(0.0.255) `&]_[* At]([@(0.0.255) int]_[*@3 i])&]
[s2; Если Value равно Null, устанавливает его 
в ValueArray. Если Value является ValueArray или 
было Null, возвращает ссылку на элемент 
по [%-*@3 i]. При его отсутствии добавляет 
столько Void Value`'ев в массив, сколько 
не хватает. Если Value является ValueMap, 
возвращает ссылку на зачение мапа 
по [%-*@3 i]. При его отсутствии поведение 
неопределённое (ASSERT в отладочном 
режиме не удаётся). [^topic`:`/`/Core`/srcdoc`/ValueReference`_ru`-ru^ В
озвращённая ссылка повреждается 
при любом дальнейшем использовании 
исходного Value]. Если Value не является 
ни ValueArray, ни Null, ни ValueMap, то поведение 
неопределённое (ASSERT в отладочном 
режиме не удаётся).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`(`)`(int`):%- [_^Value^ Value][@(0.0.255) `&]_[* operator()]([@(0.0.255) i
nt]_[*@3 i])&]
[s2; То же, что и At([%-*@3 i]).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:Add`(const Value`&`):%- [@(0.0.255) void]_[* Add]([@(0.0.255) const]_[_^Value^ V
alue][@(0.0.255) `&]_[*@3 src])&]
[s2; Если Value равно Null, то оно устанавливается 
в ValueArray. Если Value является ValueArray или 
было Null, то [%-*@3 src] приставляется в конце 
ValueArray`'я. Если Value не является ни ValueArray`'ем, 
ни Null, то поведение неопределённое 
(ASSERT в отладочном режиме не удаётся).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`<`<`(const T`&`):%- [@(0.0.255) template]_<[@(0.0.255) typename]_[*@4 T
]>_[_^Value^ Value][@(0.0.255) `&]_[* operator<<]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 s
rc])&]
[s2; То же, что и Add([%-*@3 src]).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:GetAdd`(const Value`&`):%- [_^Value^ Value][@(0.0.255) `&]_[* GetAdd]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&]_[*@3 key])&]
[s2; Если Value является Null, то оно устанавливается
 в ValueMap. Если Value является ValueArray`'ем, 
то оно устанавливается в стандартное 
преобразование ValueMap`'а в ValueArray (индексы 
становятся ключами). Если Value является 
ValueMap`'ом или было Null, возвращает ссылку 
на элемент по ключу [%-*@3 key], если элемента 
нет, он создаётся как Void Value. [^topic`:`/`/Core`/srcdoc`/ValueReference`_ru`-ru^ В
озвращённая ссылка повреждается 
при любом дальнейшем использовании 
исходного Value]. Если Value не является 
ни ValueArray, ни Null, ни ValueMap, то поведение 
неопределённое (ASSERT в отладочном 
режиме не удаётся).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`(`)`(const String`&`):%- [_^Value^ Value][@(0.0.255) `&]_[* operator
()]([@(0.0.255) const]_[_^String^ String][@(0.0.255) `&]_[*@3 key])&]
[s2; То же, что и GetAdd([%-*@3 key]).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`(`)`(const char`*`):%- [_^Value^ Value][@(0.0.255) `&]_[* operator()
]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 key])&]
[s2; Сохранить как GetAdd([%-*@3 key]).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`(`)`(const Id`&`):%- [_^Value^ Value][@(0.0.255) `&]_[* operator()](
[@(0.0.255) const]_[_^Id^ Id][@(0.0.255) `&]_[*@3 key])&]
[s2; Сохранить как GetAdd([%-*@3 key]).&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:operator`=`(const Value`&`):%- [_^Value^ Value][@(0.0.255) `&]_[* operator`=](
[@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2; Присваивание.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:Value`(const Value`&`):%- [* Value]([@(0.0.255) const]_[* Value][@(0.0.255) `&]_
[*@3 v])&]
[s2; Копи`-конструктор.&]
[s3; &]
[s4;%- &]
[s5;:Value`:`:Value`(`):%- [* Value]()&]
[s2; Дефолтный конструктор, создаёт void 
Value.&]
[s3;%- &]
[s4;%- &]
[s5;:Value`:`:`~Value`(`):%- [@(0.0.255) `~][* Value]()&]
[s2; Деструктор.&]
[s3;%- &]
[s0;%- &]
[ {{10000@(113.42.0) [s0; [*@7;4 Класс ValueType]]}}&]
[s0;%- &]
[s1;:noref:%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T], dword_[*@4 type], 
[@(0.0.255) class]_[*@3 B]_`=_EmptyClass>&]
[s1;:ValueType`:`:class:%- [@(0.0.255) class]_[* ValueType]_:_[@(0.0.255) public]_[*@3 B]&]
[s2; ValueType `- это вспомогательный класс, 
предназначенный для создания в коде`-клиенте
 конкретных кастомных типов, совместимых 
с Value rich. Такие типы должны быть производными
 от этого класса, который служит для&]
[s2; &]
[s2;i150;O0; присваивания номера типа Value 
конкретному классу (параметр [%-*@4 type])&]
[s2;i150;O0; предопределяет некоторые методы, 
спечицифные для rich, как `'empty`' для этого 
класса. Производный класс, таким образом, 
реализует только необходимые методы 
(напр., требуемый кодом`-клиентом).&]
[s2;i150;O0; добавления оператора присваивания 
для реализации совместимости с Ref 
(генерная ссылка)&]
[s2; &]
[s2; Список методов `'empty`' ValueType`'а служит 
также как список методов, которые 
конкретный тип, совместимый с Value, 
может определять для получения поддержки 
некоторых операций с Value.&]
[s3;%- &]
[ {{10000F(128)G(128)@1 [s0; [* Список Публичных Методов]]}}&]
[s3;%- &]
[s5;:ValueType`:`:IsNullInstance`(`)const:%- [@(0.0.255) bool]_[* IsNullInstance]()_[@(0.0.255) c
onst]&]
[s2; True, если конкретный тип содержит 
значение Null. ValueType возвращает false.&]
[s3;%- &]
[s4;%- &]
[s5;:ValueType`:`:Serialize`(Stream`&`):%- [@(0.0.255) void]_[* Serialize]([_^Stream^ Strea
m][@(0.0.255) `&]_[*@3 s])&]
[s2; Поддержка сериализации. ValueType вызывает 
ошибку времени выполнения.&]
[s3; &]
[s4;%- &]
[s5;:ValueType`:`:Xmlize`(XmlIO`&`):%- [@(0.0.255) void]_[* Xmlize]([_^XmlIO^ XmlIO][@(0.0.255) `&
]_[*@3 xio])&]
[s2; Поддержка XML. ValueType вызывает ошибку 
времени выполнения.&]
[s3; &]
[s4;%- &]
[s5;:ValueType`:`:Jsonize`(JsonIO`&`):%- [@(0.0.255) void]_[* Jsonize]([_^JsonIO^ JsonIO][@(0.0.255) `&
]_[*@3 jio])&]
[s2; Поддержка JSON. ValueType вызывает ошибку 
времени выполнения.&]
[s3; &]
[s4;%- &]
[s5;:ValueType`:`:GetHashValue`(`)const:%- [@(0.0.255) unsigned]_[* GetHashValue]()_[@(0.0.255) c
onst]&]
[s2; Хэш`-значение содержимых данных. 
ValueType возвращает 0.&]
[s3;%- &]
[s4;%- &]
[s5;:ValueType`:`:operator`=`=`(const T`&`)const:%- [@(0.0.255) bool]_[* operator`=`=]([@(0.0.255) c
onst]_[*@4 T][@(0.0.255) `&])_[@(0.0.255) const]&]
[s2; Равенство данных. ValueType вызывает 
ошибку времени выполнения.&]
[s3;%- &]
[s4;%- &]
[s5;:ValueType`:`:ToString`(`)const:%- [_^String^ String]_[* ToString]()_[@(0.0.255) const]&]
[s2; Преобразование в текст. ValueType возвращает 
пустую String.&]
[s3;%- &]
[s4;%- &]
[s5;:ValueType`:`:Compare`(const T`&`)const:%- [@(0.0.255) int]_[* Compare]([@(0.0.255) con
st]_[*@4 T][@(0.0.255) `&])_[@(0.0.255) const]&]
[s2; Сравнение с другом значением такого 
же типа. Возвращает `-1, 0, 1.&]
[s3;%- &]
[s4;%- &]
[s5;:ValueType`:`:PolyCompare`(const Value`&`)const:%- [@(0.0.255) int]_[* PolyCompare]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&])_[@(0.0.255) const]&]
[s2; Полиморфное сравнение с другим типом.&]
[s3;%- &]
[s4;%- &]
[s5;:ValueType`:`:operator Ref`(`):%- [* operator_Ref]()&]
[s2; Возвращает Ref (генерную ссылку) на 
экземпляр T.&]
[s0;%- &]
[ {{10000@(113.42.0) [s0; [*@7;4 Функции поддержки Value]]}}&]
[s0;%- &]
[ {{10000F(128)G(128)@1 [s0; [* Создание Value]]}}&]
[s3;%- &]
[s5;:FitsSvoValue`(`):%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[@(0.0.255) bool]_
[* FitsSvoValue]()&]
[s2; Возвращает true, если sizeof(T) умещается 
в оптимизацию SVO Value.&]
[s3;%- &]
[s4;%- &]
[s5;:SvoToValue`(const T`&`):%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[_^Value^ V
alue]_[* SvoToValue]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 x])&]
[s2; Создаёт SVO Value из [%-*@3 x]. У T должно быть 
определено всё, что требуется для 
совместимости с Value (произведение 
от типа ValueType об этом позаботится). 
В отличие от RawToValue, SvoToValue используется 
только операторе типа клиента Value() 
`- во избежании проблем с кастингом 
между Rich и Svo видами.&]
[s3; &]
[s4;%- &]
[s5;:RichToValue`(const T`&`):%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[_^Value^ V
alue]_[* RichToValue]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 data])&]
[s2; Создаёт Rich Value from [%-*@3 data]. У T должно 
быть определено всё, что требуется 
для совместимости с Value (произведение 
от типа ValueType об этом позаботится). 
В отличие от RawToValue, RichToValue используется 
только операторе типа клиента Value() 
`- во избежании проблем с кастингом 
между Rich и Svo видами.&]
[s3; &]
[s4;%- &]
[s5;:RawToValue`(const T`&`):%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[_^Value^ V
alue]_[* RawToValue]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 data])&]
[s2; Создаёт Raw Value из [%-*@3 data]. У T должен 
иметься конструктор глубокой копии.&]
[s3; &]
[s4;%- &]
[s5;:RawPickToValue`(pick`_ T`&`):%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[_^Value^ V
alue]_[* RawPickToValue]([@(0.128.128) pick`_]_[*@4 T][@(0.0.255) `&]_[*@3 data])&]
[s2; Создаёт Raw Value, пикуя [%-*@3 data] (в процессе 
данные разрушаются). У T должна быть 
семантика пик`-копии.&]
[s3; &]
[s4;%- &]
[s5;:RawDeepToValue`(const T`&`):%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[_^Value^ V
alue]_[* RawDeepToValue]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 data])&]
[s2; Создаёт Raw Value, используя конструктор 
[* необязательной глубокой копии] (T(const 
T`&, int)) [%-*@3 data].&]
[s3; &]
[s4;%- &]
[s5;:CreateRawValue`(Value`&`):%- [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[*@4 T][@(0.0.255) `&
]_[* CreateRawValue]([_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2; Создаёт Raw Value типа T в [%-*@3 v]. T создаётся 
дефолтным конструктором, возвращается 
ссылка на созданный экземпляр. Код`-клиент 
должен установить этот экземпляр 
перед передачей куда`-либо v.&]
[s3;%- &]
[s4;%- &]
[s5;:ErrorValue`(const char`*`):%- [_^Value^ Value]_[* ErrorValue]([@(0.0.255) const]_[@(0.0.255) c
har]_`*[*@3 s])&]
[s5;:ErrorValue`(const String`&`):%- [^Value^ Value]_[* ErrorValue]([@(0.0.255) const]_[^String^ S
tring][@(0.0.255) `&]_[*@3 s])&]
[s2; Возвращает Error Value с описанием [%-*@3 s].&]
[s3; &]
[s4;%- &]
[s5;:ErrorValue`(`):%- [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[* ErrorValue]()&]
[s2; Возвращает ErrorValue с пустым описанием.&]
[s3; &]
[s0;i448;a25;kKO9;@(0.0.255)%- &]
[ {{10000F(128)G(128)@1 [s0; [* Проверки типа Value]]}}&]
[s3;%- &]
[s5;:IsVoid`(const Value`&`):%- [@(0.0.255) bool]_[* IsVoid]([@(0.0.255) const]_[_^Value^ Val
ue][@(0.0.255) `&]_[*@3 v])&]
[s2; То же, что и [%-*@3 v].IsVoid().&]
[s3; &]
[s4;%- &]
[s5;:IsError`(const Value`&`):%- [@(0.0.255) bool]_[* IsError]([@(0.0.255) const]_[_^Value^ V
alue][@(0.0.255) `&]_[*@3 v])&]
[s2; То же, что и [%-*@3 v].IsError().&]
[s3; &]
[s4;%- &]
[s5;:IsString`(const Value`&`):%- [@(0.0.255) bool]_[* IsString]([@(0.0.255) const]_[_^Value^ V
alue][@(0.0.255) `&]_[*@3 v])&]
[s2; Возвращает true, если [%-*@3 v] содержит 
значение String, WString или Null.&]
[s3; &]
[s4;%- &]
[s5;:IsNumber`(const Value`&`):%- [@(0.0.255) bool]_[* IsNumber]([@(0.0.255) const]_[_^Value^ V
alue][@(0.0.255) `&]_[*@3 v])&]
[s2; Возвращает true, если [%-*@3 v] содержит 
значение bool, int, int64, double или Null.&]
[s3; &]
[s4;%- &]
[s5;:IsDateTime`(const Value`&`):%- [@(0.0.255) bool]_[* IsDateTime]([@(0.0.255) const]_[_^Value^ V
alue][@(0.0.255) `&]_[*@3 v])&]
[s2; Возвращает true, если [%-*@3 v] содержит 
значение Date, Time или Null.&]
[s3; &]
[s4;%- &]
[s5;:IsValueArray`(const Value`&`):%- [@(0.0.255) bool]_[* IsValueArray]([@(0.0.255) const]_
[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2; Возвращает true, если [%-*@3 v] содержит 
ValueArray.&]
[s3; &]
[s4;%- &]
[s5;:IsValueMap`(const Value`&`):%- [@(0.0.255) bool]_[* IsValueMap]([@(0.0.255) const]_[_^Value^ V
alue][@(0.0.255) `&]_[*@3 v])&]
[s2; Возвращает true, если [%-*@3 v] содержит 
ValueMap.&]
[s3; &]
[s4;%- &]
[s5;:GetErrorText`(const Value`&`):%- [_^String^ String]_[* GetErrorText]([@(0.0.255) const
]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2; Если [%-*@3 v] является Error Value, возвращает 
описание ошибки, иначе `- пустую String.&]
[s3; &]
[s4;%- &]
[s5;:IsNull`(const Value`&`):%- [@(0.0.255) bool]_[* IsNull]([@(0.0.255) const]_[_^Value^ Val
ue][@(0.0.255) `&]_[*@3 v])&]
[s2; То же, что и [%-*@3 v].IsNull().&]
[s3; &]
[s4;%- &]
[s5;:Nvl`(const Value`&`,const Value`&`):%- [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&
]_[* Nvl]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 a], [@(0.0.255) const]_[_^Value^ V
alue][@(0.0.255) `&]_[*@3 b])&]
[s2; Если [%-*@3 a].IsNull(), возвращает [%-*@3 b], иначе 
(не null) возвращает a.&]
[s3;%- ]]