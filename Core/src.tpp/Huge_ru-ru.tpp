topic "Класс Huge";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,2#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[ {{10000@(113.42.0) [s0; [*@7;4 Класс Huge]]}}&]
[s3;%- &]
[s1;:Upp`:`:Huge`:`:class:%- [@(0.0.255)3 class][3 _][*3 Huge]&]
[s2; Этот класс предназначен для работы 
с большими кусками сырых двоичных 
данных. Основная сфера применения 
относится к сериализационным загрузкам, 
при которых он используется для предгазрузк
и больших двоичных данных (напр., String 
или Image) , в смысле, для защиты против 
неполноценного ввода `- Huge сортирует 
данные отрезками по 1 МБ, поэтому имеется 
вероятность достижения конца потока 
без размещения в памяти неполноценных 
объёмов данных.&]
[s2; Для дальнейшего пояснения, проблема, 
которая здесь решается, выражается 
так:&]
[s2; &]
[s2; [C void Foo`::Serialize(Stream`& s)]&]
[s2; [C `{]&]
[s2; [C    int len;]&]
[s2; [C    s % len;]&]
[s2; [C    if(s.IsLoading()) `{]&]
[s2; [C        ptr `= new byte`[len`];]&]
[s2; [C        s.GetAll(ptr, len);]&]
[s2; [C    `}]&]
[s2; [C    .....]&]
[s2; [C `}]&]
[s2; &]
[s2; в случае если поток неполноценен 
(повреждён), есть вероятность, что 
произойдёт ошибка аллокации. Это 
можно предотвратить, изучив количество 
оставшихся в потоке данных, но для 
некоторых классав потоков (например, 
для сжатых) такая информация отсутствует. 
[* Huge] решает эту проблему, служа временным 
буфером для загружаемых данных:&]
[s2; &]
[s2; [C void Foo`::Serialize(Stream`& s)]&]
[s2; [C `{]&]
[s2; [C    int len;]&]
[s2; [C    s % len;]&]
[s2; [C    if(s.IsLoading()) `{]&]
[s2; [C -|       Huge h;]&]
[s2; [C        s.GetAll(h, len);]&]
[s2; [C        ptr `= new byte`[h.GetSize()`];]&]
[s2; [C        h.Get(ptr);]&]
[s2; [C    `}]&]
[s2; [C    .....]&]
[s2; [C `}]&]
[s2;C &]
[s2; Теперь, если остаточная длина потока 
меньше [C len], [* Huge] выполняет размещение 
кусками по 1 МБ, и конец потока будет 
достигнут без размещения избыточной 
памяти. GetAll далее должен завершиться 
неуспешно, с ошибкой LoadingError. За этим 
шагом кроется тот факт, что данные 
копируются ещё раз и что для загрузки 
отдельного элемента требуется в два 
раза больше памяти. Одако зачастую 
этим можно пренебречь.&]
[s0;i448;a25;kKO9;:noref:@(0.0.255)%- &]
[ {{10000F(128)G(128)@1 [s0; [* Список Публичных Методов]]}}&]
[s3;%- &]
[s5;:Upp`:`:Huge`:`:CHUNK:%- [@(0.0.255) enum]_[* CHUNK]_`=_[@3 1024]_`*_[@3 1024]_&]
[s2; Это размер куска размещения для [* Huge], 
на данный момент в районе 1МБ.&]
[s3;%- &]
[s4;%- &]
[s5;:Upp`:`:Huge`:`:AddChunk`(`):%- [_^Upp`:`:byte^ byte]_`*[* AddChunk]()&]
[s2; Добавляет кусок (`"чанк`") в возвращает 
указатель не него. Код`-`"клиент`" должен 
`"уважать`" размер куска [* CHUNK].&]
[s3;%- &]
[s4;%- &]
[s5;:Upp`:`:Huge`:`:Finish`(int`):%- [@(0.0.255) void]_[* Finish]([@(0.0.255) int]_[*@3 last`_
chunk`_size])&]
[s2; После добавления последнего куска, 
[* Huge] `'закрывается`' вызовом этого метода 
с размером своего последнего куска 
[%-*@3 last`_chunk`_size]. Обычно, [* Huge] получает 
данные из какого`-либо источника(типа 
Stream), который возвращает полноразмерные 
куски, вплоть до самого последнего 
из них.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:Huge`:`:GetSize`(`)const:%- [_^size`_t^ size`_t]_[* GetSize]()_[@(0.0.255) cons
t]&]
[s2; Возвращает число сохранённых байтов.&]
[s3;%- &]
[s4;%- &]
[s5;:Upp`:`:Huge`:`:Get`(void`*`,size`_t`,size`_t`)const:%- [@(0.0.255) void]_[* Get]([@(0.0.255) v
oid]_`*[*@3 t`_], [_^size`_t^ size`_t]_[*@3 pos], [_^size`_t^ size`_t]_[*@3 sz])_[@(0.0.255) c
onst]&]
[s2; Считывает данные в указатель цели 
(приёмник).&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:Huge`:`:Get`(void`*`):%- [@(0.0.255) void]_[* Get]([@(0.0.255) void]_`*[*@3 t])&]
[s2; То же, что и Get(t, 0, GetSize()).&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:Huge`:`:Get`(`)const:%- [_^Upp`:`:String^ String]_[* Get]()_[@(0.0.255) const]&]
[s2; Возвращает данные в виде String. Должно 
быть менее 2 ГБ данных, иначе операция 
завершается `"паникой`" ( Panic).&]
[s3;%- ]]