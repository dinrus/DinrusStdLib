topic "Шаблонные Алгоритмы";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,0#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_} 
[ {{10000@(113.42.0) [s0;%RU-RU [*@7;4 Шаблонные Алгоритмы]]}}&]
[s3;%RU-RU &]
[s5;:Swap`(T`&`,T`&`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T][@(0.0.255) >]_&]
[s5;:Swap`(T`&`,T`&`): [@(0.0.255) void]_[* Swap]([*@4 T][@(0.0.255) `&]_[*@3 a], 
[*@4 T][@(0.0.255) `&]_[*@3 b])&]
[s2;%RU-RU Меняет местами значения. Специфичные 
типы могут специализировать [* Swap].&]
[s3; &]
[s4; &]
[s5;:IterSwap`(I`,I`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 I][@(0.0.255) >]_&]
[s5;:IterSwap`(I`,I`): [@(0.0.255) void]_[* IterSwap]([*@4 I]_[*@3 a], [*@4 I]_[*@3 b])&]
[s2;%RU-RU Меняет местами значения, на которые 
указывают итераторы. Специфичные 
типы могут специализировать [* IterSwap].&]
[s3; &]
[s4; &]
[s5;:sgn`(T`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_&]
[s5;:sgn`(T`): [@(0.0.255) int]_[* sgn]([*@4 T]_[*@3 a])&]
[s2;%RU-RU Возвращает 1, если  [%-*@3 a] больше 
нуля, `-1, если [%-*@3 a] меньше нуля и ноль, 
если [%-*@3 a] равно нулю.&]
[s3;%RU-RU &]
[s4; &]
[s5;:tabs`(T`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_&]
[s5;:tabs`(T`): [*@4 T]_[* tabs]([*@4 T]_[*@3 a])&]
[s2;%RU-RU Возвращает абсолютное значение 
[%-*@3 a].&]
[s3;%RU-RU &]
[s4; &]
[s5;:cmp`(const T`&`,const T`&`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_&]
[s5;:cmp`(const T`&`,const T`&`): [@(0.0.255) int]_[* cmp]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&
]_[*@3 a], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 b])&]
[s2; [%RU-RU Возвращает 1, если ][*@3 a][%RU-RU  больше 
][*@3 b;][%RU-RU  `-1, если ][*@3 a][%RU-RU  меньше ][*@3 b; 
][%RU-RU и ноль, если ][*@3 a][%RU-RU  равно ][*@3 b.]&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:Reverse`(Range`&`&`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 Range]>_&]
[s5;:Upp`:`:Reverse`(Range`&`&`): [@(0.0.255) void]_[* Reverse]([*@4 Range][@(0.0.255) `&`&]_
[*@3 r])&]
[s2;%RU-RU Реверсирует порядок значений 
в диапазоне.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:Sum`(const Range`&`,const Upp`:`:ValueTypeOf`<Range`>`&`): [@(0.0.255) temp
late]_<[@(0.0.255) class]_[*@4 Range]>_&]
[s5;:Upp`:`:Sum`(const Range`&`,const Upp`:`:ValueTypeOf`<Range`>`&`): [_^Upp`:`:ValueTypeOf^ V
alueTypeOf]<[*@4 Range]>_[* Sum]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r], 
[@(0.0.255) const]_[_^Upp`:`:ValueTypeOf^ ValueTypeOf]<[*@4 Range]>`&_[*@3 zero])&]
[s2; [%RU-RU Возвращает сумму всех элементов 
в диапазоне ][*@3 r][%RU-RU , с ][*@3 zero][%RU-RU , представляющи
м начальное нулевое значение. У ][*@4 T]_должен 
быть определён оператор `+`=.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Sum`(const T`&`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 Range]>_&]
[s5;:Sum`(const T`&`): [@(0.0.255) typename]_[_^Upp`:`:ValueTypeOf^ ValueTypeOf]<[*@4 Range
]>_[* Sum]([@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 c])&]
[s2;%RU-RU То же, что и Sum(c, 0).&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:Count`(const Range`&`,const V`&`): [@(0.0.255) template]_<[@(0.0.255) class]_
[*@4 Range], [@(0.0.255) class]_[*@4 V]>_&]
[s5;:Upp`:`:Count`(const Range`&`,const V`&`): [@(0.0.255) int]_[* Count]([@(0.0.255) const
]_[*@4 Range][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[*@4 V][@(0.0.255) `&]_[*@3 val])&]
[s2;%RU-RU Считает число элементов в Range 
[%-*@3 r], которое равно [%-*@3 val] .&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:CountIf`(const Range`&`,const Predicate`&`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range], [@(0.0.255) class]_[*@4 Predicate]>_&]
[s5;:Upp`:`:CountIf`(const Range`&`,const Predicate`&`): [@(0.0.255) int]_[* CountIf]([@(0.0.255) c
onst]_[*@4 Range][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[*@4 Predicate][@(0.0.255) `&]_[*@3 p
])&]
[s2;%RU-RU Считает число элементов в Range 
[%-*@3 r], удовлетворяющее условие [%-*@3 p].&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:FindBest`(const Range`&`,const Pred`&`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range], [@(0.0.255) class]_[*@4 Pred]>_&]
[s5;:Upp`:`:FindBest`(const Range`&`,const Pred`&`): [@(0.0.255) int]_[* FindBest]([@(0.0.255) c
onst]_[*@4 Range][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[*@4 Pred][@(0.0.255) `&]_[*@3 pre
d])&]
[s2;%RU-RU Находит наиболее удобный элемент 
в диапазоне [%-*@3 r], как указано [%-*@3 pred]. 
Напр., если [%-*@3 pred] является std`::less, находит 
минимум. Если [%-*@3 r] пустой, возвращает 
`-1.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:FindMin`(const Range`&`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 Range]>
_&]
[s5;:Upp`:`:FindMin`(const Range`&`): [@(0.0.255) int]_[* FindMin]([@(0.0.255) const]_[*@4 Ra
nge][@(0.0.255) `&]_[*@3 r])&]
[s2;%RU-RU Возвращает индекс минимального 
элемента из [%-*@3 r], используя std`::less для 
сравнения элементов. Если [%-*@3 r] пустой, 
возвращает `-1.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:Min`(const Range`&`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 Range]>_&]
[s5;:Upp`:`:Min`(const Range`&`): [@(0.0.255) const]_[_^Upp`:`:ValueTypeOf^ ValueTypeOf]<
[*@4 Range]>`&_[* Min]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r])&]
[s2;%RU-RU Возвращает  [/ значение] минимального 
элемента из [%-*@3 r], используя std`::less для 
сравнения элементов. Если [%-*@3 r] пустой, 
поведение неопределённое (ASSERT неудачен 
при отладке).&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:Min`(const Range`&`,const Upp`:`:ValueTypeOf`<Range`>`&`): [@(0.0.255) temp
late]_<[@(0.0.255) class]_[*@4 Range]>_&]
[s5;:Upp`:`:Min`(const Range`&`,const Upp`:`:ValueTypeOf`<Range`>`&`): [@(0.0.255) cons
t]_[_^Upp`:`:ValueTypeOf^ ValueTypeOf]<[*@4 Range]>`&_[* Min]([@(0.0.255) const]_[*@4 Range
][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[_^Upp`:`:ValueTypeOf^ ValueTypeOf]<[*@4 Range
]>`&_[*@3 def])&]
[s2;%RU-RU Возвращает [/ значение] минимального 
элемента из [%-*@3 r], используя std`::less для 
сравнения элементов. Если [%-*@3 r] пустой, 
возвращает [%-*@3 def].&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:FindMax`(const Range`&`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 Range]>
_&]
[s5;:Upp`:`:FindMax`(const Range`&`): [@(0.0.255) int]_[* FindMax]([@(0.0.255) const]_[*@4 Ra
nge][@(0.0.255) `&]_[*@3 r])&]
[s2;%RU-RU Возвращает индекс максимального 
элемента из [%-*@3 r], используя std`::greater 
для сравнения элементов. Если [%-*@3 r] 
пустой, возвращает `-1.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:Max`(const Range`&`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 Range]>_&]
[s5;:Upp`:`:Max`(const Range`&`): [@(0.0.255) const]_[_^Upp`:`:ValueTypeOf^ ValueTypeOf]<
[*@4 Range]>`&_[* Max]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r])&]
[s2;%RU-RU Возвращает [/ значение] максимального 
элемента в [%-*@3 r], используя std`::less для 
сравнения элементов. Если [%-*@3 r] пустой, 
поведение неопределённое (ASSERT неудачен 
при отладке).&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:Max`(const Range`&`,const Upp`:`:ValueTypeOf`<Range`>`&`): [@(0.0.255) temp
late]_<[@(0.0.255) class]_[*@4 Range]>_&]
[s5;:Upp`:`:Max`(const Range`&`,const Upp`:`:ValueTypeOf`<Range`>`&`): [@(0.0.255) cons
t]_[_^Upp`:`:ValueTypeOf^ ValueTypeOf]<[*@4 Range]>`&_[* Max]([@(0.0.255) const]_[*@4 Range
][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[_^Upp`:`:ValueTypeOf^ ValueTypeOf]<[*@4 Range
]>`&_[*@3 def])&]
[s2;%RU-RU Возвращает [/ значение] максимального 
элемента в [%-*@3 r], используя std`::less для 
сравнения элементов. Если [%-*@3 r] пустой, 
возвращает [%-*@3 def].&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:IsEqualRange`(const Range1`&`,const Range2`&`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range1], [@(0.0.255) class]_[*@4 Range2]>_&]
[s5;:Upp`:`:IsEqualRange`(const Range1`&`,const Range2`&`): [@(0.0.255) bool]_[* IsEqualR
ange]([@(0.0.255) const]_[*@4 Range1][@(0.0.255) `&]_[*@3 a], [@(0.0.255) const]_[*@4 Range2][@(0.0.255) `&
]_[*@3 b])&]
[s2;%RU-RU Возвращает true, если [%-*@3 a] и [%-*@3 b] 
равны. Оператор`=`= использутся для 
сравнения элементов. Диапазоны считаются 
равными, если в них одинаковое число 
элементов и для каждого элемента 
по индексу [/ i: ][%-*@3 a]`[i`] `=`= [%-*@3 b]`[i`].&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:CompareRanges`(const Range1`&`,const Range2`&`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range1], [@(0.0.255) class]_[*@4 Range2]>_&]
[s5;:Upp`:`:CompareRanges`(const Range1`&`,const Range2`&`): [@(0.0.255) int]_[* CompareR
anges]([@(0.0.255) const]_[*@4 Range1][@(0.0.255) `&]_[*@3 a], [@(0.0.255) const]_[*@4 Range2
][@(0.0.255) `&]_[*@3 b])&]
[s2;%RU-RU Сравнивает лексикографически 
диапазоны [%-*@3 a] [%-*@3 b], используя SgnCompare 
для сравнения элементов. SgnCompare предположите
льно возвращает значение < 0, если 
первый элемент меньше второго, 0, если 
они равны, >0 в ином случае. Возвращает 
 значение <0, 0, >0, если [%-*@3 a] < [%-*@3 b],[%-*@3  
a] `=`= [%-*@3 b],[%-*@3  a] > [%-*@3 b].&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:FindMatch`(const Range`&`,const C`&`,int`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range], [@(0.0.255) class]_[*@4 C]>_&]
[s5;:Upp`:`:FindMatch`(const Range`&`,const C`&`,int`): [@(0.0.255) int]_[* FindMatch]([@(0.0.255) c
onst]_[*@4 Range][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[*@4 C][@(0.0.255) `&]_[*@3 match],
 [@(0.0.255) int]_[*@3 from]_`=_[@3 0])&]
[s2;%RU-RU Возвращает индекс первого элемента, 
для которого предикат [%-*@3 match] верен. 
Если не найден, возвращает `-1. Поиск 
начинается с индекса [%-*@3 from].&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:FindIndex`(const Range`&`,const V`&`,int`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range], [@(0.0.255) class]_[*@4 V]>_&]
[s5;:Upp`:`:FindIndex`(const Range`&`,const V`&`,int`): [@(0.0.255) int]_[* FindIndex]([@(0.0.255) c
onst]_[*@4 Range][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[*@4 V][@(0.0.255) `&]_[*@3 value],
 [@(0.0.255) int]_[*@3 from]_`=_[@3 0])&]
[s2;%RU-RU Возвращает индекс первого элемента, 
который равен [%-*@3 value]. Если не найден, 
возвращается `-1. Поиск начинается 
с индекса [%-*@3 from].&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:FindAll`(const Range`&`,Predicate`,int`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range], [@(0.0.255) class]_[*@4 Predicate]>_&]
[s5;:Upp`:`:FindAll`(const Range`&`,Predicate`,int`): [_^Upp`:`:Vector^ Vector]<[@(0.0.255) i
nt]>_[* FindAll]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r], 
[*@4 Predicate]_[*@3 match], [@(0.0.255) int]_[*@3 from]_`=_[@3 0])&]
[s2;%RU-RU Возвращает Vector индексов [/ ВСЕХ] 
элементов, для которых [%-*@3 match] верен. 
Возвращённый Vector сортируется в восходящем 
порядке. Поиск начинается с индекса 
[%-*@3 from].Параметр [%-*@3 match] является элементом.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:FindAlli`(const Range`&`,Predicate`,int`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range], [@(0.0.255) class]_[*@4 Predicate]>_[_^Upp`:`:Vector^ Vector]<[@(0.0.255) i
nt]>_[* FindAlli]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r], 
[*@4 Predicate]_[*@3 match], [@(0.0.255) int]_[*@3 from]_`=_[@3 0])&]
[s2;%RU-RU Возвращает Vector индексов [/ ВСЕХ] 
элементов, для которых [%-*@3 match] верен. 
Возвращённый Vector сортируется в восходящем 
порядке.. Поиск начинается с индекса 
[%-*@3 from]. В отличие от FindAll, параметром 
к [%-*@3 match] является индекс элемента.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:FindLowerBound`(const Range`&`,const T`&`,const Less`&`): [@(0.0.255) templ
ate]_<[@(0.0.255) class]_[*@4 Range], [@(0.0.255) class]_[*@4 T], [@(0.0.255) class]_[*@4 Les
s]>_&]
[s5;:Upp`:`:FindLowerBound`(const Range`&`,const T`&`,const Less`&`): [@(0.0.255) int]_
[* FindLowerBound]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r], 
[@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 val], [@(0.0.255) const]_[*@4 Less][@(0.0.255) `&
]_[*@3 less])&]
[s5;:Upp`:`:FindLowerBound`(const Range`&`,const T`&`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range], [@(0.0.255) class]_[*@4 T]>_&]
[s5;:Upp`:`:FindLowerBound`(const Range`&`,const T`&`): [@(0.0.255) int]_[* FindLowerBoun
d]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&
]_[*@3 val])&]
[s2;%RU-RU Находит первый индекс в отсортированном
 диапазоне [%-*@3 r], который должен сортироватьс
я предикатом [%-*@3 less ](или std`::less во второй 
перегрузке), где [%-*@3 val] можно вставить, 
не нарушая порядок.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:FindUpperBound`(const Range`&`,const T`&`,const L`&`): [@(0.0.255) template
]_<[@(0.0.255) class]_[*@4 Range], [@(0.0.255) class]_[*@4 T], [@(0.0.255) class]_[*@4 L]>_&]
[s5;:Upp`:`:FindUpperBound`(const Range`&`,const T`&`,const L`&`): [@(0.0.255) int]_[* Fi
ndUpperBound]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r], 
[@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 val], [@(0.0.255) const]_[*@4 L][@(0.0.255) `&]_
[*@3 less])&]
[s5;:Upp`:`:FindUpperBound`(const Range`&`,const T`&`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range], [@(0.0.255) class]_[*@4 T]>_&]
[s5;:Upp`:`:FindUpperBound`(const Range`&`,const T`&`): [@(0.0.255) int]_[* FindUpperBoun
d]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&
]_[*@3 val])&]
[s2;%RU-RU Находит последний индекс в отсортирован
ном диапазоне [%-*@3 r], который должен 
сортироваться с предикатом [%-*@3 less] 
(или std`::less во второй перегрузке), где 
[%-*@3 val] можно вставить, не нарушая порядок.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:FindBinary`(const Range`&`,const T`&`,const L`&`): [@(0.0.255) template]_<[@(0.0.255) c
lass]_[*@4 Range], [@(0.0.255) class]_[*@4 T], [@(0.0.255) class]_[*@4 L]>_&]
[s5;:Upp`:`:FindBinary`(const Range`&`,const T`&`,const L`&`): [@(0.0.255) int]_[* FindBi
nary]([@(0.0.255) const]_[*@4 Range][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&
]_[*@3 val], [@(0.0.255) const]_[*@4 L][@(0.0.255) `&]_[*@3 less])&]
[s5;:Upp`:`:FindBinary`(const Range`&`,const T`&`): [@(0.0.255) template]_<[@(0.0.255) cl
ass]_[*@4 Range], [@(0.0.255) class]_[*@4 T]>_&]
[s5;:Upp`:`:FindBinary`(const Range`&`,const T`&`): [@(0.0.255) int]_[* FindBinary]([@(0.0.255) c
onst]_[*@4 Range][@(0.0.255) `&]_[*@3 r], [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[*@3 val])&]
[s2;%RU-RU Находит индекс [%-*@3 val] в отсортированном 
диапазоне [%-*@3 r], который должен сортироваться
 с предикатом [%-*@3 less] (или std`::less во второй 
перегузке). Если [%-*@3 val] отсутствует 
в [%-*@3 r], возвращается `-1.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:LruAdd`(Container`&`,T`,int`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 C
ontainer], [@(0.0.255) class]_[*@4 T]>_&]
[s5;:Upp`:`:LruAdd`(Container`&`,T`,int`): [@(0.0.255) void]_[* LruAdd]([*@4 Container][@(0.0.255) `&
]_[*@3 lru], [*@4 T]_[*@3 value], [@(0.0.255) int]_[*@3 limit]_`=_[@3 10])&]
[s2;%RU-RU Этот специализированный алгоритм 
предназначен для управления списками 
Least`-Recently`-Used. [%-*@3 lru] должен быть типа 
массива U`+`+ (Vector, Array, InVector, InArray) и представлят
ь список. [%-*@3 value] `- значение, в итоге 
добавляемое в этот список, [%-*@3 limit] 
`- максимальное число элементов в 
списке. При вызове, если [%-*@3 value] присутствует 
в этом [%-*@3 lru], оно перемещается вперёд. 
Если отсутствует, вставляется во 
`"фрунт`" и размер списка снижается 
до [%-*@3 limit], возможно удаление элемента 
в конце списка.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:MakeIota`(V`,V`,V`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 C]_`=_Vecto
r<[@(0.0.255) int]>, [@(0.0.255) class]_[*@4 V]>_&]
[s5;:Upp`:`:MakeIota`(V`,V`,V`): [*@4 C]_[* MakeIota]([*@4 V]_[*@3 end], 
[*@4 V]_[*@3 start]_`=_[@3 0], [*@4 V]_[*@3 step]_`=_[@3 1])&]
[s2;%RU-RU Возвращает контейнер типа [%-*@4 C], 
наполненный последовательностью 
чисел, начинающихся со [%-*@3 start] и меньших, 
чем [%-*@3 end, ][%- увеличиваясь на] [%-*@3 step] 
инкрементов.&]
[s3;%RU-RU &]
[s0;%RU-RU ]]