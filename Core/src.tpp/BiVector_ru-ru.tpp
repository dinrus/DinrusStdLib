topic "Класс BiVector";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,0#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[ {{10000@(113.42.0) [s0; [*@7;4 Класс BiVector]]}}&]
[s3; &]
[s1;:noref:%- [@(0.0.255)3 template][3 _<][@(0.0.255)3 class][3 _][*@4;3 T][@(0.0.255)3 >]&]
[s1;:BiVector`:`:class:%- [@(0.0.255) class]_[* BiVector]_:_[@(0.0.255) private]_[*@3 Moveable
AndDeepCopyOption][@(0.0.255) <]_[* BiVector][@(0.0.255) <][*@4 T][@(0.0.255) >]_>_&]
[s8; [*@4 T]-|Тип элементов, сохраняемых в BiVector`'е. 
T обязательно должен быть [/^topic`:`/`/Core`/srcdoc`/Moveable`_ru`-ru^ m
oveable][/  ]и иметь либо [/ конструктор глубокой 
копии (КГК)], [/ pick`-конструктор] или [/ дефолтный 
конструктор].&]
[s0; &]
[s0;# Vector flavor двунаправленного контейнера. 
Позволяет добавлять элементы с обеих 
сторон последовательности за константное 
амортизированное время.&]
[s0;# &]
[s0; Подобно любому другому NTL`-контейнеру, 
BiVector является [*/^topic`:`/`/Core`/srcdoc`/Moveable`_ru`-ru^ moveable][/  
]типом с семантикой трансфера, именуемой 
`" [*/^topic`:`/`/Core`/srcdoc`/pick`_`_ru`-ru^ pick and optional 
deep copy]. Вызов методов `"пикнутого`" 
BiVector`'а является логической ошибкой, 
за исключением:&]
[s0;%- [C+75 void ][*C+75 operator`=][C+75 (pick`_ Vector`& ][*C@3+75 v][C+75 )]&]
[s0;%- [C+75 void ][*C+75 operator<<`=][C+75 (const Vector`& ][*C@3+75 v][C+75 ) 
][/C+75 (определено с применением DeepCopyOptionTemplate)]&]
[s0;%- [C+75 void ][*C+75 Clear][C+75 ()]&]
[s0;%- [C+75 bool ][*C+75 IsPicked][C+75 () const]&]
[s0;C+75%- &]
[s0; Опциональная глубокая копия реализуется 
с помощью макроса [* DeepCopyOptionTemplate].&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0; [* Детали Конструктора]]}}&]
[s3; &]
[s5;:BiVector`:`:BiVector`(`):%- [* BiVector]()&]
[s2; Дефолтный конструктор. Создаёт пустой 
[* BiVector].&]
[s3;%- &]
[s4;%- &]
[s5;:Upp`:`:BiVector`:`:BiVector`(Upp`:`:BiVector`&`&`):%- [* BiVector]([* BiVector][@(0.0.255) `&
`&]_[*@3 src])&]
[s2; Pick`-конструктор. `"Трансферит`" исходный 
[* BiVector ][%-*@3 src ]за малое константное время, 
но разрушает его при пикинге.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:BiVector`:`:operator`=`(Upp`:`:BiVector`&`&`):%- [@(0.0.255) void]_[* operato
r`=]([_^Upp`:`:BiVector^ BiVector][@(0.0.255) `&`&]_[*@3 src])&]
[s2; Pick`-присваивание. `"Трансферит`" исходный 
[* BiVector ][%-*@3 src ]за малое константное время, 
но разрушает его при пикинге.&]
[s3; &]
[s4;%- &]
[s5;:BiVector`:`:BiVector`(const BiVector`&`,int`):%- [* BiVector]([@(0.0.255) const]_[* Bi
Vector][@(0.0.255) `&]_[*@3 src], [@(0.0.255) int])&]
[s2; Опциональный конструктор глубокой 
копии (ОКГК). Создаёт глубокую копию 
[%-*@3 src].&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:BiVector`:`:BiVector`(std`:`:initializer`_list`<T`>`):%- [* BiVector]([_^http`:`/`/en`.cppreference`.com`/w`/cpp`/utility`/initializer`_list^ s
td`::initializer`_list]<[*@4 T]>_[*@3 init])&]
[s2; C`+`+11 инициализация.&]
[s3; &]
[s4;%- &]
[s5;:BiVector`:`:`~BiVector`(`):%- [@(0.0.255) `~][* BiVector]()&]
[s2; Дефолтный деструктор. Вызывает деструктор 
каждого элемента в этом BiVector`'е.&]
[s3;%- &]
[s0;i448;a25;kKO9;@(0.0.255)%- &]
[ {{10000F(128)G(128)@1 [s0; [* Список Публичных Методов]]}}&]
[s3;%- &]
[s5;:BiVector`:`:AddHead`(`):%- [*@4 T][@(0.0.255) `&]_[* AddHead]()&]
[s2; Добавляет новый, дефолтно сконструированны
й элемент в голову этого [* BiVector`'а]. 
Новый элемент появляется в позиции 
0. Возвращает  ссылку на вновь добавленный, 
дефолтно сконструированный, элемент.&]
[s6; Требует, чтобы у T был дефолтный конструктор
.&]
[s6; Повреждает обходчики и ссылку на 
этот BiVector.&]
[s3; &]
[s4;%- &]
[s5;:BiVector`:`:AddTail`(`):%- [*@4 T][@(0.0.255) `&]_[* AddTail]()&]
[s2; Добавляет новый, дефолтно сконструированны
й элемент в хвост этого [* BiVector`'а]. Новый 
элемент появляется в позиции [* GetCount]() 
`- 1. Возвращает  ссылку на вновь добавленный, 
дефолтно сконструированный, элемент.&]
[s6; Требует, чтобы у T был дефолтный конструктор
.&]
[s6; Повреждает обходчики и ссылку на 
этот BiVector.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:AddHead`(const T`&`):%- [@(0.0.255) void]_[* AddHead]([@(0.0.255) const]_[*@4 T
][@(0.0.255) `&]_[*@3 x])&]
[s2; Добавляет новый элемент с указанным 
значением [%-*@3 x ]в голову этого [* BiVector`'а]. 
Новый элемент занимает позицию 0.&]
[s6; Требует, чтобы у T был конструктор 
глубокой копии (КГК).&]
[s6; Повреждает обходчики и ссылку на 
этот BiVector.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:AddTail`(const T`&`):%- [@(0.0.255) void]_[* AddTail]([@(0.0.255) const]_[*@4 T
][@(0.0.255) `&]_[*@3 x])&]
[s2; Добавляет новый элемент с заданным 
значением [%-*@3 x ]в хвост этого [* BiVector`'а]. 
Новый элемент будет расположен в 
позиции [* GetCount]() `- 1.&]
[s6; Требует, чтобы у T был конструктор 
глубокой копии (КГК).&]
[s6; Повреждает обходчики и ссылку на 
этот BiVector.&]
[s6; &]
[s4;%- &]
[s5;:BiVector`:`:Head`(`):%- [*@4 T][@(0.0.255) `&]_[* Head]()&]
[s2; Возвращает ссылку на голову этого 
[* BiVector`'а. ]То же, что и operator`[`](0).&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:Tail`(`):%- [*@4 T][@(0.0.255) `&]_[* Tail]()&]
[s2; Возвращает ссылку на хвост этого 
[* BiVector`'а.] То же, что и operator`[`]([* GetCount]() 
`- 1).&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:Head`(`)const:%- [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[* Head]()_[@(0.0.255) c
onst]&]
[s2; Возвращает [* const] ссылку на голову 
этого [* BiVector`'а]. То же, что и operator`[`](0).&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:Tail`(`)const:%- [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[* Tail]()_[@(0.0.255) c
onst]&]
[s2; Возвращает [* const ]ссылку на хвост этого 
[* BiVector`'а]. То же, что и operator`[`]([* GetCount]() 
`- 1).&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:DropHead`(`):%- [@(0.0.255) void]_[* DropHead]()&]
[s2; `"Роняет`" элемент в голове этого [* BiVector`'а].&]
[s6; Повреждает обходчики и ссылку на 
этот BiVector..&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:DropTail`(`):%- [@(0.0.255) void]_[* DropTail]()&]
[s2; Удаляет элемент в хвосте этого [* BiVector`'а].&]
[s6; Повреждает обходчики и ссылку на 
этот BiVector.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:operator`[`]`(int`):%- [*@4 T][@(0.0.255) `&]_[* operator`[`]]([@(0.0.255) i
nt]_[*@3 i])&]
[s2; Возвращает  ссылку на элемент в указанной 
позиции [%-*@3 i].&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:operator`[`]`(int`)const:%- [@(0.0.255) const]_[*@4 T][@(0.0.255) `&]_[* ope
rator`[`]]([@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2; Возвращает [* const] ссылку на элемент 
в указанной позиции [%-*@3 i].&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:GetCount`(`)const:%- [@(0.0.255) int]_[* GetCount]()_[@(0.0.255) const]&]
[s2; Возвращает число элементов в [* BiVector`'е].&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:IsEmpty`(`)const:%- [@(0.0.255) bool]_[* IsEmpty]()_[@(0.0.255) const]&]
[s2; Тестирует, пуст ли [* BiVector]. То же, что 
и [* GetCount]() `=`= 0.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:Clear`(`):%- [@(0.0.255) void]_[* Clear]()&]
[s2; Удаляет все элементы из этого [* BiVector`'а]..&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:Shrink`(`):%- [@(0.0.255) void]_[* Shrink]()&]
[s2; Минимизирует потребление памяти 
этим [* BiVector`'ом].путём минимизации ёмкости.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:Reserve`(int`):%- [@(0.0.255) void]_[* Reserve]([@(0.0.255) int]_[*@3 n])&]
[s2; Резервирует ёмкость. Если требуемая 
ёмкость [%-*@3 n ]больше, чем текущая, ёмкость 
увеличивается до требуемого значения.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:GetAlloc`(`)const:%- [@(0.0.255) int]_[* GetAlloc]()_[@(0.0.255) const]&]
[s2; Возвращает текущую ёмкость этого 
[* BiVector`'а]..&]
[s3; &]
[s4;%- &]
[s5;:BiVector`:`:Serialize`(Stream`&`):%- [@(0.0.255) void]_[* Serialize]([_^Stream^ Stream
][@(0.0.255) `&]_[*@3 s])&]
[s2; Сериализукт контент этого [* BiVector`'а].в/из 
потока Stream [%-*@3 s].&]
[s6; Требует, чтобы у T был определён оператор 
сериализации.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:IsPicked`(`):%- [@(0.0.255) bool]_[* IsPicked]()&]
[s2; Возвращает [* true], если [* BiVector ]был `"пикнут`", 
false иначе.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:operator`=`(pick`_ BiVector`&`):%- [@(0.0.255) void]_[* operator`=]([@(0.128.128) p
ick`_]_[_^BiVector^ BiVector][@(0.0.255) `&]_[*@3 src])&]
[s2; Pick`=оператор. `"Трансферит`" исходный 
[* BiVector ][%-*@3 src] за константно малое время, 
но разрушает его при пикинге.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:ValueType`:`:typedef:%- [@(0.0.255) typedef]_[*@4 T]_[* ValueType]&]
[s2; Typedef [*@4 T] для использования в шаблонных 
алгоритмах.&]
[s3; &]
[s4;%- &]
[s5;:BiVector`:`:Iterator`:`:typedef:%- [@(0.0.255) typedef]_[_^IIterator^ IIterator][@(0.0.255) <
][_^BiVector^ BiVector][@(0.0.255) >]_[* Iterator]&]
[s2; Тип обходчика.&]
[s3; &]
[s4;%- &]
[s5;:BiVector`:`:ConstIterator`:`:typedef:%- [@(0.0.255) typedef]_[_^ConstIIterator^ Cons
tIIterator][@(0.0.255) <][_^BiVector^ BiVector][@(0.0.255) >]_[* ConstIterator]&]
[s2; Тип константного обходчика.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:Begin`(`)const:%- [_^BiVector`:`:ConstIterator^ ConstIterator]_[* Begin](
)_[@(0.0.255) const]&]
[s7; Возвращает константный обходчик 
к первому элементу в этом BiVector`'е.&]
[s3; &]
[s4;%- &]
[s5;:BiVector`:`:End`(`)const:%- [_^BiVector`:`:ConstIterator^ ConstIterator]_[* End]()_[@(0.0.255) c
onst]&]
[s2; Возвращает константный итератор 
в позицию сразу за последним элементом 
этого BiVector`'а..&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:GetIter`(int`)const:%- [_^BiVector`:`:ConstIterator^ ConstIterator]_[* G
etIter]([@(0.0.255) int]_[*@3 pos])_[@(0.0.255) const]&]
[s2; Возвращает константный итератор 
к элементу в указанной позиции [%-*@3 pos]. 
То же, что и [* Begin() `+ ][%-*@3 pos]. The benefit of this 
method is that [%-*@3 pos] is range checked in debug mode.&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:Begin`(`):%- [_^BiVector`:`:Iterator^ Iterator]_[* Begin]()&]
[s2; Возвращает неконстантный итератор 
к первому элементу в этом [* BiVector`'е]..&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:End`(`):%- [_^BiVector`:`:Iterator^ Iterator]_[* End]()&]
[s2; Возвращает неконстантный итератор 
к позиции сразу за последним элементом 
в этом [* BiVector`'е]..&]
[s3;%- &]
[s4;%- &]
[s5;:BiVector`:`:GetIter`(int`):%- [_^BiVector`:`:Iterator^ Iterator]_[* GetIter]([@(0.0.255) i
nt]_[*@3 pos])&]
[s2; Возвращает неконстантный итератор 
к элементу в указанной позиции. То 
же, что и [* Begin() `+ pos]. The benefit of this method 
is that [* pos] is range checked in debug mode.&]
[s3; &]
[s4; &]
[s5;K%- friend_[@(0.0.255) void][@(64) _]Swap[@(64) (][^`:`:BiVector^@(64) BiVector][@(64) `&_][@3 a
][@(64) , ][^`:`:BiVector^@(64) BiVector][@(64) `&_][@3 b][@(64) )]&]
[s2; Специализация генерного [* Swap] для 
BiVector`'ов. Обменивает BiVector`'ы за константно 
малое время.&]
[s3; &]
[s0;i448;a25;kKO9;@(0.0.255)%- &]
[ {{10000F(128)G(128)@1 [s0; [* Глобальные Операторы]]}}&]
[s3; &]
[s0;:friend BiVector`& operator`<`<`(BiVector`& b`, const T`& x`): friend 
BiVector`& [* operator]<<(BiVector`& [*@3 b], const T`& [*@3 x])&]
[s2; Оператор, заменяющий [* void AddTail(const T`&x)]. 
Возвращая ссылку на этот BiVector, он 
позволяет в одном выражении собирать 
несколько элементов, таким оьразом, 
например, можно конструировать временный 
BiVector как часть выражения, как в Foo(BiVector<int>() 
<< 1 << 2 << 4).&]
[s6; Требует, чтобы у T был конструктор 
глубокой копии (КГК).&]
[s6; Повреждает обходчики и ссылку на 
этот BiVector.&]
[s3; &]
[s4; &]
[s0;:friend BiVector`& operator`>`>`(const T`& x`, BiVector`& b`): friend 
BiVector`& [* operator]>>(const T`& [*@3 x], BiVector`& [*@3 b])&]
[s2; Оператор, заменяющий [* void AddHead(const T`&x)]. 
Возвращая ссылку на этот BiVector, он 
позволяет в одном выражении собирать 
несколько элементов, таким оьразом, 
например, можно конструировать временный 
BiVector как часть выражения, как в Foo(1 
>> (2 >> BiVector<int>())).&]
[s6; Требует, чтобы у T был конструктор 
глубокой копии (КГК).&]
[s6; Повреждает обходчики и ссылку на 
этот BiVector.&]
[s3; &]
[s0; ]]