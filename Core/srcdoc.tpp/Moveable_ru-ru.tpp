topic "Moveable";
[l288;i704;a17;O9;~~~.992;2 $$1,0#10431211400427159095818037425705:param]
[a83;*R6 $$2,5#31310162474203024125188417583966:caption]
[b83;*2 $$3,5#07864147445237544204411237157677:title]
[b167;a42;C2 $$4,6#40027414424643823182269349404212:item]
[b42;a42;ph2 $$5,5#45413000475342174754091244180557:text]
[l288;a17;2 $$6,6#27521748481378242620020725143825:desc]
[l321;t246;C@5;1 $$7,7#20902679421464641399138805415013:code]
[b2503;2 $$8,0#65142375456100023862071332075487:separator]
[*@(0.0.255)2 $$9,0#83433469410354161042741608181528:base]
[t4167;C2 $$10,0#37138531426314131251341829483380:class]
[l288;a17;*1 $$11,11#70004532496200323422659154056402:requirement]
[i417;b42;a42;O9;~~~.416;2 $$12,12#10566046415157235020018451313112:tparam]
[b167;C2 $$13,13#92430459443460461911108080531343:item1]
[i288;a42;O9;C2 $$14,14#77422149456609303542238260500223:item2]
[*@2$(0.128.128)2 $$15,15#34511555403152284025741354420178:NewsDate]
[l321;*C$7;2 $$16,16#03451589433145915344929335295360:result]
[l321;b83;a83;*C$7;2 $$17,17#07531550463529505371228428965313:result`-line]
[l160;t4167;*C+117 $$18,5#88603949442205825958800053222425:package`-title]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[s2; [@3 Moveable]&]
[s5; Первое важное замечание: U`+`+ Moveable 
не следует путать с семантикой move 
из стандартной библиотеки C`+`+.&]
[s5; Понятие Moveable представляет собой 
базовые требования к типам, сохраняемым 
в Vector flavor контейнеров (а именно Vector, 
BiVector, Index, VectorMap, InVector, SortedIndex, SortedVectorMap). 
Чтобы обяснить что это такое (`"и с 
чем его едят`"), почему это так важно, 
для начала создадим очень примитивный 
шаблон Vector`-`"образного`" контейнера&]
[s0; &]
[s7; template <class T>&]
[s7; class SimpleVector `{&]
[s7; -|T  `*vector;&]
[s7; -|int capacity;&]
[s7; -|int items;&]
[s7; &]
[s7; -|void [* Expand()] `{&]
[s7; -|-|capacity `= max(1, 2 `* capacity);&]
[s7; -|-|T `*newvector `= (T `*) new char`[capacity `* sizeof(T)`];&]
[s7; -|-|for(int i `= 0; i < items; i`+`+) `{&]
[s7; -|-|-|[* new(newvector`[i`]) T(vector`[i`])];&]
[s7; -|-|-|[* vector`[i`].T`::`~T();]&]
[s7; -|-|`}&]
[s7; -|-|delete`[`] (char `*) vector;&]
[s7; -|-|vector `= newvector;&]
[s7; -|`}&]
[s7; public:&]
[s7; -|void Add(const T`& x) `{&]
[s7; -|-|if(items >`= capacity) [* Expand()];&]
[s7; -|-|new(vector`[items`+`+`]) T(x);&]
[s7; -|`}&]
[s7; -|T`& operator`[`](int i) `{ return vector`[i`]; `}&]
[s7; -|SimpleVector() `{&]
[s7; -|-|vector `= NULL;&]
[s7; -|-|capacity `= items `= 0;&]
[s7; -|`}&]
[s7; -|`~SimpleVector() `{&]
[s7; -|-|for(int i `= 0; i < items; i`+`+)&]
[s7; -|-|-|vector`[i`].T`::`~T();&]
[s7; -|-|delete`[`] (char `*)vector;&]
[s7; -|`}&]
[s7; `};&]
[s0; &]
[s5; Этот [* SimpleVector] сохраняет добавленные 
элементы в поле`-члене [* vector]. Если места 
для сохранения больше не осталось 
в [* vector], то [* SimpleVector] просто удваивает 
его ёмкость, с помощью метода [* Expand]. 
Этот метод нас`-то и интересует `- так 
как [* Expand ]требует наличия средств 
для копирования значений элементов 
из исходной области памяти во вновь 
размещённую. В версии выше, для этой 
цели используется размещение new и 
конструктор копии. Это, к тому же, 
означает, что [* SimpleVector`'у] требуется, 
чтобы у T был конструктор копии (в 
терминах стандартной библиотеки 
C`+`+: он должен быть [/ copy`-constructible]). Теперь 
создадим типичный элемент, который 
можно сохранить в таком контейнере&]
[s0; &]
[s7; class SimpleString `{&]
[s7; -|char `*text;&]
[s7; public:&]
[s7; -|SimpleString(const char `*txt) `{&]
[s7; -|-|text `= new char`[strlen(txt)`+1`];&]
[s7; -|-|strcpy(text, txt);&]
[s7; -|`}&]
[s7; -|SimpleString(const SimpleString`& s) `{&]
[s7; -|-|text `= new char`[strlen(s.text)`+1`];&]
[s7; -|-|strcpy(text, s.text);&]
[s7; -|`}&]
[s7; -|void operator`=(const SimpleString`& s) `{&]
[s7; -|-|delete`[`] text;&]
[s7; -|-|text `= new char`[strlen(s.text)`+1`];&]
[s7; -|-|strcpy(text, s.text);-|-|&]
[s7; -|`}&]
[s7; -|`~SimpleString() `{&]
[s7; -|-|delete`[`] text;&]
[s7; -|`}&]
[s7; `};&]
[s0; &]
[s5; и смотрим, что происходит, когда [* SimpleVector] 
из [* SimpleString`'ов] `"расширяется`": Во`-первых, 
создаются копии всех элементов, что 
означает размещение нового хранилища 
для члена [* text] нового элемента и копирование 
исходного [* text] в него, с помощью [* strcpy]. 
Моментом позднее, [* Expand] вызывает для 
элемента деструктор, таким образом 
удаляются все [* text`'ы ]в исходных элементах. 
Не кажется ли, что на этом мы теряем 
много циклов ЦПБ (CPU), просто чтобы 
сделать копии вещей, которые чуть 
позднее просто выбросим, в любом случае? 
А что если вместо делания копий нашёлся 
бы какой`-то способ перемещения (трансфера) 
членов [* text] исходных элементов в новые 
элементы?.. и как`-то был запрешён [* delete`[`] 
text] в деструкторе?.. Смотрите, как можно 
это `"опримитивить`":&]
[s0; &]
[s7; template <class T>&]
[s7; class SimpleVector `{&]
[s7; -|T  `*vector;&]
[s7; -|int capacity;&]
[s7; -|int items;&]
[s7; &]
[s7; -|void Expand() `{&]
[s7; -|-|capacity `= max(1, 2 `* capacity);&]
[s7; -|-|T `*newvector `= (T `*) new char`[capacity `* sizeof(T)`];&]
[s7; -|-|[* memcpy(newvector, vector, items `* sizeof(T));]&]
[s7; -|-|delete`[`](char `*)vector;&]
[s7; -|-|vector `= newvector;&]
[s7; -|`}&]
[s7; public:&]
[s7; -|void Add(const T`& x) `{&]
[s7; -|-|if(items >`= capacity) Expand();&]
[s7; -|-|new(vector`[items`+`+`]) T(x);&]
[s7; -|`}&]
[s7; -|SimpleVector() `{&]
[s7; -|-|vector `= NULL;&]
[s7; -|-|capacity `= items `= 0;&]
[s7; -|`}&]
[s7; -|`~SimpleVector() `{&]
[s7; -|-|for(int i `= 0; i < items; i`+`+)&]
[s7; -|-|-|vector`[i`].T`::`~T();&]
[s7; -|-|delete`[`] (char `*)vector;&]
[s7; -|`}&]
[s7; `};&]
[s0; &]
[s5; Проигрнорируем тот факт, что, используя 
memcpy для move`'инга не`-POD типов, мы нарушаем 
стандарт C`+`+ (обсудим это позднее).Теперь 
мы получили ровных счётом то, что 
хотели,`- вместо череды копиконструкций 
и деструкций мы просто копируем сырые 
двоичные данные в новое положение. 
Таким образом, мы просто переносим 
старые значения из членов [* text ]элементов 
в новый расширенный [* vector]. Не нужно 
вызывать ни конструктор копий, ни 
деструктор при расширении вектора. 
Не потерян даром ни один цикл ЦПБ!&]
[s5; Типы, которые можно перемещать в 
памяти с помощью memcpy, называются [*/ moveable.]&]
[s5; Ясно, что не все типы moveable (т.е. `"перемещаемы`"
). Чтобы быть `"перемещаемым`", это как`-то 
связано с [/ несохранением ]ссылок на 
сам объект или на его части. Пример:&]
[s0; &]
[s7; struct Link `{&]
[s7; -|Link `*prev;&]
[s7; public:&]
[s7; -|Link()        `{ prev `= nullptr; `}&]
[s7; -|Link(Link `*p) `{ prev `= p; `}&]
[s7; `};&]
[s0; &]
[s5; это [* не] moveable, так как memcpy`'ирование 
в новую локацию сломает существующие 
связи. Все следующие требования должны 
выполняться для типов moveable:&]
[s5;l128;i150;O0; У него нет никакого виртуального 
метода, нет никакого виртуального 
класса`-основы.&]
[s5;l128;i150;O0; Классы`-основы (если они есть) 
и переменные`-члены любого экземпляра 
`"суть`" moveable.&]
[s5;l128;i150;O0; Нет ссылок или указателей 
сохранённых в самом объекте, либо 
в подобъектах в методах типа, в переменных, 
которые существуют, после того как 
метод завершил выполнение. &]
[s5; Фундаментальные типы удовлетворяют 
этим требованиям, поэтому они moveable.&]
[s5; Пример:&]
[s0; &]
[s7; struct Foo;&]
[s7; &]
[s7; Foo `*global`_foo;&]
[s0; &]
[s7; struct Foo `{&]
[s7; -|int a;&]
[s7; -|Foo `*foo;&]
[s7; -|int `*ptr;&]
[s7; public:&]
[s7; -|void Set(Foo `*f) `{&]
[s7; -|-|foo `= f;&]
[s7; -|`}&]
[s7; -|void Ok1() `{&]
[s7; -|-|Foo `*x `= this;&]
[s7; -|// локальная переменная не будет 
существовать вне метода&]
[s7; -|// `-> не мешает Foo быть moveable&]
[s7; -|`}&]
[s7; -|void Ok2() `{&]
[s7; -|-|memset(`&a, 0, sizeof(int));&]
[s7; -|// указатель не будет существовать 
вне метода&]
[s7; -|// `-> не мешает Foo быть moveable&]
[s7; -|`}&]
[s7; -|void Bad1() `{&]
[s7; -|-|foo `= this;&]
[s7; -|// переменная`-член foo существует 
вне метода&]
[s7; -|// `-> делает Foo не`-moveable&]
[s7; -|`}&]
[s7; -|void Bad2() `{&]
[s7; -|-|ptr `= `&a;&]
[s7; -|// указатель на подобъект сохранён, 
ptr существует вне метода&]
[s7; -|// `-> делает Foo не`-moveable&]
[s7; -|`}&]
[s7; -|void Bad3() `{&]
[s7; -|-|global`_foo `= this;&]
[s7; -|// указатель хранит глобальную переменную&]
[s7; -|// `-> делает Foo не`-moveable&]
[s7; -|`}&]
[s7; -|void Bad4(Foo`& another) `{&]
[s7; -|-|another.Set(this);&]
[s7; -|// указатель косвенно сохраняется 
в объекте, существующем вне метода&]
[s7; -|// `-> делает Foo не`-moveable&]
[s7; -|`}&]
[s7; `};&]
[s0; &]
[s5; Этим требованиям соответствует довольно 
большое количество типов; большинство 
типов, которые требуется хранить 
в контейнере элементов одного типа, 
являются moveable. Что наиболее важно, 
все крнтейнеры NTL [* являются ]moveable.&]
[s5; Теперь у нас есть действенный способ 
организовывать сохранение элементов 
в контейнерах. Нам нужно иметь дело 
с тем фактом, что быть moveable  `- это часть 
интерфейса объекта, и нужно следить 
за тем, чтобы только movable эоементы 
сохранялись в контейнерах NTL. Для 
этого нам нужен способ объявлять 
во время компиляции, что некий тип 
есть moveable, а также способ проверки 
этого.&]
[s5; Чтобы добиться этой цели, можно отметить 
типы moveable, произведя их от шаблонного 
класса [* Moveable], например:&]
[s0; &]
[s7; class SimpleString : Moveable<SimpleString> `{ ... `}&]
[s0; &]
[s5; Альтернативно можно использовать 
макрос [* NTL`_MOVEABLE , ]чтобы метить типы 
как moveable, если интерфейс класса нельзя 
изменить, как в случае:&]
[s0; &]
[s7; NTL`_MOVEABLE(std`::string);&]
[s0; &]
[s5; Теперь, когда мы можем отмечать типы 
как moveable, нам нужен способ проверки 
типа на перемещаемость. Это выполняется 
добавкой строки:&]
[s0; &]
[s7; AssertMoveable<T>()&]
[s0; &]
[s5; в один из методов шаблона, который 
компилируется для любого аргумента 
шаблона `- деструктор наиболее очевидное 
место. Функция [* AssertMovable] определяется 
только, если [* T] отмечен как moveable, таким 
образом, она приводит к ошибке компиляции 
для не`-moveable типов T.&]
[s5; Наконец, настало время разобраться 
со стандартом C`+`+. Текущий C`+`+ определяет 
memcpy только для типов POD. Понятие moveable 
требует определения memcpy для не`-POD 
типов. Фактически, разница между POD 
и moveable не`-POD типами состоит в существовании 
конструкторов и невиртуальных деструкторов
. Чтобы это работало, всё, что требуется, 
`-  чтобы результат memcpy`'ирования не`-POD 
типа [* T ]был такой же, как у memcpy`'ирования 
типа POD [* T1] , который можно получить, 
удалив деструктор и конструкторы 
из [* T]. Покуда эта операция всё ещё 
не определена в C`+`+, трудно представить 
себе оптимальную реализацию C`+`+, которая 
нарушит это правило. Действительно, 
вся текущая реализация, встречавшаяся 
нам доселе, поддерживает семантику 
moveable, способом, который мы здесь определили. 
Производительность и прочие достижения, 
реализуемые использованием этого 
концепта о moveable, очень велики, чтобы 
остаться незамеченными.&]
[s5; ]]