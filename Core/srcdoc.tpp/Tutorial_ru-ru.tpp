topic "Учебник по U++ Core";
[l288;i1120;a17;O9;~~~.1408;2 $$1,0#10431211400427159095818037425705:param]
[a83;*R6 $$2,5#31310162474203024125188417583966:caption]
[b83;*4 $$3,5#07864147445237544204411237157677:title]
[i288;O9;C2 $$4,6#40027414424643823182269349404212:item]
[b42;a42;ph2 $$5,5#45413000475342174754091244180557:text]
[l288;b17;a17;2 $$6,6#27521748481378242620020725143825:desc]
[l321;C@5;1 $$7,7#20902679421464641399138805415013:code]
[b2503;2 $$8,0#65142375456100023862071332075487:separator]
[*@(0.0.255)2 $$9,0#83433469410354161042741608181528:base]
[C2 $$10,0#37138531426314131251341829483380:class]
[l288;a17;*1 $$11,11#70004532496200323422659154056402:requirement]
[i417;b42;a42;O9;~~~.416;2 $$12,12#10566046415157235020018451313112:tparam]
[b167;C2 $$13,13#92430459443460461911108080531343:item1]
[i288;a42;O9;C2 $$14,14#77422149456609303542238260500223:item2]
[*@2$(0.128.128)2 $$15,15#34511555403152284025741354420178:NewsDate]
[l321;*C$7;2 $$16,16#03451589433145915344929335295360:result]
[l321;*C$7;2 $$17,17#07531550463529505371228428965313:result`-line]
[l160;*C+117 $$18,5#88603949442205825958800053222425:package`-title]
[2 $$19,0#53580023442335529039900623488521:gap]
[C2 $$20,20#70211524482531209251820423858195:class`-nested]
[b50;2 $$21,21#03324558446220344731010354752573:Par]
[H8;b73;*+150 $$22,5#07864147445237544204111237153677:subtitle]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_} 
[s2;%RU-RU [@5 Учебник по U`+`+ Core]&]
[s22; Содержание&]
[s0;^`#Chapter`_1^ &]
[s0; [^`#Chapter`_1^ 1. Основы]&]
[s0; ___[^`#Section`_1`_1^ 1.1 Логгирование]&]
[s0; ___[^`#Section`_1`_2^ 1.2 String]&]
[s0; ___[^`#Section`_1`_3^ 1.3 StringBuffer]&]
[s0; ___[^`#Section`_1`_4^ 1.4 WString]&]
[s0; ___[^`#Section`_1`_5^ 1.5 Date и Time]&]
[s0; ___[^`#Section`_1`_6^ 1.6 AsString, ToString и operator<<]&]
[s0; ___[^`#Section`_1`_7^ 1.7 CombineHash]&]
[s0; ___[^`#Section`_1`_8^ 1.8 SgnCompare и CombineCompare]&]
[s0; &]
[s0; [^`#Chapter`_2^ 2. Потоки]&]
[s0; ___[^`#Section`_2`_1^ 2.1 Основы Потоков]&]
[s0; ___[^`#Section`_2`_2^ 2.2 Особые Потоки]&]
[s0; ___[^`#Section`_2`_3^ 2.3 Двоичная сериализация]&]
[s0; &]
[s0; [^`#Chapter`_3^ 3. Контейнеры`-массивы]&]
[s0; ___[^`#Section`_3`_1^ 3.1 Основы Векторов]&]
[s0; ___[^`#Section`_3`_2^ 3.2 Векторные операции]&]
[s0; ___[^`#Section`_3`_3^ 3.3 Проблемы Трансфера]&]
[s0; ___[^`#Section`_3`_4^ 3.4 Клиентские типы в контейнерах 
U`+`+]&]
[s0; ___[^`#Section`_3`_5^ 3.5 Array flavor]&]
[s0; ___[^`#Section`_3`_6^ 3.6Полиморфный Массив]&]
[s0; ___[^`#Section`_3`_7^ 3.7 Двунаправленные контейнеры]&]
[s0; ___[^`#Section`_3`_8^ 3.8 Индекс]&]
[s0; ___[^`#Section`_3`_9^ 3.9 Индекс и клиентские 
типы]&]
[s0; ___[^`#Section`_3`_10^ 3.10 VectorMap, ArrayMap]&]
[s0; ___[^`#Section`_3`_11^ 3.11 One]&]
[s0; ___[^`#Section`_3`_12^ 3.12 Any]&]
[s0; ___[^`#Section`_3`_13^ 3.13 InVector, InArray]&]
[s0; ___[^`#Section`_3`_14^ 3.14 SortedIndex, SortedVectorMap, SortedArrayMap]&]
[s0; ___[^`#Section`_3`_15^ 3.15  Кортежи]&]
[s0; &]
[s0; [^`#Chapter`_4^ 4. Диапазоны и Алгоритмы]&]
[s0; ___[^`#Section`_4`_1^ 4.1 Диапазон]&]
[s0; ___[^`#Section`_4`_2^ 4.2 Алгоритмы]&]
[s0; ___[^`#Section`_4`_3^ 4.3 Сортировка]&]
[s0; &]
[s0; [^`#Chapter`_5^ 5. Значение]&]
[s0; ___[^`#Section`_5`_1^ 5.1 Value]&]
[s0; ___[^`#Section`_5`_2^ 5.2 Null]&]
[s0; ___[^`#Section`_5`_3^ 5.3 Клиентские типы и Value, 
RawValue, RichValue]&]
[s0; ___[^`#Section`_5`_4^ 5.4 ValueArray и ValueMap]&]
[s0; &]
[s0; [^`#Chapter`_6^ 6. Функция и лямбды]&]
[s0; ___[^`#Section`_6`_1^ 6.1 Function]&]
[s0; ___[^`#Section`_6`_2^ 6.2 Захват контейнеров 
U`+`+ в лямбдах]&]
[s0; &]
[s0; [^`#Chapter`_7^ 7. Многопоточность]&]
[s0; ___[^`#Section`_7`_1^ 7.1 Thread]&]
[s0; ___[^`#Section`_7`_2^ 7.2 Mutex]&]
[s0; ___[^`#Section`_7`_3^ 7.3 ConditionVariable]&]
[s0; ___[^`#Section`_7`_4^ 7.4 CoWork]&]
[s0; ___[^`#Section`_7`_5^ 7.5 AsyncWork]&]
[s0; ___[^`#Section`_7`_6^ 7.6 CoPartition]&]
[s0; ___[^`#Section`_7`_7^ 7.7 CoDo]&]
[s0; ___[^`#Section`_7`_8^ 7.8 Параллельные алгоритмы]&]
[s22;:Chapter`_1: [@3 1. Основы]&]
[s3;:Section`_1`_1: [@(128.0.255) 1.1 Логгирование]&]
[s5; Логгирование (Logging) `- это техника, 
применяемая для трассировки потока 
кода и изучения результатов. В этом 
уроке мы будем экстенсивно его использовать
, поэтому начнём с объяснения.&]
[s5; В режиме отладки и с дефолтными настройками
, макрос [*C@5 LOG] помещает строку в файл 
вывода лога. Файл лога находится в 
директории `'config`-directory`', которая дефолтно 
является директорией с .exe на Win32 и 
`~/.upp/appname на POSIX.&]
[s5; В DinrusIDE лог доступен с помощью `'Отладка`'/`'По
смотреть лог`-файл Alt`+L`'.&]
[s0; &]
[s7; LOG(`"Hello world`");&]
[s0; &]
[s17; Hello world&]
[s0; &]
[s5; `"Логировать`" можно значения любых 
типов, если для них определена функция 
[*C@5 AsString.] Можно сцеплять значения в 
одном макросе [*C@5 LOG] с помощью [*C@5 operator<<]:&]
[s0; &]
[s7; int x `= 123;&]
[s7; LOG(`"Значение x равно `" << x);&]
[s0; &]
[s17; Значение x равно 123&]
[s0; &]
[s5; Так как довольно распространено 
логирование значения единичной переменной, 
макрос [*C@5 DUMP] предлагает полезное 
сокращение, создающее строку лога 
и именем и значением переменной:&]
[s0; &]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= 123&]
[s0; &]
[s5; Чтобы получить значение из 16`-ричного 
кода, используется [*C@5 LOGHEX] / [*C@5 DUMPHEX]&]
[s0; &]
[s7; DUMPHEX(x);&]
[s7; String h `= `"foo`";&]
[s7; DUMPHEX(h);&]
[s0; &]
[s17; x `= 0x7b&]
[s17; h `= Memory at 0x0208fe08, size 0x3 `= 3&]
[s17;     `+0 0x0208FE08 66 6F 6F                                 
           foo             &]
[s0; &]
[s5; Для логгирования значения контейнера 
(или генерного Range), можно либо использовать 
обычный [*C@5 LOG] / [*C@5 DUMP]:&]
[s0; &]
[s7; Vector<int> v `= `{ 1, 2, 3 `};&]
[s7; &]
[s7; DUMP(v);&]
[s0; &]
[s17; v `= `[1, 2, 3`]&]
[s0; &]
[s5; либо DUMPC для многострочного вывода:&]
[s0; &]
[s7; DUMPC(v);&]
[s0; &]
[s17; v:&]
[s17; -|`[0`] `= 1&]
[s17; -|`[1`] `= 2&]
[s17; -|`[2`] `= 3&]
[s0; &]
[s5; Для мапов (карт) используется DUMPM:&]
[s0; &]
[s7; VectorMap<int, String> map `= `{ `{ 1, `"one`" `}, `{ 2, `"two`" 
`} `};&]
[s7; &]
[s7; DUMP(map);&]
[s0; &]
[s17; map `= `{1: one, 2: two`}&]
[s0; &]
[s0; &]
[s7; DUMPM(map);&]
[s0; &]
[s17; map:&]
[s17; -|`[0`] `= (1) one&]
[s17; -|`[1`] `= (2) two&]
[s0; &]
[s5; Все нормальные [*C@5 LOG]s удаляются в 
режиме выпуска. Если требуется что`-то 
логгировать в релизном режиме, нужно 
использовать вариант [*C@5 LOG]/``DUMP`` с 
префиксом `'[*C@5 R]`' ([*C@5 RLOG], [*C@5 RDUMP], [*C@5 RDUMPHEX]...):&]
[s0; &]
[s7; RLOG(`"Это будет также логгировано и 
в релизном режиме!`");&]
[s0; &]
[s17; Это будет также логгировано и в релизном 
режиме!&]
[s0; &]
[s5; Своего рода противоположная ситуация, 
когда для отладки кода ведутся временные 
[*C@5 LOG]s. В этом случае применимы варианты, 
префиксованные  `'[*C@5 D]`' ([*C@5 DLOG], [*C@5 DDUMP], 
[*C@5 DDUMPHEX]...) `- в релизном режиме они 
вызывают ошибку компиляции (если 
в главной конфигурации не установлен 
флаг DEBUGCODE), поэтому о нём нельзя забыть 
и оставить в коде после выпуска:&]
[s0; &]
[s7; DLOG(`"This would not compile in release mode.`");&]
[s0; &]
[s17; This would not compile in release mode.&]
[s0; &]
[s5; Последняя разновидность [*C@5 LOG,] которая 
может встретиться при чтении исходников 
U`+`+,`- префиксированная `'[*C@5 L]`'. Она 
в реальности не определена в библиотеке 
U`+`+, а простая конвенция. В начале 
файла обычно можно встретить:&]
[s0; &]
[s7; #define LLOG(x) // DLOG(x)&]
[s0; &]
[s5; убрав комментарий из части тела, 
можно активировать логгирование 
для этого отдельного файла.&]
[s5; Хотя логгирование в файл .log является 
дефолтом, есть различные способы 
повлиять на логгирование, например, 
следующая строка регулирует логгирование 
на вывод как в лог`-файл, так и на консоль:&]
[s0; &]
[s7; StdLogSetup(LOG`_COUT`|LOG`_FILE);&]
[s0; &]
[s3;H4;:Section`_1`_2: [@(128.0.255) 1.2 String (Строка)]&]
[s5; String `- тип значения, используемый 
для сохранения текста или двоичных 
данных.&]
[s0; &]
[s7; String a `= `"Hello`";&]
[s7; DUMP(a);&]
[s0; &]
[s17; a `= Hello&]
[s0; &]
[s5; Строки можно объединять (concatenate) `- 
конкатенировать `- с другой String или 
литералом:&]
[s0; &]
[s7; a `= a `+ `" world`";&]
[s7; DUMP(a);&]
[s0; &]
[s17; a `= Hello world&]
[s0; &]
[s5; а также с единичным символом или 
заданным числом символов из другой 
[*C@5 String] или литерала:&]
[s0; &]
[s7; a.Cat(`'!`');&]
[s7; DUMP(a);&]
[s0; &]
[s17; a `= Hello world!&]
[s0; &]
[s0; &]
[s7; a.Cat(`"ABCDEFGHIJKLM`", 3);&]
[s7; DUMP(a);&]
[s0; &]
[s17; a `= Hello world!ABC&]
[s0; &]
[s5; Метод [*C@5 Clear] делает String пустой:&]
[s0; &]
[s7; a.Clear();&]
[s7; DUMP(a);&]
[s0; &]
[s17; a `= &]
[s0; &]
[s5; Можно использовать [*C@5 operator<<] , чтобы 
приставить к существующей [*C@5 String]. 
Нестроковые значения преобразуются 
в соответствующее строковое представление 
(используется стандартная функция 
[*C@5 AsString], дефолтное шаблонное определение 
которой для значения называется методом 
[*C@5 ToString]):&]
[s0; &]
[s7; for(int i `= 0; i < 10; i`+`+)&]
[s7; -|a << i << `", `";&]
[s7; &]
[s7; DUMP(a);&]
[s0; &]
[s17; a `= 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &]
[s0; &]
[s5; Иногда используют [*C@5 operator<<], чтобы 
произвести временное значение типа 
[*C@5 String] (например, как реальный аргумент 
к вызову функции):&]
[s0; &]
[s7; String b `= String() << `"Number is `" << 123 << `".`";&]
[s7; &]
[s7; DUMP(b);&]
[s0; &]
[s17; b `= Number is 123.&]
[s0; &]
[s5; Класс String предоставляет много различных 
методов для получения числа символов, 
вставки или удаления символов в/из 
[*C@5 String]:&]
[s0; &]
[s7; a `= `"0123456789`";&]
[s7; &]
[s7; DUMP(a.GetCount());&]
[s0; &]
[s17; a.GetCount() `= 10&]
[s0; &]
[s0; &]
[s7; DUMP(a.GetLength()); // GetLength `- это синоним GetCount&]
[s0; &]
[s17; a.GetLength() `= 10&]
[s0; &]
[s0; &]
[s7; a.Insert(6, `"<inserted>`");&]
[s7; DUMP(a);&]
[s0; &]
[s17; a `= 012345<inserted>6789&]
[s0; &]
[s0; &]
[s7; a.Remove(2, 2);&]
[s7; DUMP(a);&]
[s0; &]
[s17; a `= 0145<inserted>6789&]
[s0; &]
[s5; а также методы поиска и сравнения:&]
[s0; &]
[s7; DUMP(a.Find(`'e`'));&]
[s7; DUMP(a.ReverseFind(`'e`'));&]
[s0; &]
[s17; a.Find(`'e`') `= 8&]
[s17; a.ReverseFind(`'e`') `= 11&]
[s0; &]
[s0; &]
[s7; DUMP(a.Find(`"ins`"));&]
[s0; &]
[s17; a.Find(`"ins`") `= 5&]
[s0; &]
[s0; &]
[s7; DUMP(a.StartsWith(`"ABC`"));&]
[s7; DUMP(a.StartsWith(`"01`"));&]
[s7; DUMP(a.EndsWith(`"89`"));&]
[s0; &]
[s17; a.StartsWith(`"ABC`") `= false&]
[s17; a.StartsWith(`"01`") `= true&]
[s17; a.EndsWith(`"89`") `= true&]
[s0; &]
[s5; Можно получить срез String с помощью 
метода Mid; с одним параметром он даёт 
срез до конца строки:&]
[s0; &]
[s7; DUMP(a.Mid(3, 3));&]
[s7; DUMP(a.Mid(3));&]
[s0; &]
[s17; a.Mid(3, 3) `= 5<i&]
[s17; a.Mid(3) `= 5<inserted>6789&]
[s0; &]
[s5; Можно также обрезать длину строки, 
используя Trim (это быстрее, чем использование
 любого другого метода):&]
[s0; &]
[s7; a.Trim(4);&]
[s7; DUMP(a);&]
[s0; &]
[s17; a `= 0145&]
[s0; &]
[s5; Можно получить целочисленные значения 
индивидуальных символов с помощью 
operator`[`]:&]
[s0; &]
[s7; DUMP(a`[0`]);&]
[s0; &]
[s17; a`[0`] `= 48&]
[s0; &]
[s5; или значение первого символа с помощью 
operator`* (заметьте, что если [*C@5 GetCount() 
`=`= 0], this вернёт терминатор ноль):&]
[s0; &]
[s7;     DUMP(`*a);&]
[s0; &]
[s17; `*a `= 48&]
[s0; &]
[s0; &]
[s7;     a.Clear();&]
[s7;     &]
[s7;     DUMP(`*a);&]
[s0; &]
[s17; `*a `= 0&]
[s0; &]
[s5; [*C@5 String] имеет неявный каст (implicit cast), 
приведение к типу, [*C@5 const char `*ptr] с нулевым 
окончанием (которое полноценно, пока 
[*C@5 String] остаётся неизменённой):&]
[s0; &]
[s7; a `= `"1234`";&]
[s7; const char `*s `= a;&]
[s7; while(`*s)&]
[s7; -|LOG(`*s`+`+);&]
[s0; &]
[s17; 1&]
[s17; 2&]
[s17; 3&]
[s17; 4&]
[s0; &]
[s5; [*C@5 String] также имеет стандартные методы 
[*C@5 begin] [*C@5 end], которые, например, позволяют 
использовать из C`+`+11 конструкцию 
[*C@5 for]:&]
[s0; &]
[s7; for(char ch : a)&]
[s7; -|LOG(ch);&]
[s0; &]
[s17; 1&]
[s17; 2&]
[s17; 3&]
[s17; 4&]
[s0; &]
[s5; Абсолютно OK `- и обще `- использовать 
String для сохранения двоичных данных, 
включая нули:&]
[s0; &]
[s7; a.Cat(0);&]
[s7; &]
[s7; DUMPHEX(a);&]
[s0; &]
[s17; a `= Memory at 0x0208fde0, size 0x5 `= 5&]
[s17;     `+0 0x0208FDE0 31 32 33 34 00                           
           1234.           &]
[s0; &]
[s3;H4;:Section`_1`_3: [@(128.0.255) 1.3 StringBuffer]&]
[s5; Если требуется прямой доступ для 
записи к [*C@5 String]`'овому C`-string буферу 
символов, можно использовать комплементарны
й класс [*C@5 StringBuffer]. Одна из причин это 
делать `- когда нужно работать с некоторыми 
функциями C`-API, которые ожидают прямой 
записи в [*C@5 char `*, ]а вам хотелось бы, 
чтобы результат был преобразован 
в [*C@5 String]:&]
[s0; &]
[s7; void CApiFunction(char `*c)&]
[s7; `{&]
[s7; -|strcpy(c, `"Hello`");&]
[s7; `}&]
[s7; &]
[s7; StringBuffer b;&]
[s7; b.SetLength(200);&]
[s7; CApiFunction(b);&]
[s7; b.Strlen();&]
[s7; String x `= b;&]
[s7; &]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= Hello&]
[s0; &]
[s5; В данном случае, [*C@5 SetLength] создаёт 
массив Си из 200 символов. Затем можно 
вызвать функцию C`-API. Далее устанавливается 
реальная длина с помощью [*C@5 Strlen] `- 
фукнция эта выполняет strlen буфера 
и устанавливает соответственно длину. 
Позже мы просто присваиваем [*C@5 StringBuffer] 
к [*C@5 String]. Заметьте, по причинам производитель
ности, эта операция очищает от содержимого 
[*C@5 StringBuffer] (операция быстрая и не зависит 
от числа символов).&]
[s5; Другой сценарий StringBuffer `- изменение 
существующей String:&]
[s0; &]
[s7; b `= x;&]
[s7; b`[1`] `= `'a`';&]
[s7; x `= b;&]
[s7; &]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= Hallo&]
[s0; &]
[s5; Подобно присваиванию StringBuffer к String, 
присваивание String к StringBuffer очищает 
исходную String.&]
[s5; StringBuffer также предоставляет операции 
по приставлению (appending operations):&]
[s0; &]
[s7; b `= x;&]
[s7; b.Cat(`'!`');&]
[s7; x `= b;&]
[s7; &]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= Hallo!&]
[s0; &]
[s5; Заметьте, что иногда, при создании 
какой`-либо String из множества единичных 
символов, использовать StringBuffer для 
такой операции работает несколько 
скорее, чем прямое использование 
String.&]
[s3;H4;:Section`_1`_4: [@(128.0.255) 1.4 WString]&]
[s5; String работает с 8`-битными символами. 
Для 16`-битной символьной кодировки 
используется [*C@5 WString]. Оба класса тесно 
связаны и разделяют большинство методов 
интерфейса. U`+`+ также предоставляет 
преобразования между [*C@5 String] и [*C@5 WString,] 
также можно использовать и 8`-битные 
строковые литералы с [*C@5 WString]. Преобразование
 проводится по правилам текущего 
дефолтного набора символов. Дефолтное 
значение дефолтного набора символов 
`- [*C@5 CHARSET`_UTF8]. Это преобразование также 
используется и в [*C@5 WString`::ToString], например, 
при помещении [*C@5 WString] в лог:&]
[s0; &]
[s7; WString x `= `"characters 280`-300: `"; // можно присвоить 
8`-битный символьный литерал WString&]
[s7; for(int i `= 280; i < 300; i`+`+)&]
[s7; -|x.Cat(i);&]
[s7; &]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= characters 280`-300: ĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪī&]
[s0; &]
[s5; [*C@5 ToString] преобразует [*C@5 WString] в [*C@5 String]:&]
[s0; &]
[s7; String y `= x.ToString();&]
[s7; DUMP(y);&]
[s0; &]
[s17; y `= characters 280`-300: ĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪī&]
[s0; &]
[s5; [*C@5 ToWString] преобразует [*C@5 String] в [*C@5 WString]:&]
[s0; &]
[s7; y.Cat(`" (appended)`"); // можно использовать 
8`-битные символьные литералы в большинстве&]
[s7;                      // операций с WString&]
[s7; x `= y.ToWString();&]
[s7; &]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= characters 280`-300: ĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪī 
(appended)&]
[s0; &]
[s3;H4;:Section`_1`_5: [@(128.0.255) 1.5 Date и Time]&]
[s5; Для представления дат и времени, 
U`+`+ предоставляет конкретные типы 
 [*C@5 Date] и [*C@5 Time].&]
[s0; &]
[s7; Date date `= GetSysDate();&]
[s7; &]
[s7; DUMP(date);&]
[s0; &]
[s17; date `= 07/21/2021&]
[s0; &]
[s5; Все члены данных структуры [*C@5 Date] 
публичны (public):&]
[s0; &]
[s7; DUMP((int)date.year); // нужно сделать каст 
в int, т.к. некоторые члены даты&]
[s7; DUMP((int)date.month); // типа беззначного символа, 
что логируется&]
[s7; DUMP((int)date.day); // как символы&]
[s0; &]
[s17; (int)date.year `= 2021&]
[s17; (int)date.month `= 7&]
[s17; (int)date.day `= 21&]
[s0; &]
[s5; Даты можно сравнивать:&]
[s0; &]
[s7; DUMP(date > Date(2000, 1, 1));&]
[s0; &]
[s17; date > Date(2000, 1, 1) `= true&]
[s0; &]
[s5; При прибавлении числа к [*C@5 Date] к ней 
прибавляется число дней, а инкрементировани
е/декрементирование приводит к следующему/п
редыдущему дню:&]
[s0; &]
[s7; DUMP(date `+ 1);&]
[s7; DUMP(`-`-date);&]
[s7; DUMP(`+`+date);&]
[s0; &]
[s17; date `+ 1 `= 07/22/2021&]
[s17; `-`-date `= 07/20/2021&]
[s17; `+`+date `= 07/21/2021&]
[s0; &]
[s5; При вычитании дат получается число 
дней между ними:&]
[s0; &]
[s7; DUMP(date `- Date(2000, 1, 1));&]
[s0; &]
[s17; date `- Date(2000, 1, 1) `= 7872&]
[s0; &]
[s5; Несколько функций связано с [*C@5 Date] 
и календарём:&]
[s0; &]
[s7; DUMP(IsLeapYear(2012));&]
[s7; DUMP(IsLeapYear(2014));&]
[s7; DUMP(IsLeapYear(2015));&]
[s7; DUMP(IsLeapYear(2016));&]
[s7; DUMP(IsLeapYear(2017));&]
[s0; &]
[s17; IsLeapYear(2012) `= true&]
[s17; IsLeapYear(2014) `= false&]
[s17; IsLeapYear(2015) `= false&]
[s17; IsLeapYear(2016) `= true&]
[s17; IsLeapYear(2017) `= false&]
[s0; &]
[s0; &]
[s7; DUMP(GetDaysOfMonth(2, 2015));&]
[s7; DUMP(GetDaysOfMonth(2, 2016));&]
[s0; &]
[s17; GetDaysOfMonth(2, 2015) `= 28&]
[s17; GetDaysOfMonth(2, 2016) `= 29&]
[s0; &]
[s0; &]
[s7; DUMP(DayOfWeek(date)); // 0 равно Воскресенью&]
[s0; &]
[s17; DayOfWeek(date) `= 3&]
[s0; &]
[s0; &]
[s7; DUMP(LastDayOfMonth(date));&]
[s7; DUMP(FirstDayOfMonth(date));&]
[s7; DUMP(LastDayOfYear(date));&]
[s7; DUMP(FirstDayOfYear(date));&]
[s7; DUMP(DayOfYear(date)); // число дней с Jan`-1 `+ 1&]
[s7; DUMP(DayOfYear(Date(2016, 1, 1)));&]
[s0; &]
[s17; LastDayOfMonth(date) `= 07/31/2021&]
[s17; FirstDayOfMonth(date) `= 07/01/2021&]
[s17; LastDayOfYear(date) `= 12/31/2021&]
[s17; FirstDayOfYear(date) `= 01/01/2021&]
[s17; DayOfYear(date) `= 202&]
[s17; DayOfYear(Date(2016, 1, 1)) `= 1&]
[s0; &]
[s0; &]
[s7; DUMP(AddMonths(date, 20));&]
[s7; DUMP(GetMonths(date, date `+ 100)); // число `'полных 
месяцев`' между двумя датами&]
[s7; DUMP(GetMonthsP(date, date `+ 100)); // число`'полных 
или частичных месяцев`' между двумя 
датами&]
[s7; DUMP(AddYears(date, 2));&]
[s0; &]
[s17; AddMonths(date, 20) `= 03/21/2023&]
[s17; GetMonths(date, date `+ 100) `= 3&]
[s17; GetMonthsP(date, date `+ 100) `= 4&]
[s17; AddYears(date, 2) `= 07/21/2023&]
[s0; &]
[s0; &]
[s7; DUMP(GetWeekDate(2015, 1));&]
[s7; int year;&]
[s7; DUMP(GetWeek(Date(2016, 1, 1), year)); // первый день 
года может относиться к предыдущему 
году&]
[s7; DUMP(year);&]
[s0; &]
[s17; GetWeekDate(2015, 1) `= 12/29/2014&]
[s17; GetWeek(Date(2016, 1, 1), year) `= 53&]
[s17; year `= 2015&]
[s0; &]
[s0; &]
[s7; DUMP(EasterDay(2015));&]
[s7; DUMP(EasterDay(2016));&]
[s0; &]
[s17; EasterDay(2015) `= 04/05/2015&]
[s17; EasterDay(2016) `= 03/27/2016&]
[s0; &]
[s5; U`+`+ определяет начало и конец эры, 
большинство алгоритмов безопасны 
и `"понимают`", какие минимальные и 
максимальные значения могут быть 
у [*C@5 Date]:&]
[s0; &]
[s7; DUMP(Date`::Low());&]
[s7; DUMP(Date`::High());&]
[s0; &]
[s17; Date`::Low() `= 01/01/`-4000&]
[s17; Date`::High() `= 01/01/4000&]
[s0; &]
[s5; Time `- производное от [*C@5 Date], с добавлением 
членов для представления времени:&]
[s0; &]
[s7; Time time `= GetSysTime();&]
[s7; DUMP(time);&]
[s7; DUMP((Date)time);&]
[s7; DUMP((int)time.hour);&]
[s7; DUMP((int)time.minute);&]
[s7; DUMP((int)time.second);&]
[s0; &]
[s17; time `= 07/21/2021 15:01:38&]
[s17; (Date)time `= 07/21/2021&]
[s17; (int)time.hour `= 15&]
[s17; (int)time.minute `= 1&]
[s17; (int)time.second `= 38&]
[s0; &]
[s5; `"Времена`" можно сравнивать:&]
[s0; &]
[s7; DUMP(time > Time(1970, 0, 0));&]
[s0; &]
[s17; time > Time(1970, 0, 0) `= true&]
[s0; &]
[s5; Предупреждение: Поскольку [*C@5 Time] `- 
производное от [*C@5 Date], большинство 
операций автоматически преобразует 
[*C@5 Time] обратно в [*C@5 Date]. Нужно использовать 
функцию преобразования [*C@5 ToTime], чтобы 
преобразовать [*C@5 Date] в [*C@5 Time]:&]
[s0; &]
[s7; DUMP(time > date); // time преобразуется в Date...&]
[s7; DUMP(time > ToTime(date));&]
[s0; &]
[s17; time > date `= false&]
[s17; time > ToTime(date) `= true&]
[s0; &]
[s5; Подобно [*C@5 Date], [*C@5 Time] поддерживает 
операции прибавления и вычитания, 
но числа представляют секунды (используется
 тип данных [*C@5 int64]):&]
[s0; &]
[s7; DUMP(time `+ 1);&]
[s7; DUMP(time `+ 24 `* 3600);&]
[s7; DUMP(time `- date); // time преобразуется в Date, 
sрезультат в днях&]
[s7; DUMP(time `- ToTime(date)); // Time `- Time в секундах&]
[s0; &]
[s17; time `+ 1 `= 07/21/2021 15:01:39&]
[s17; time `+ 24 `* 3600 `= 07/22/2021 15:01:38&]
[s17; time `- date `= 0&]
[s17; time `- ToTime(date) `= 54098&]
[s0; &]
[s5; [*C@5 Time] тоже определяет пределы эры:&]
[s0; &]
[s7; DUMP(Time`::Low());&]
[s7; DUMP(Time`::High());&]
[s0; &]
[s17; Time`::Low() `= 01/01/`-4000 00:00:00&]
[s17; Time`::High() `= 01/01/4000 00:00:00&]
[s0; &]
[s3;H4;:Section`_1`_6: 1.6 [C@5 AsString], [C@5 ToString] и [C@5 operator<<]&]
[s5; U`+`+ Core предоставляет простую, но действенную
, стандартную схему для преобразования 
значений в дефолтную текстовую форму. 
Система основана на комбинации шаблонных 
функций (следующий код является частью 
библиотеки U`+`+):&]
[s0; &]
[s7; namespace Upp `{&]
[s7; -|template <class T>&]
[s7; -|inline String AsString(const T`& x)&]
[s7; -|`{&]
[s7; -|-|return x.ToString();&]
[s7; -|`}&]
[s7; -|&]
[s7; -|template <class T>&]
[s7; -|inline Stream`& operator<<(Stream`& s, const T`& x)&]
[s7; -|`{&]
[s7; -|-|s << AsString(x);&]
[s7; -|-|return s;&]
[s7; -|`}&]
[s7; -|&]
[s7; -|template <class T>&]
[s7; -|inline String`& operator<<(String`& s, const T`& x)&]
[s7; -|`{&]
[s7; -|-|s.Cat(AsString(x));&]
[s7; -|-|return s;&]
[s7; -|`}&]
[s7; `};&]
[s0; &]
[s5; Клиентские типы должны либо определить 
метод [*C@5 String ToString] , либо создать специальный 
шаблон [*C@5 AsString]  в пространстве имён 
[*C@5 Upp]. Такие типы могут приставляться 
к Потокам или Строкам с помощью [*C@5 operator<<]. 
Конечно, типы значений U`+`+ и примитивные 
типы имеют предопределённые элементы 
в U`+`+:&]
[s0; &]
[s7; FileOut fout(ConfigFile(`"test.txt`"));&]
[s7; String  sout;&]
[s7; &]
[s7; fout << 1.23 << `' `' << GetSysDate() << `' `' << GetSysTime();&]
[s7; sout << 1.23 << `' `' << GetSysDate() << `' `' << GetSysTime();&]
[s7; &]
[s7; fout.Close();&]
[s7; &]
[s7; DUMP(LoadFile(ConfigFile(`"test.txt`")));&]
[s7; DUMP(sout);&]
[s0; &]
[s17; LoadFile(ConfigFile(`"test.txt`")) `= 1.23 07/21/2021 07/21/2021 
15:01:38&]
[s17; sout `= 1.23 07/21/2021 07/21/2021 15:01:38&]
[s0; &]
[s5; Включить в эту схему клиентские типы 
не так уж сложно, нужно только добавить 
метод [*C@5 ToString]:&]
[s0; &]
[s7; struct BinFoo `{&]
[s7; -|int x;&]
[s7; -|&]
[s7; -|String ToString() const   `{ return FormatIntBase(x, 2); `}&]
[s7; `};&]
[s7; &]
[s7; BinFoo bf;&]
[s7; bf.x `= 30;&]
[s7; &]
[s7; sout.Clear();&]
[s7; sout << bf;&]
[s7; DUMP(sout);&]
[s0; &]
[s17; sout `= 11110&]
[s0; &]
[s5; Если добавить [*C@5 ToString ]не получается, 
можно специализировать для этого 
шаблон в пространстве имён Upp:&]
[s0; &]
[s7; struct RomanFoo `{&]
[s7; -|int x;&]
[s7; -|&]
[s7; -|RomanFoo(int x) : x(x) `{`}&]
[s7; `};&]
[s7; &]
[s7; namespace Upp `{&]
[s7; template <> String Upp`::AsString(const RomanFoo`& a) `{ return 
FormatIntRoman(a.x); `}&]
[s7; `};&]
[s0; &]
[s3;H4;:Section`_1`_7: [@(128.0.255) 1.7 CombineHash]&]
[s5; Чтобы упростить предоставление высококачес
твенных хэш`-кодов для составных типов, 
U`+`+ предлагает вспомогательный класс 
[*C@5 CombineHash]. Этот класс использует функцию 
[*C@5 GetHashValue] для сбора хэш`-кодов всех 
значений и комбинирования их, чтобы 
дать итоговое хэш`-значение составному 
типу:&]
[s0; &]
[s7; struct Foo `{&]
[s7; -|String a;&]
[s7; -|int    b;&]
[s7; -|&]
[s7; -|unsigned GetHashValue() const `{ return CombineHash(a, b); 
`}&]
[s7; `};&]
[s0; &]
[s5; Заметьте, что [*C@5 GetHashValue] определён 
как шаблон функции, вызывающий метод 
[*C@5 GetHashValue] своего аргумента, следовательно, 
определение метода [*C@5 GetHashValue] определяет 
также и функцию [*C@5 GetHashValue]:&]
[s0; &]
[s7; Foo x;&]
[s7; x.a `= `"world`";&]
[s7; x.b `= 22;&]
[s7; &]
[s7; DUMP(GetHashValue(x));&]
[s0; &]
[s17; GetHashValue(x) `= 3180644175&]
[s0; &]
[s0; &]
[s7; x.a << `'!`';&]
[s7; &]
[s7; DUMP(GetHashValue(x));&]
[s0; &]
[s17; GetHashValue(x) `= 1959050319&]
[s0; &]
[s3;H4;:Section`_1`_8: [@(128.0.255) 1.8 SgnCompare и CombineCompare]&]
[s5; Традиционным подходом языка Си к 
представлению результатов сравнения 
был из трёх состояний: сравнение a 
и b даёт отрицательное значение (if 
a < b), ноль (if a `=`= b) или положительное 
значение (a > b). В стандартной библиотеке 
C`+`+ сравнения обычно представляются 
с предикатом [*C@5 bool].&]
[s5; Однако, с предикатом [*C@5 bool] становится 
несколько труднее проводить сравнение 
составных типов:&]
[s0; &]
[s7; struct Foo `{&]
[s7; -|String a;&]
[s7; -|int    b;&]
[s7; -|int    c;&]
[s7; -|&]
[s7; -|// we want to order Foo instances by a first, then b, then 
c&]
[s7; -|&]
[s7; -|bool operator<(const Foo`& x) const `{&]
[s7; -|-|return a < x.a ? true&]
[s7; -|-|               : a `=`= x.a ? b < x.b ? true&]
[s7; -|-|                          : b `=`= x.b ? false&]
[s7; -|-|                                     : c < x.c&]
[s7; -|-|               : false;&]
[s7; -|`}&]
[s7; `};&]
[s0; &]
[s5; U`+`+ предоставляет стандартную функцию 
[*C@5 SgnCompare], возвращающую отрицательное 
значение/ноль/позитив в стиле `"C style`":&]
[s0; &]
[s7; int a `= 1;&]
[s7; int b `= 2;&]
[s7; &]
[s7; DUMP(SgnCompare(a, b));&]
[s7; DUMP(SgnCompare(b, a));&]
[s7; DUMP(SgnCompare(a, a));&]
[s0; &]
[s17; SgnCompare(a, b) `= `-1&]
[s17; SgnCompare(b, a) `= 1&]
[s17; SgnCompare(a, a) `= 0&]
[s0; &]
[s5; Дефолтная реализация [*C@5 SgnCompare] вызывает 
метод значения [*C@5 Compare]:&]
[s0; &]
[s7; struct MyClass `{&]
[s7; -|int val;&]
[s7; -|&]
[s7; -|int Compare(const MyClass`& x) const `{ return SgnCompare(val, 
x.val); `}&]
[s7; `};&]
[s0; &]
[s5; [*C@5 SgnCompare] теперь определён для [*C@5 MyClass]:&]
[s0; &]
[s7; MyClass u, v;&]
[s7; u.val `= 1;&]
[s7; v.val `= 2;&]
[s7; &]
[s7; DUMP(SgnCompare(u, v));&]
[s7; DUMP(SgnCompare(v, u));&]
[s7; DUMP(SgnCompare(v, v));&]
[s0; &]
[s17; SgnCompare(u, v) `= `-1&]
[s17; SgnCompare(v, u) `= 1&]
[s17; SgnCompare(v, v) `= 0&]
[s0; &]
[s5; Теперь вернуться к [*C@5 Foo], с [*C@5 SgnCompare] 
[*C@5 operator<] становится не так уж трудно:&]
[s0; &]
[s7; struct Foo2 `{&]
[s7; -|String a;&]
[s7; -|int    b;&]
[s7; -|int    c;&]
[s7; -|&]
[s7; -|bool operator<(const Foo2`& x) const `{&]
[s7; -|-|int q `= SgnCompare(a, x.a);&]
[s7; -|-|if(q) return q < 0;&]
[s7; -|-|q `= SgnCompare(b, x.b);&]
[s7; -|-|if(q) return q < 0;&]
[s7; -|-|q `= SgnCompare(c, x.c);&]
[s7; -|-|return q < 0;&]
[s7; -|`}&]
[s7; `};&]
[s0; &]
[s5; Альтернативно, можно определить 
только метод [*C@5 Compare] и использовать 
[*C@5 Comparable] [^https`:`/`/en`.wikipedia`.org`/wiki`/Curiously`_recurring`_template`_pattern^ C
RTP идиому] , чтобы определить все реляционные
 операторы:&]
[s0; &]
[s7; struct Foo3 : Comparable<Foo3> `{&]
[s7; -|String a;&]
[s7; -|int    b;&]
[s7; -|int    c;&]
[s7; -|&]
[s7; -|int Compare(const Foo3`& x) const `{&]
[s7; -|-|int q `= SgnCompare(a, x.a);&]
[s7; -|-|if(q) return q;&]
[s7; -|-|q `= SgnCompare(b, x.b);&]
[s7; -|-|if(q) return q;&]
[s7; -|-|return SgnCompare(c, x.c);&]
[s7; -|`}&]
[s7; `};&]
[s7; &]
[s7; Foo3 m, n;&]
[s7; m.a `= `"A`";&]
[s7; m.b `= 1;&]
[s7; m.c `= 2;&]
[s7; n.a `= `"A`";&]
[s7; n.b `= 1;&]
[s7; n.c `= 3;&]
[s7; &]
[s7; DUMP(m < n);&]
[s7; DUMP(m `=`= n);&]
[s7; DUMP(m !`= n);&]
[s7; DUMP(SgnCompare(m, n));&]
[s0; &]
[s17; m < n `= true&]
[s17; m `=`= n `= false&]
[s17; m !`= n `= true&]
[s17; SgnCompare(m, n) `= `-1&]
[s0; &]
[s5; Хотя содержание метода [*C@5 Compare]  и 
так достаточно тривиально, его можно 
ещё более упростить, используя вспомогатель
ный класс [*C@5 CombineCompare]:&]
[s0; &]
[s7; struct Foo4 : Comparable<Foo4> `{&]
[s7; -|String a;&]
[s7; -|int    b;&]
[s7; -|int    c;&]
[s7; -|&]
[s7; -|int Compare(const Foo4`& x) const `{&]
[s7; -|-|return CombineCompare(a, x.a)(b, x.b)(c, x.c);&]
[s7; -|`}&]
[s7; `};&]
[s7; &]
[s7; Foo4 o, p;&]
[s7; o.a `= `"A`";&]
[s7; o.b `= 1;&]
[s7; o.c `= 2;&]
[s7; p.a `= `"A`";&]
[s7; p.b `= 1;&]
[s7; p.c `= 3;&]
[s7; &]
[s7; DUMP(o < p);&]
[s7; DUMP(o `=`= p);&]
[s7; DUMP(o !`= p);&]
[s7; DUMP(SgnCompare(o, p));&]
[s0; &]
[s17; o < p `= true&]
[s17; o `=`= p `= false&]
[s17; o !`= p `= true&]
[s17; SgnCompare(o, p) `= `-1&]
[s0; &]
[s22;:Chapter`_2: [@3 2. Потоки]&]
[s3;:Section`_2`_1: [@(128.0.255) 2.1 Основы Потоков]&]
[s5; Потоком U`+`+, работающим с файлами, 
является [*C@5 FileStream]. У него 3 производных 
класса `- [*C@5 FileIn], [*C@5 FileOut] и [*C@5 FileAppend], 
для самых общих применений.&]
[s0; &]
[s7; FileIn in(GetDataFile(`"test.txt`"));&]
[s7; if(!in) `{&]
[s7; -|LOG(`"Не удалось открыть файл`");&]
[s7; -|return;&]
[s7; `}&]
[s0; &]
[s5; Самыми основными операциями потоков 
являются [*C@5 Put] и [*C@5 Get]. [*C@5 Get] работает 
точно так же, как и старый добрый getc 
из языка Си `- он возвращает отрицательное 
число при eof или ошибке:&]
[s0; &]
[s7; String h;&]
[s7; int c;&]
[s7; while((c `= in.Get()) >`= 0)&]
[s7; -|h.Cat(c);&]
[s7; DUMP(h);&]
[s0; &]
[s17; h `= Lorem ipsum dolor sit amet, consectetur adipiscing elit,&]
[s17; sed do eiusmod tempor incididunt ut labore et dolore magna&]
[s17; aliqua. Ut enim ad minim veniam, quis nostrud exercitation&]
[s17; ullamco laboris nisi ut aliquip ex ea commodo consequat.&]
[s17; Duis aute irure dolor in reprehenderit in voluptate velit&]
[s17; esse cillum dolore eu fugiat nulla pariatur. Excepteur&]
[s17; sint occaecat cupidatat non proident, sunt in culpa qui&]
[s17; officia deserunt mollit anim id est laborum.&]
[s0; &]
[s5; Потоки U`+`+ не предоставляют возможностей 
форматирования (это относится к текстовым 
утилитам), но у них есть некоторые 
уникальные черты. U`+`+ не делает различия 
между режимами потока `'text`' и `'binary`'; 
методы отлично приспособлены работать 
с обеими, в общем режиме.&]
[s5; [*C@5 GetLine] возвращает [*C@5 String] одной считанной 
строки (разделители строк `'`\n`', `'`\r`' 
игнорируются):&]
[s0; &]
[s7; in.Seek(0);&]
[s7; while(!in.IsEof())&]
[s7; -|DUMP(in.GetLine());&]
[s0; &]
[s17; in.GetLine() `= Lorem ipsum dolor sit amet, consectetur adipiscing 
elit,&]
[s17; in.GetLine() `= sed do eiusmod tempor incididunt ut labore et 
dolore magna&]
[s17; in.GetLine() `= aliqua. Ut enim ad minim veniam, quis nostrud 
exercitation&]
[s17; in.GetLine() `= ullamco laboris nisi ut aliquip ex ea commodo 
consequat.&]
[s17; in.GetLine() `= Duis aute irure dolor in reprehenderit in voluptate 
velit&]
[s17; in.GetLine() `= esse cillum dolore eu fugiat nulla pariatur. 
Excepteur&]
[s17; in.GetLine() `= sint occaecat cupidatat non proident, sunt in 
culpa qui&]
[s17; in.GetLine() `= officia deserunt mollit anim id est laborum.&]
[s0; &]
[s5; [*C@5 Peek] можно использовать для того, 
чтобы заглянуть в следующий символ, 
не переходя к нему:&]
[s0; &]
[s7; in.Seek(0);&]
[s7; DDUMP((char)in.Peek());&]
[s7; DDUMP(in.GetLine());&]
[s0; &]
[s17; (char)in.Peek() `= L&]
[s17; in.GetLine() `= Lorem ipsum dolor sit amet, consectetur adipiscing 
elit,&]
[s0; &]
[s5; [*C@5 Get] `- метод, который считывает из 
потока указанное число байтов и возвращает 
их как [*C@5 String]:&]
[s0; &]
[s7; in.Seek(0);&]
[s7; DUMP(in.Get(10));&]
[s0; &]
[s17; in.Get(10) `= Lorem ipsu&]
[s0; &]
[s5; Если в Stream`'е меньше символов, чем 
требуется для Get`'а, то возвращается 
всё, что есть, до EOF`'а (конца файла):&]
[s0; &]
[s7; in.Seek(0);&]
[s7; DUMP(in.Get(999999).GetCount());&]
[s0; &]
[s17; in.Get(999999).GetCount() `= 452&]
[s0; &]
[s5; В отличие он него, метод [*C@5 GetAll] испытывает 
провал, когда в Stream`'е не хватает символов. 
И возвращает Void [*C@5 String], если Stream не 
находится в режиме [*C@5 LoadThrowing]:&]
[s0; &]
[s7; in.Seek(0);&]
[s7; h `= in.GetAll(100);&]
[s7; DUMP(h.GetCount());&]
[s0; &]
[s17; h.GetCount() `= 100&]
[s0; &]
[s0; &]
[s7; h `= in.GetAll(999999);&]
[s7; DUMP(h.IsVoid());&]
[s0; &]
[s17; h.IsVoid() `= true&]
[s0; &]
[s5; В режиме [*C@5 LoadThrowing], [*C@5 Stream] выбрасывает 
исключение [*C@5 LoadingError], если у него 
появляется проблема с вводным [*C@5 Stream`'ом]:&]
[s0; &]
[s7; in.LoadThrowing();&]
[s7; try `{&]
[s7; -|in.GetAll(999999);&]
[s7; `}&]
[s7; catch(LoadingError) `{&]
[s7; -|LOG(`"Ошибка загрузки`");&]
[s7; `}&]
[s0; &]
[s17; Loading error&]
[s0; &]
[s5; Шаблонный вариант [*C@5 Stream`::operator<<] использует 
[*C@5 AsString] для преобразования данных 
в текст:&]
[s0; &]
[s7; String fn `= GetHomeDirFile(`"test.txt`");&]
[s7; FileOut out(fn);&]
[s7; if(!out) `{&]
[s7; -|LOG(`"Не удалось открыть файл`");&]
[s7; -|return;&]
[s7; `}&]
[s7; out << `"Some number `" << 321 << `" and Point `" << Point(1, 
2);&]
[s7; out.Close();&]
[s0; &]
[s5; При записи в [*C@5 Stream], хороший способ 
проверки на ошибки `- запись всех данных, 
закрытие потока и затем проверка 
на [*C@5 IsError]:&]
[s0; &]
[s7; if(out.IsError()) `{ // проверка правильности 
записи файла&]
[s7; -|LOG(`"Ошибка`");&]
[s7; -|return;&]
[s7; `}&]
[s7; DUMP(LoadFile(fn));&]
[s0; &]
[s17; LoadFile(fn) `= Some number 321 and Point `[1, 2`]&]
[s0; &]
[s5; [*C@5 FileAppend] можно использовать для приставлени
я (`"постановки в хвост`") данных к файлу:&]
[s0; &]
[s7; FileAppend out2(fn);&]
[s7; out2 << `"`\nSomething more`";&]
[s7; out2.Close();&]
[s7; DUMP(LoadFile(fn));&]
[s0; &]
[s17; LoadFile(fn) `= Some number 321 and Point `[1, 2`]&]
[s17; Something more&]
[s0; &]
[s5; Важным и часто используемым типом 
[*C@5 Stream`'а] является [*C@5 StringStream], который 
работает со [*C@5 String`'ом] как с вводом/выводом.&]
[s5; [*C@5 Stream] также предосталяет методы 
для сохранения/загрузки примитивных 
типов, как в режиме little`-endian, так и 
в big`-endian:&]
[s0; &]
[s7; StringStream ss;&]
[s7; ss.Put32le(0x12345678);&]
[s7; ss.Put32be(0x12345678);&]
[s7; DUMPHEX(ss.GetResult());&]
[s0; &]
[s17; ss.GetResult() `= Memory at 0x0208fa48, size 0x8 `= 8&]
[s17;     `+0 0x0208FA48 78 56 34 12 12 34 56 78                  
           xV4..4Vx        &]
[s0; &]
[s0; &]
[s7; StringStream ss2(ss.GetResult());&]
[s7; DUMPHEX(ss2.Get32le());&]
[s7; DUMPHEX(ss2.Get32be());&]
[s0; &]
[s17; ss2.Get32le() `= 0x12345678&]
[s17; ss2.Get32be() `= 0x12345678&]
[s0; &]
[s3;H4;:Section`_2`_2: [@(128.0.255) 2.2 Особые потоки]&]
[s5; [*C@5 SizeStream] считает число байтов, записанных 
в поток:&]
[s0; &]
[s7; SizeStream szs;&]
[s7; szs << `"1234567`";&]
[s7; DUMP(szs.GetSize());&]
[s0; &]
[s17; szs.GetSize() `= 7&]
[s0; &]
[s5; [*C@5 CompareStream] можно использовать для 
сравнения содержимого некоторого 
потока с данными, записанными в  [*C@5 CompareStream]:&]
[s0; &]
[s7; StringStream in(`"123456`");&]
[s7; CompareStream cs(in);&]
[s7; cs.Put(`"12345`");&]
[s7; DUMP(cs.IsEqual());&]
[s0; &]
[s17; cs.IsEqual() `= true&]
[s0; &]
[s0; &]
[s7; cs.Put(`"7`");&]
[s7; DUMP(cs.IsEqual());&]
[s0; &]
[s17; cs.IsEqual() `= false&]
[s0; &]
[s5; [*C@5 OutStream] буферирует выводные данные 
в большие блоки, затем выводит их 
виртуальным методом [*C@5 Out]:&]
[s0; &]
[s7; struct MyOutStream : OutStream `{&]
[s7; -|virtual  void  Out(const void `*data, dword size) `{&]
[s7; -|-|DUMPHEX(String((const char `*)data, size));&]
[s7; -|`}&]
[s7; `};&]
[s7; &]
[s7; MyOutStream os;&]
[s7; os << `"This is a test `" << 12345;&]
[s7; os.Close();&]
[s0; &]
[s17; String((const char `*)data, size) `= Memory at 0x07604a10, size 
0x14 `= 20&]
[s17;     `+0 0x07604A10 54 68 69 73 20 69 73 20 61 20 74 65 73 74 
20 31     This is a test 1&]
[s17;    `+16 0x07604A20 32 33 34 35                              
           2345            &]
[s0; &]
[s5; [*C@5 TeeStream] отсылает выводные данные 
в два разных потока:&]
[s0; &]
[s7; StringStream ss1;&]
[s7; StringStream ss2;&]
[s7; TeeStream tee(ss1, ss2);&]
[s7; tee << `"Tee stream test`";&]
[s7; tee.Close();&]
[s7; DUMP(ss1.GetResult());&]
[s7; DUMP(ss2.GetResult());&]
[s0; &]
[s17; ss1.GetResult() `= Tee stream test&]
[s17; ss2.GetResult() `= Tee stream test&]
[s0; &]
[s5; [*C@5 MemReadStream] можно использовать для 
преобразования блока памяти read`-only 
в данные потока:&]
[s0; &]
[s7; static const char s`[`] `= `"Some line`\nAnother line`";&]
[s7; MemReadStream ms(s, sizeof(s) `- 1);&]
[s7; while(!ms.IsEof())&]
[s7; -|DUMPHEX(ms.GetLine());&]
[s0; &]
[s17; ms.GetLine() `= Memory at 0x0208f6f8, size 0x9 `= 9&]
[s17;     `+0 0x0208F6F8 53 6F 6D 65 20 6C 69 6E 65               
           Some line       &]
[s17; ms.GetLine() `= Memory at 0x0208f6f8, size 0xC `= 12&]
[s17;     `+0 0x0208F6F8 41 6E 6F 74 68 65 72 20 6C 69 6E 65      
           Another line    &]
[s0; &]
[s3;H4;:Section`_2`_3: [@(128.0.255) 2.3 Двоичная сериализация]&]
[s5; Сериализация `- это механизм, преобразующий 
структурированные данные в /из двоичного 
потока. В U`+`+ загрузка и сохранение 
данных выполняется одним и тем же 
кодом, в большинстве случаев представленным
 методом [*C@5 Serialize]. Сериализация выполняется 
напрямую, с базовым [*C@5 Stream`'ом]. На всём 
протяжении у [*C@5 Stream`'а] имеется булев 
член, который представляет направление 
процесса сериализации. Направление 
можно проверить `- с помощью методов 
[*C@5 IsLoading] и [*C@5 IsStoring;] и изменить `- с помощью 
методов [*C@5 SetStoring] и [*C@5 SetLoading]. Обычно 
направление, нужным образом, устанавливаетс
я производными классами (например, 
FileOut устанавливает его в сохранение, 
а FileIn `- в загрузку).&]
[s5; Краткий вызов метода [*C@5 Serialize] выполняет 
[*C@5 operator%], являющийся шаблонной перегрузкой, 
которая вызывает [*C@5 Serialize] для заданной 
переменной (у примитивных типов в 
классе [*C@5 Stream] есть прямая перегрузка):&]
[s0; &]
[s7; StringStream ss;&]
[s7; &]
[s7; int x `= 123;&]
[s7; Color h `= White();&]
[s7; &]
[s7; ss % x % h;&]
[s7; &]
[s7; StringStream ss2(ss.GetResult());&]
[s7; &]
[s7; int x2;&]
[s7; Color h2;&]
[s7; &]
[s7; ss2 % x2 % h2;&]
[s7; &]
[s7; DUMP(x2);&]
[s7; DUMP(h2);&]
[s0; &]
[s17; x2 `= 123&]
[s17; h2 `= Color(255, 255, 255)&]
[s0; &]
[s5; Когда при сериализации не удаётся 
загрузить данные (например, из`-за 
ошибочной структуры или недостатка 
данных в потоке), вызывается [*C@5 Stream`::LoadError], 
которая может триггировать исключение, 
если поток [*C@5 LoadThrowing]:&]
[s0; &]
[s7; ss2.Seek(0);&]
[s7; ss2.LoadThrowing();&]
[s7; try `{&]
[s7; -|ss2 % x2 % h2 % x2;&]
[s7; `}&]
[s7; catch(LoadingError) `{&]
[s7; -|LOG(`"Десериализация не удалась`");&]
[s7; `}&]
[s0; &]
[s17; Десериализация не удалась&]
[s0; &]
[s5; Сериализация, главным образом, может 
быть продемонстрирована на конкретных 
примерах. На практике обычно реализация 
представлена методом [*C@5 Serialize] класса, 
совместимого с этим понятием. Неплохо 
предоставлять средства для последующего 
расширения подобного класса:&]
[s0; &]
[s7; struct MyFoo `{&]
[s7; -|int    number;&]
[s7; -|Color  color;&]
[s7; -|&]
[s7; -|void Serialize(Stream`& s) `{&]
[s7; -|-|int version `= 0;&]
[s7; -|-|s / version; // позволяет в будущем достичь 
обратной совместимости&]
[s7; -|-|s.Magic(31415); // помещает магическое число 
в поток для проверки&]
[s7;                               // некорректных данных&]
[s7; -|-|s % number % color;&]
[s7; -|`}&]
[s7; `};&]
[s7; &]
[s7; MyFoo foo;&]
[s7; foo.number `= 321;&]
[s7; foo.color `= Blue();&]
[s0; &]
[s5; [*C@5 StoreAsFile], [*C@5 StoreAsString], [*C@5 LoadFromFile] и [*C@5 LoadFromString] 
`- эти функции удобны тем, что упрощают 
сохранение/загрузку объектов в/из 
наиболее распространённых форм сохранения:&]
[s0; &]
[s7; String data `= StoreAsString(foo);&]
[s7; MyFoo foo2;&]
[s7; LoadFromString(foo2, data);&]
[s7; DUMP(foo2.number);&]
[s7; DUMP(foo2.color);&]
[s0; &]
[s17; foo2.number `= 321&]
[s17; foo2.color `= Color(0, 0, 128)&]
[s0; &]
[s5; Теперь, если [*C@5 MyFoo] нужно расширить 
до [*C@5 MyFoo2], и требуется поддержать 
способность загружать из двоичных 
данных, сохранённых посредством исходного 
[*C@5 MyFoo], можно ответвиться от ранее 
сохранённой версии ([*C@5 version)]:&]
[s0; &]
[s7; struct MyFoo2 `{&]
[s7; -|int    number;&]
[s7; -|Color  color;&]
[s7; -|String text;&]
[s7; -|&]
[s7; -|void Serialize(Stream`& s) `{&]
[s7; -|-|int version `= 1;&]
[s7; -|-|s / version;&]
[s7; -|-|s % number % color;&]
[s7; -|-|if(version >`= 1)&]
[s7; -|-|-|s % text;&]
[s7; -|`}&]
[s7; `};&]
[s7; MyFoo2 foo3;&]
[s7; LoadFromString(foo3, data);&]
[s7; DUMP(foo3.number);&]
[s7; DUMP(foo3.color);&]
[s0; &]
[s17; foo3.number `= 0&]
[s17; foo3.color `= Color(Null)&]
[s0; &]
[s5; Примечание: [*C@5 operator/] `- это метод Stream 
с несколькими пергрузками, оптимизированный
 для небольшого значения `- в этом 
случае [*C@5 int] сохраняется как единичный 
байт по возможности (и как 5 байтов, 
при её отсутствии).&]
[s22;:Chapter`_3: [@3 3. Контейнеры`-массивы]&]
[s3;:Section`_3`_1: [@(128.0.255) 3.1 Основы] [C@5 Vector`'а]&]
[s5; [*C@5 Vector] `- это базовый контейнер U`+`+. 
Это контейнер случайного доступа, 
подобный [*C@5 std`::vector], с одним отличием, 
относящимся к производительности 
(performance): Правила для элементов [*C@5 Vector`'а] 
позволяют в его реализации перемещать 
элементы в памяти, использую простые 
[*C@5 memcpy]/``memmove`` (понятие `"Moveable`").&]
[s5; В любом случае, начнём с простого 
[*C@5 Vector`'а из] [*C@5 int`'ов]:&]
[s0; &]
[s7; -|Vector<int> v;&]
[s0; &]
[s5; Добавить элементы в этот Vector можно 
в виде параметров к методу Add:&]
[s0; &]
[s7; -|v.Add(1);&]
[s7; -|v.Add(2);&]
[s7; -|&]
[s7; -|DUMP(v);&]
[s0; &]
[s17; v `= `[1, 2`]&]
[s0; &]
[s5; Альтернативная и очень важная возможность 
для контейнеров U`+`+ `- `'in`-place creation`' 
(`"создание на месте`"). При этом беспараметрны
й Add возвращает ссылку на новый элемент 
в [*C@5 Vector`'е]:&]
[s0; &]
[s7; -|v.Add() `= 3;&]
[s7; -|&]
[s7; -|DUMP(v);&]
[s0; &]
[s17; v `= `[1, 2, 3`]&]
[s0; &]
[s5; Можно также использовать [*C@5 operator<<]&]
[s0; &]
[s7; -|v << 4 << 5;&]
[s7; &]
[s7; -|DUMP(v);&]
[s0; &]
[s17; v `= `[1, 2, 3, 4, 5`]&]
[s0; &]
[s5; [*C@5 Vector] к тому же поддерживает списки 
инициализаторов:&]
[s0; &]
[s7; -|v.Append(`{ 6, 7 `});&]
[s7; &]
[s7; -|DUMP(v);&]
[s0; &]
[s17; v `= `[1, 2, 3, 4, 5, 6, 7`]&]
[s0; &]
[s5; Для итерации (обхода) по [*C@5 Vector`'у] 
используются индексы:&]
[s0; &]
[s7; -|for(int i `= 0; i < v.GetCount(); i`+`+)&]
[s7; -|-|LOG(v`[i`]);&]
[s0; &]
[s17; 1&]
[s17; 2&]
[s17; 3&]
[s17; 4&]
[s17; 5&]
[s17; 6&]
[s17; 7&]
[s0; &]
[s5; интерфейс begin/end:&]
[s0; &]
[s7; -|for(auto q `= v.begin(), e `= v.end(); q !`= e; q`+`+)&]
[s7; -|-|LOG(`*q);&]
[s0; &]
[s17; 1&]
[s17; 2&]
[s17; 3&]
[s17; 4&]
[s17; 5&]
[s17; 6&]
[s17; 7&]
[s0; &]
[s5; синтаксис C`+`+11 range`-for:&]
[s0; &]
[s7; -|for(const auto`& q : v)&]
[s7; -|-|LOG(q);&]
[s0; &]
[s17; 1&]
[s17; 2&]
[s17; 3&]
[s17; 4&]
[s17; 5&]
[s17; 6&]
[s17; 7&]
[s0; &]
[s3;H4;:Section`_3`_2: [@(128.0.255) 3.2 Операции с] [C@5 Vector`'ом]&]
[s5; Вставка и удаление элеметов (методами 
[*C@5 Insert] или [*C@5 Remove)] в случайные позиции 
вектора Vector (сложность O(n)):&]
[s0; &]
[s7; Vector<int> v;&]
[s7; v.Add(1);&]
[s7; v.Add(2);&]
[s7; &]
[s7; v.Insert(1, 10);&]
[s7; &]
[s7; DUMP(v);&]
[s0; &]
[s17; v `= `[1, 10, 2`]&]
[s0; &]
[s0; &]
[s7; v.Insert(0, `{ 7, 6, 5 `});&]
[s7; &]
[s7; DUMP(v);&]
[s0; &]
[s17; v `= `[7, 6, 5, 1, 10, 2`]&]
[s0; &]
[s0; &]
[s7; v.Remove(0);&]
[s7; &]
[s7; DUMP(v);&]
[s0; &]
[s17; v `= `[6, 5, 1, 10, 2`]&]
[s0; &]
[s5; [*C@5 At] `- метод, возвращающий элементы 
в указанной позиции, проверяющий 
такую позицию на наличие. Если в [*C@5 Vector`'е 
]недостаточно элементов, он добавляет 
их в требуемом количестве. Если у 
[*C@5 At] есть второй параметр, то новые 
добавленные элементы инициализируются 
с этим значением.&]
[s0; &]
[s7; v.Clear();&]
[s7; for(int i `= 0; i < 10000; i`+`+)&]
[s7; -|v.At(Random(10), 0)`+`+;&]
[s7; &]
[s7; DUMP(v);&]
[s0; &]
[s17; v `= `[922, 995, 1050, 1007, 1002, 998, 1020, 1023, 1000, 983`]&]
[s0; &]
[s5; Ссылка на некорректный индекс приводит 
к неопределённой операции. Иногда, 
правда, полезно вернуть значение 
элемента, если индекс некорректен; 
либо какое`-то значение по умолчанию, 
если значение вообще отсутствует. 
Этого можно достичь двухпараметрным 
методом Get:&]
[s0; &]
[s7; DUMP(v.Get(4, 0));&]
[s7; DUMP(v.Get(`-10, 0));&]
[s7; DUMP(v.Get(13, `-1));&]
[s0; &]
[s17; v.Get(4, 0) `= 1002&]
[s17; v.Get(`-10, 0) `= 0&]
[s17; v.Get(13, `-1) `= `-1&]
[s0; &]
[s5; К контейнерам можно применять алгоритмы, 
например, Sort (алгоритм сортировки)&]
[s0; &]
[s7; Sort(v);&]
[s7; &]
[s7; DUMP(v);&]
[s0; &]
[s17; v `= `[922, 983, 995, 998, 1000, 1002, 1007, 1020, 1023, 1050`]&]
[s0; &]
[s3;H4;:Section`_3`_3: [@(128.0.255) 3.3 Проблемы трансфера]&]
[s5; Часто приходится передавать содержимое 
из одного контейнера в другой, такого 
же типа. Контейнеры U`+`+ всегда поддерживают 
[^topic`:`/`/Core`/srcdoc`/pick`_`_ru`-ru^ семантику pick] 
(синоним std`::move), и, в зависимости от 
типа сохранения, также могут поддерживать 
[^topic`:`/`/Core`/srcdoc`/pick`_`_ru`-ru^ семантику clone]. 
При перемещении (трансфере) значения 
нужно явно указать, какую из них использоват
ь:&]
[s0; &]
[s7; Vector<int> v`{ 1, 2 `};&]
[s7; &]
[s7; DUMP(v);&]
[s7; &]
[s7; Vector<int> v1 `= pick(v);&]
[s7; &]
[s7; DUMP(v);&]
[s7; DUMP(v1);&]
[s0; &]
[s17; v `= `[1, 2`]&]
[s17; v `= `[`]&]
[s17; v1 `= `[1, 2`]&]
[s0; &]
[s5; теперь исходный [*C@5 Vector] [*C@5 v] пуст, так 
как элементы `'picked`'(`"сброшены`") в [*C@5 v1].&]
[s5; Если же нужно сохранить значение 
в исходнике (и элементы поддерживают 
операцию глубокого копирования), 
можно использовать [*C@5 clone]:&]
[s0; &]
[s7; v `= clone(v1);&]
[s7; &]
[s7; DUMP(v);&]
[s7; DUMP(v1);&]
[s0; &]
[s17; v `= `[1, 2`]&]
[s17; v1 `= `[1, 2`]&]
[s0; &]
[s5; Требование явного [*C@5 clone] имеет преимущество
 избежания неожидаемых глубоких копий. 
Например:&]
[s0; &]
[s7; Vector<Vector<int>> x;&]
[s7; x.Add() << 1 << 2 << 3;&]
[s7; &]
[s7; for(auto i : x) `{ LOG(i); `}&]
[s0; &]
[s5; приводит к рантаймной ошибке, а эквивалентн
ый код с [*C@5 std`::vector] компилируется, но 
`"втихаря`" выполняет глубокое копирование 
на каждой итерации:&]
[s0; &]
[s7; std`::vector<std`::vector<int>> sv;&]
[s7; sv.push`_back(`{1, 2, 3`});&]
[s7; for(auto i : sv) // вызывает конструктор копии 
std`::vector<int>&]
[s7; -|for(auto j : i)&]
[s7; -|-|DUMP(j);&]
[s0; &]
[s5; Печально, но в некоторых случаях 
проще иметь дефолтную копию, вместо 
явного [*C@5 clone]. Этого можно легко добиться, 
применив шаблон [*C@5 WithDeepCopy]:&]
[s0; &]
[s7; WithDeepCopy<Vector<int>> v2;&]
[s7; &]
[s7; v2 `= v;&]
[s7; &]
[s7; DUMP(v);&]
[s7; DUMP(v2);&]
[s0; &]
[s17; v `= `[1, 2`]&]
[s17; v2 `= `[1, 2`]&]
[s0; &]
[s3;H4;:Section`_3`_4: [@(128.0.255) 3.4 Клентские типы 
в контейнерах U`+`+]&]
[s5; До сих пор в качестве типа элементов 
нами использовался int. В целях сохранения 
клиентских типов в [*C@5 Vector] (и Vector [^topic`:`/`/Core`/src`/Vector`_ru`-ru^ f
lavor]) тип должен удовлетворять требованию 
[^topic`:`/`/Core`/srcdoc`/Moveable`_ru`-ru^ moveable] `- короче, 
он не должен содержать ни обратных 
указателей, ни виртуальных методов. 
Тип должен быть отмечен как [/ moveable 
]с тем, чтобы определить интерфейс`-контракт,
 используя [*C@5 Moveable] [^https`:`/`/en`.wikipedia`.org`/wiki`/Curiously`_recurring`_template`_pattern^ C
RTP идиому]:&]
[s0; &]
[s7; struct Distribution : Moveable<Distribution> `{&]
[s7; -|String      text;&]
[s7; -|Vector<int> data;&]
[s7; -|&]
[s7; -|String ToString() const `{ return text `+ `": `" `+ AsString(data); 
`}&]
[s7; `};&]
[s0; &]
[s5; Теперь, чтобы добавить элементы [*C@5 Distribution], 
нельзя использовать [*C@5 Vector`::Add(const T`&)], 
так как ему требуются элементы с дефолтным 
конструктором глубокой копии `- а 
у [*C@5 Distribution ]он отсутствует, так как[*C@5  
]Vector<int>`` имеет дефолтный pick`-конструктор, 
как и сама Distribution имеет pick`-конструктор. 
В любом случае это плохая идея, так 
как глубокое копирование применяет 
ресурсозатратное копирование внутреннего 
Vector`'а.&]
[s5; В качестве замены нужно использовать 
Add без параметров `- по умолчанию он 
строит (`"сердито и дёшево`" `-that is cheap) 
элемент в Vector`'е и возвращает ссылку 
на него:&]
[s0; &]
[s7; Vector<Distribution> dist;&]
[s7; for(int n `= 5; n <`= 10; n`+`+) `{&]
[s7; -|Distribution`& d `= dist.Add();&]
[s7; -|d.text << `"Test `" << n;&]
[s7; -|for(int i `= 0; i < 10000; i`+`+)&]
[s7; -|-|d.data.At(Random(n), 0)`+`+;&]
[s7; `}&]
[s7; &]
[s7; DUMPC(dist);&]
[s0; &]
[s17; dist:&]
[s17; -|`[0`] `= Test 5: `[2006, 2009, 2025, 1958, 2002`]&]
[s17; -|`[1`] `= Test 6: `[1691, 1660, 1665, 1664, 1633, 1687`]&]
[s17; -|`[2`] `= Test 7: `[1433, 1400, 1413, 1426, 1429, 1476, 1423`]&]
[s17; -|`[3`] `= Test 8: `[1266, 1272, 1139, 1267, 1263, 1233, 1289, 
1271`]&]
[s17; -|`[4`] `= Test 9: `[1076, 1127, 1132, 1129, 1155, 1089, 1045, 
1114, 1133`]&]
[s17; -|`[5`] `= Test 10: `[998, 995, 1012, 973, 1003, 1000, 1009, 1010, 
991, 1009`]&]
[s0; &]
[s5; Другой вариант `- использовать метод 
[*C@5 Vector`::Add(T`&`&)], который использует 
pick`-конструктор вместо конструктора 
deep`-copy. Например, элементы. [*C@5 Distribution] 
могут быть сгенерированы некоей функцией:&]
[s0; &]
[s7; Distribution CreateDist(int n);&]
[s0; &]
[s5; а код для добавления таких элементов 
в Vector, в таком случае, выглядит так:&]
[s0; &]
[s7; for(n `= 5; n <`= 10; n`+`+)&]
[s7; -|dist.Add(CreateDist(n));&]
[s0; &]
[s5; альтернативно, можно также использовать 
default`-constructed вариант&]
[s0; &]
[s7; -|dist.Add() `= CreateDist();&]
[s0; &]
[s3;H4;:Section`_3`_5: [@(128.0.255) 3.5 Array flavor]&]
[s5; Если элементы не [*C@5 Moveable] и, следовательно, 
не могут сохраняться в [*C@5 Vector] flavor, 
их всё же можно сохранить в [*C@5 Array] 
flavor. Другая причина для использования 
Array `- необходимость ссылаться на элементы 
`- Array flavor никогда не инвалидирует 
ссылки или указатели на них. Наконец, 
если sizeof(T) большой (скажем, более 100`-200 
байтов), то использовать Array может 
быть лучше, с точки зрения перформанса.&]
[s5; Примерами элементов, которые нельзя 
сохранить в Vector flavor, являются объекты 
стандартной библиотеки типа [*C@5 std`::string] 
(поскольку очевидно, что стандартная 
библиотека ничего не знает о понятии 
U`+`+ Moveable):&]
[s0; &]
[s7; Array<std`::string> as;&]
[s7; for(int i `= 0; i < 4; i`+`+)&]
[s7; -|as.Add(`"Test`");&]
[s7; &]
[s7; for(auto s : as)&]
[s7; -|DUMP(s.c`_str());&]
[s0; &]
[s17; s.c`_str() `= Test&]
[s17; s.c`_str() `= Test&]
[s17; s.c`_str() `= Test&]
[s17; s.c`_str() `= Test&]
[s0; &]
[s3;H4;:Section`_3`_6: [@(128.0.255) 3.6 Полиморфный] [C@5 Array]&]
[s5; [*C@5 Array] можно использовать даже для 
хранения полиморфных элементов:&]
[s0; &]
[s7; struct Number `{&]
[s7; -|virtual double Get() const `= 0;&]
[s7; -|String ToString() const `{ return AsString(Get()); `}&]
[s7; -|virtual `~Number() `{`}&]
[s7; `};&]
[s7; &]
[s7; struct Integer : public Number `{&]
[s7; -|int n;&]
[s7; -|virtual double Get() const `{ return n; `}&]
[s7; `};&]
[s7; &]
[s7; struct Double : public Number `{&]
[s7; -|double n;&]
[s7; -|virtual double Get() const `{ return n; `}&]
[s7; `};&]
[s0; &]
[s5; Чтобы добавить такие производные 
типы в [*C@5 Array], лучше всего использовать 
in`-place создание методом [*C@5 Create]:&]
[s0; &]
[s7; Array<Number> num;&]
[s7; num.Create<Double>().n `= 15.5;&]
[s7; num.Create<Integer>().n `= 3;&]
[s7; &]
[s7; DUMP(num);&]
[s0; &]
[s17; num `= `[15.5, 3`]&]
[s0; &]
[s5; Альтернативно, можно использовать 
метод [*C@5 Add(T `*)] и предоставить указатель 
на новый созданный экземпляр на куче 
([*C@5 Add] возвращает ссылку на этот экземпляр):&]
[s0; &]
[s7; Double `*nd `= new Double;&]
[s7; nd`->n `= 1.1;&]
[s7; num.Add(nd);&]
[s7; &]
[s7; DUMP(num);&]
[s0; &]
[s17; num `= `[15.5, 3, 1.1`]&]
[s0; &]
[s5; Array овладевает объектом кучи и удаляет 
его, как следует. Рекомендуем использовать 
этот вариант только, если создание 
in`-place методом [*C@5 Create] невозможно.&]
[s5; Всё OK с прямым применением алгоритмов 
U`+`+ к [*C@5 Array`'ю] (самое stringent`'ное требование 
любых базовых алгоритмов `- этот [*C@5 IterSwap], 
который предоставляется итераторам 
контейнеров и который определяется 
для итераторов [*C@5 Array`'я]):&]
[s0; &]
[s7; Sort(num, `[`](const Number`& a, const Number`& b) `{ return 
a.Get() < b.Get(); `});&]
[s7; &]
[s7; DUMP(num);&]
[s0; &]
[s17; num `= `[1.1, 3, 15.5`]&]
[s0; &]
[s3;H4;:Section`_3`_7: [@(128.0.255) 3.7 Двунаправленные 
контейнеры]&]
[s5; Контейнеры[*C@5  Vector] и [*C@5 Array] позволяют 
быстро добавлять и удалять элементы 
в конце последовательности. Иногда 
такое же нужно делать и в начале последовате
льности (обычно для поддержки очередей 
FIFO). [*C@5 BiVector] и [*C@5 BiArray] для этого сценария 
оптимальны:&]
[s0; &]
[s7; BiVector<int> n;&]
[s7; n.AddHead(1);&]
[s7; n.AddTail(2);&]
[s7; n.AddHead(3);&]
[s7; n.AddTail(4);&]
[s7; DUMP(n);&]
[s0; &]
[s17; n `= `[3, 1, 2, 4`]&]
[s0; &]
[s0; &]
[s7; n.DropHead();&]
[s7; DUMP(n);&]
[s0; &]
[s17; n `= `[1, 2, 4`]&]
[s0; &]
[s0; &]
[s7; n.DropTail();&]
[s7; DUMP(n);&]
[s0; &]
[s17; n `= `[1, 2`]&]
[s0; &]
[s0; &]
[s7; struct Val `{&]
[s7; -|virtual String ToString() const `= 0;&]
[s7; -|virtual `~Val() `{`}&]
[s7; `};&]
[s7; &]
[s7; struct Number : Val `{&]
[s7; -|int n;&]
[s7; -|virtual String ToString() const `{ return AsString(n); `}&]
[s7; `};&]
[s7; &]
[s7; struct Text : Val `{&]
[s7; -|String s;&]
[s7; -|virtual String ToString() const `{ return s; `}&]
[s7; `};&]
[s7; &]
[s7; BiArray<Val> num;&]
[s7; num.CreateHead<Number>().n `= 3;&]
[s7; num.CreateTail<Text>().s `= `"Hello`";&]
[s7; num.CreateHead<Text>().s `= `"World`";&]
[s7; num.CreateTail<Number>().n `= 2;&]
[s7; &]
[s7; DUMP(num);&]
[s0; &]
[s17; num `= `[World, 3, Hello, 2`]&]
[s0; &]
[s3;H4;:Section`_3`_8: 3.8 [C@5 Index]&]
[s5; [*C@5 Index] является основой всех ассоциативных 
операций U`+`+ и одна из определяющих 
фишек в U`+`+.&]
[s5; [*C@5 Index] `- это контейнер, весьма подобный 
простому [*C@5 Vector`'у] (это массив элементов 
случайного доступа с быстрым добавлением 
в конец), но с одной дополнительной 
чертой `- он может быстро `"вычислять`" 
позицию элемента с требуемым значением, 
используя метод [*C@5 Find]:&]
[s0; &]
[s7; Index<String> ndx;&]
[s7; ndx.Add(`"alfa`");&]
[s7; ndx.Add(`"beta`");&]
[s7; ndx.Add(`"gamma`");&]
[s7; ndx.Add(`"delta`");&]
[s7; ndx.Add(`"kappa`");&]
[s7; &]
[s7; DUMP(ndx);&]
[s7; DUMP(ndx.Find(`"beta`"));&]
[s0; &]
[s17; ndx `= `[alfa, beta, gamma, delta, kappa`]&]
[s17; ndx.Find(`"beta`") `= 1&]
[s0; &]
[s5; Если элемент отсутствует в [*C@5 Index`'е], 
[*C@5 Find] возвращает отрицательное значение:&]
[s0; &]
[s7; DUMP(ndx.Find(`"something`"));&]
[s0; &]
[s17; ndx.Find(`"something`") `= `-1&]
[s0; &]
[s5; Любой элемент может заменить метод 
[*C@5 Set]:&]
[s0; &]
[s7; ndx.Set(1, `"alfa`");&]
[s7; &]
[s7; DUMP(ndx);&]
[s0; &]
[s17; ndx `= `[alfa, alfa, gamma, delta, kappa`]&]
[s0; &]
[s5; Если элементов с одинаковым значением 
несколько, `"проитерировать`" (обойти) 
их можно методом [*C@5 FindNext]:&]
[s0; &]
[s7; int fi `= ndx.Find(`"alfa`");&]
[s7; while(fi >`= 0) `{&]
[s7; -|DUMP(fi);&]
[s7; -|fi `= ndx.FindNext(fi);&]
[s7; `}&]
[s0; &]
[s17; fi `= 0&]
[s17; fi `= 1&]
[s0; &]
[s5; Метод[*C@5  FindAdd] , подобно [*C@5 Find], `"добывает`" 
позицию элемента, но если элемент 
отсутствует в [*C@5 Index`'е], то он будет 
добавлен:&]
[s0; &]
[s7; DUMP(ndx.FindAdd(`"one`"));&]
[s7; DUMP(ndx.FindAdd(`"two`"));&]
[s7; DUMP(ndx.FindAdd(`"three`"));&]
[s7; DUMP(ndx.FindAdd(`"two`"));&]
[s7; DUMP(ndx.FindAdd(`"three`"));&]
[s7; DUMP(ndx.FindAdd(`"one`"));&]
[s0; &]
[s17; ndx.FindAdd(`"one`") `= 5&]
[s17; ndx.FindAdd(`"two`") `= 6&]
[s17; ndx.FindAdd(`"three`") `= 7&]
[s17; ndx.FindAdd(`"two`") `= 6&]
[s17; ndx.FindAdd(`"three`") `= 7&]
[s17; ndx.FindAdd(`"one`") `= 5&]
[s0; &]
[s5; Удаление элементов из последовательности 
случайного доступа потенциально 
`"расточительно`" (ресурсозатратно), 
потому, вместо удаления, [*C@5 Index] поддерживает 
операции [*C@5 Unlink] и [*C@5 UnlinkKey], которые 
придерживают элемент в [*C@5 Index`'е], но 
делают его невидимым для операции 
[*C@5 Find]:&]
[s0; &]
[s7; ndx.Unlink(2);&]
[s7; ndx.UnlinkKey(`"kappa`");&]
[s7; &]
[s7; DUMP(ndx.Find(ndx`[2`]));&]
[s7; DUMP(ndx.Find(`"kappa`"));&]
[s0; &]
[s17; ndx.Find(ndx`[2`]) `= `-1&]
[s17; ndx.Find(`"kappa`") `= `-1&]
[s0; &]
[s5; Протестировать, является ли элемент 
в определённой позиции `"отлинкованным`", 
можно методом [*C@5 IsUnlinked:]&]
[s0; &]
[s7; DUMP(ndx.IsUnlinked(1));&]
[s7; DUMP(ndx.IsUnlinked(2));&]
[s0; &]
[s17; ndx.IsUnlinked(1) `= false&]
[s17; ndx.IsUnlinked(2) `= true&]
[s0; &]
[s5; Отлинкованные позиции можно повторно 
использовать методом [*C@5 Put]:&]
[s0; &]
[s7; ndx.Put(`"foo`");&]
[s7; &]
[s7; DUMP(ndx);&]
[s7; DUMP(ndx.Find(`"foo`"));&]
[s0; &]
[s17; ndx `= `[alfa, alfa, gamma, delta, foo, one, two, three`]&]
[s17; ndx.Find(`"foo`") `= 4&]
[s0; &]
[s5; Также можно удалить все отлинкованные 
элементы из [*C@5 Index`'а] с помощью метода 
[*C@5 Sweep]:&]
[s0; &]
[s7; ndx.Sweep();&]
[s7; &]
[s7; DUMP(ndx);&]
[s0; &]
[s17; ndx `= `[alfa, alfa, delta, foo, one, two, three`]&]
[s0; &]
[s5; Операции, непосредственно удаляющие 
или вставляющие элементы Index`'а, ресурсоёмки,
 но тоже доступны:&]
[s0; &]
[s7; ndx.Remove(1);&]
[s7; &]
[s7; DUMP(ndx);&]
[s0; &]
[s17; ndx `= `[alfa, delta, foo, one, two, three`]&]
[s0; &]
[s0; &]
[s7; ndx.RemoveKey(`"two`");&]
[s7; &]
[s7; DUMP(ndx);&]
[s0; &]
[s17; ndx `= `[alfa, delta, foo, one, three`]&]
[s0; &]
[s0; &]
[s7; ndx.Insert(0, `"insert`");&]
[s7; &]
[s7; DUMP(ndx);&]
[s0; &]
[s17; ndx `= `[insert, alfa, delta, foo, one, three`]&]
[s0; &]
[s5; Операция PickKeys позволяет получить 
Vector из элементов Index`'а за `"low constant 
time`" операцию (при этом разрушая исходный 
Index)&]
[s0; &]
[s7; Vector<String> d `= ndx.PickKeys();&]
[s7; &]
[s7; DUMP(d);&]
[s0; &]
[s17; d `= `[insert, alfa, delta, foo, one, three`]&]
[s0; &]
[s5; Pick`-присваивание [*C@5 Vector`'а] к [*C@5 Index`'у] 
поддерживается также:&]
[s0; &]
[s7; d`[0`] `= `"test`";&]
[s7; &]
[s7; ndx `= pick(d);&]
[s7; &]
[s7; DUMP(ndx);&]
[s0; &]
[s17; ndx `= `[test, alfa, delta, foo, one, three`]&]
[s0; &]
[s3;H4;:Section`_3`_9: [@(128.0.255) 3.9 Index и клиентские 
типы]&]
[s5; С тем, чтобы сохранить элементы в 
[*C@5 Index], нужно, чтобы они были типа [*C@5 Moveable], 
имели глубокую копию, и определяли 
[*C@5 operator`=`=] и функцию [*C@5 GetHashValue,] или 
метод для вычисления хэш`-кода. Рекомендуетс
я использовать [*C@5 CombineHash], чтобы комбинироват
ь хэш`-значения типов, которые уже 
предоставляют [*C@5 GetHashValue]:&]
[s0; &]
[s7; struct Person : Moveable<Person> `{&]
[s7; -|String name;&]
[s7; -|String surname;&]
[s7; &]
[s7; -|unsigned GetHashValue() const          `{ return CombineHash(name, 
surname); `}&]
[s7; -|bool operator`=`=(const Person`& b) const `{ return name `=`= 
b.name `&`& surname `=`= b.surname; `}&]
[s7; &]
[s7; -|Person(String name, String surname) : name(name), surname(surname) 
`{`}&]
[s7; -|Person() `{`}&]
[s7; `};&]
[s7; &]
[s7; Index<Person> p;&]
[s7; p.Add(Person(`"John`", `"Smith`"));&]
[s7; p.Add(Person(`"Paul`", `"Carpenter`"));&]
[s7; p.Add(Person(`"Carl`", `"Engles`"));&]
[s7; &]
[s7; DUMP(p.Find(Person(`"Paul`", `"Carpenter`")));&]
[s0; &]
[s17; p.Find(Person(`"Paul`", `"Carpenter`")) `= 1&]
[s0; &]
[s3;H4;:Section`_3`_10: 3.10 [C@5 VectorMap], [C@5 ArrayMap]&]
[s5; [*C@5 VectorMap] `- ни что иное, как простая 
композиция из [*C@5 Index`'а] ключей и [*C@5 Vector`'а 
]значений. Методы [*C@5 Add] используются 
для помещения элементов в [*C@5 VectorMap]:&]
[s0; &]
[s7; struct Person : Moveable<Person> `{&]
[s7; -|String name;&]
[s7; -|String surname;&]
[s7; -|&]
[s7; -|String ToString() const `{ return String() << name << `' `' 
<< surname; `}&]
[s7; &]
[s7; -|Person(String name, String surname) : name(name), surname(surname) 
`{`}&]
[s7; -|Person() `{`}&]
[s7; `};&]
[s7; &]
[s7; VectorMap<String, Person> m;&]
[s7; &]
[s7; m.Add(`"1`", Person(`"John`", `"Smith`"));&]
[s7; m.Add(`"2`", Person(`"Carl`", `"Engles`"));&]
[s7; &]
[s7; Person`& p `= m.Add(`"3`");&]
[s7; p.name `= `"Paul`";&]
[s7; p.surname `= `"Carpenter`";&]
[s7; &]
[s7; DUMP(m);&]
[s0; &]
[s17; m `= `{1: John Smith, 2: Carl Engles, 3: Paul Carpenter`}&]
[s0; &]
[s5; [*C@5 VectorMap] предоставляет доступ read`-only 
(только чтение) к своему [*C@5 Index`'у] ключей 
и доступ read`-write (чтение`-запись) к своему 
[*C@5 Vector`'у] значений:&]
[s0; &]
[s7; DUMP(m.GetKeys());&]
[s7; DUMP(m.GetValues());&]
[s0; &]
[s17; m.GetKeys() `= `[1, 2, 3`]&]
[s17; m.GetValues() `= `[John Smith, Carl Engles, Paul Carpenter`]&]
[s0; &]
[s0; &]
[s7; m.GetValues()`[2`].name `= `"Peter`";&]
[s7; &]
[s7; DUMP(m);&]
[s0; &]
[s17; m `= `{1: John Smith, 2: Carl Engles, 3: Peter Carpenter`}&]
[s0; &]
[s5; Для обхода (итерирования) по содержимому 
[*C@5 VectorMap] можно использовать индексы:&]
[s0; &]
[s7; for(int i `= 0; i < m.GetCount(); i`+`+)&]
[s7; -|LOG(m.GetKey(i) << `": `" << m`[i`]);&]
[s0; &]
[s17; 1: John Smith&]
[s17; 2: Carl Engles&]
[s17; 3: Peter Carpenter&]
[s0; &]
[s5; Стандартная пара [*C@5 begin] / [*C@5 end] для 
[*C@5 VectorMap] `- это диапазон из одних значений 
(внутренний Vector) `- она соответствует 
[*C@5 operator`'у`[`]], возвращающему значения:&]
[s0; &]
[s7; for(const auto`& p : m)&]
[s7; -|DUMP(p);&]
[s0; &]
[s17; p `= John Smith&]
[s17; p `= Carl Engles&]
[s17; p `= Peter Carpenter&]
[s0; &]
[s5; Для обхода ключей можно использовать 
[*C@5 begin]/``end`` внутреннего [*C@5 Index`'а]:&]
[s0; &]
[s7; for(const auto`& p : m.GetKeys())&]
[s7; -|DUMP(p);&]
[s0; &]
[s17; p `= 1&]
[s17; p `= 2&]
[s17; p `= 3&]
[s0; &]
[s5; Альтернативно, можно создать `'диапазон 
проекции`' VectorMap`'а, предоставляющий 
удобную итерацию ключ/значение, применяя 
[*C@5 operator`~] (заметьте, что он также удаляет 
и `'отлинкованные`' элементы, смотрите 
далее):&]
[s0; &]
[s7; for(const auto`& e : `~m) `{&]
[s7; -|DUMP(e.key);&]
[s7; -|DUMP(e.value);&]
[s7; `}&]
[s0; &]
[s17; e.key `= 1&]
[s17; e.value `= John Smith&]
[s17; e.key `= 2&]
[s17; e.value `= Carl Engles&]
[s17; e.key `= 3&]
[s17; e.value `= Peter Carpenter&]
[s0; &]
[s5; Заметьте, что `'диапазон проекции`', 
получаемый с помощью [*C@5 operator`'а `~] ,`- 
значение временное, что если потребуется 
изменяющая операция для значений, 
ссылку на правое значение (r`-value) нужно 
использовать вместо простой ссылки 
(reference):&]
[s0; &]
[s7; for(const auto`& e : `~m)&]
[s7; -|if(e.key `=`= `"2`")&]
[s7; -|-|e.value.surname `= `"May`";&]
[s7; &]
[s7; DUMP(m);&]
[s0; &]
[s17; m `= `{1: John Smith, 2: Carl May, 3: Peter Carpenter`}&]
[s0; &]
[s5; Чтобы получить позицию элемента 
с нужным ключом, можно использовать 
метод Find:&]
[s0; &]
[s7; DUMP(m.Find(`"2`"));&]
[s0; &]
[s17; m.Find(`"2`") `= 1&]
[s0; &]
[s5; или метод Get, чтобы получить соответствующее
 значение:&]
[s0; &]
[s7; DUMP(m.Get(`"2`"));&]
[s0; &]
[s17; m.Get(`"2`") `= Carl May&]
[s0; &]
[s5; При передаче ключа, отсутствующего 
в [*C@5 VectorMap`'е, ]в качестве параметра 
[*C@5 Get], возникает неопределённое поведение 
(ASSERT в отладочном режиме неуспешен). 
Но есть двухпараметрная версия [*C@5 Get], 
которая возвращает второй параметр, 
если ключ в VectorMap`'е не найден:&]
[s0; &]
[s7; DUMP(m.Get(`"33`", Person(`"unknown`", `"person`")));&]
[s0; &]
[s17; m.Get(`"33`", Person(`"unknown`", `"person`")) `= unknown person&]
[s0; &]
[s5; Как в случае с [*C@5 Index`'ом], можно пользоваться 
[*C@5 Unlink], делая элементы невидимыми 
для операций Find:&]
[s0; &]
[s7; m.Unlink(1);&]
[s7; DUMP(m.Find(`"2`"));&]
[s0; &]
[s17; m.Find(`"2`") `= `-1&]
[s0; &]
[s5; [*C@5 SetKey] изменяет ключ элемента:&]
[s0; &]
[s7; m.SetKey(1, `"33`");&]
[s7; DUMP(m.Get(`"33`", Person(`"unknown`", `"person`")));&]
[s0; &]
[s17; m.Get(`"33`", Person(`"unknown`", `"person`")) `= Carl May&]
[s0; &]
[s5; Если есть ещё элементы, с таким же 
ключом, в [*C@5 VectorMap`'е], можно проитерировать 
по ним методом [*C@5 FindNext]:&]
[s0; &]
[s7; m.Add(`"33`", Person(`"Peter`", `"Pan`"));&]
[s7; &]
[s7; int q `= m.Find(`"33`");&]
[s7; while(q >`= 0) `{&]
[s7; -|DUMP(m`[q`]);&]
[s7; -|q `= m.FindNext(q);&]
[s7; `}&]
[s0; &]
[s17; m`[q`] `= Carl May&]
[s17; m`[q`] `= Peter Pan&]
[s0; &]
[s5; Отлинкованные позиции повторно используютс
я через метод Put:&]
[s0; &]
[s7; m.UnlinkKey(`"33`");&]
[s7; m.Put(`"22`", Person(`"Ali`", `"Baba`"));&]
[s7; m.Put(`"44`", Person(`"Ivan`", `"Wilks`"));&]
[s7; &]
[s7; DUMP(m);&]
[s0; &]
[s17; m `= `{1: John Smith, 44: Ivan Wilks, 3: Peter Carpenter, 22: Ali 
Baba`}&]
[s0; &]
[s5; [*C@5 PickValues] / [*C@5 PickIndex] / [*C@5 PickKeys] / `"пикирует`" 
внутренний [*C@5 Vector] / [*C@5 Index] / [*C@5 Vector] из 
[*C@5 Index]:&]
[s0; &]
[s7; Vector<Person> ps `= m.PickValues();&]
[s7; Vector<String> ks `= m.PickKeys();&]
[s7; &]
[s7; DUMP(ps);&]
[s7; DUMP(ks);&]
[s7; DUMP(m);&]
[s0; &]
[s17; ps `= `[John Smith, Ivan Wilks, Peter Carpenter, Ali Baba`]&]
[s17; ks `= `[1, 44, 3, 22`]&]
[s17; m `= `{`}&]
[s0; &]
[s5; Пик`-конструктор[*C@5  VectorMap`'а] создаёт 
мап `"пикингом`":&]
[s0; &]
[s7; ks`[0`] `= `"Changed key`";&]
[s7; &]
[s7; m `= VectorMap<String, Person>(pick(ks), pick(ps));&]
[s7; &]
[s7; DUMP(m);&]
[s0; &]
[s17; m `= `{Changed key: John Smith, 44: Ivan Wilks, 3: Peter Carpenter, 
22: Ali Baba`}&]
[s0; &]
[s5; [*C@5 ArrayMap] `- это композиция Index`'а и Array`'я, 
для тех случаев, когда Array лучше подходит 
для даннного типа значений (например, 
они полиморфны):&]
[s0; &]
[s7; ArrayMap<String, Person> am;&]
[s7; am.Create<Person>(`"key`", `"new`", `"person`");&]
[s7; &]
[s7; DUMP(am);&]
[s0; &]
[s17; am `= `{key: new person`}&]
[s0; &]
[s3;H4;:Section`_3`_11: 3.11 [C@5 One]&]
[s5; [*C@5 One] `- это контейнер, который может 
хранить нисколько или один элемент 
типа T... Или производный от T... По функционалу
 он очень похож на [*C@5 std`::unique`_ptr], но 
обладает некоторыми удобными чертами.&]
[s0; &]
[s7; struct Base `{&]
[s7; -|virtual String Get() `= 0;&]
[s7; -|virtual `~Base() `{`}&]
[s7; `};&]
[s7; &]
[s7; struct Derived1 : Base `{&]
[s7; -|virtual String Get() `{ return `"Derived1`"; `}&]
[s7; `};&]
[s7; &]
[s7; struct Derived2 : Base `{&]
[s7; -|virtual String Get() `{ return `"Derived2`"; `}&]
[s7; `};&]
[s7; &]
[s7; One<Base> s;&]
[s0; &]
[s5; [*C@5 operator bool] `"Вана`" возвращает true, если 
в нём есть элемент:&]
[s0; &]
[s7; DUMP((bool)s);&]
[s0; &]
[s17; (bool)s `= false&]
[s0; &]
[s0; &]
[s7; s.Create<Derived1>();&]
[s7; DUMP((bool)s);&]
[s7; DUMP(s`->Get());&]
[s0; &]
[s17; (bool)s `= true&]
[s17; s`->Get() `= Derived1&]
[s0; &]
[s5; Используется [*C@5 Is] для проверки, есть 
ли на данный момент какой`-то тип в 
[*C@5 One]:&]
[s0; &]
[s7; DUMP(s.Is<Derived1>());&]
[s7; DUMP(s.Is<Base>());&]
[s7; DUMP(s.Is<Derived2>());&]
[s0; &]
[s17; s.Is<Derived1>() `= true&]
[s17; s.Is<Base>() `= true&]
[s17; s.Is<Derived2>() `= false&]
[s0; &]
[s5; Чтобы получить указатель на содержимый 
экземпляр, используется [*C@5 operator`~]:&]
[s0; &]
[s7; Base `*b `= `~s;&]
[s7; DUMP(b`->Get());&]
[s0; &]
[s17; b`->Get() `= Derived1&]
[s0; &]
[s5; Метод Clear удаляет элемент из One:&]
[s0; &]
[s7; s.Clear();&]
[s7; DUMP((bool)s);&]
[s0; &]
[s17; (bool)s `= false&]
[s0; &]
[s5; Вспомогательная функция MakeOne, производная 
от One, может использоваться для создания 
содержимого элемента:&]
[s0; &]
[s7; s `= MakeOne<Derived1>();&]
[s7; DUMP(s`->Get());&]
[s0; &]
[s17; s`->Get() `= Derived1&]
[s0; &]
[s0; &]
[s7; auto t `= pick(s);&]
[s7; DUMP(t`->Get());&]
[s0; &]
[s17; t`->Get() `= Derived1&]
[s0; &]
[s3;H4;:Section`_3`_12: 3.12 [C@5 Any]&]
[s5; [*C@5 Any] `- это контейнер, могущий содержать 
нисколько или один элемент [/ любого] 
типа. Метод [*C@5 Any`::Is ]сверяет точный 
тип, игнорируя иерархии классов (в 
отличие от [*C@5 One`::Is]). Можно употребить 
[*C@5 Get] для дела получения ссылки на 
сохраняемый экземпляр:&]
[s0; &]
[s7; for(int pass `= 0; pass < 2; pass`+`+) `{&]
[s7; -|Any x;&]
[s7; -|if(pass)&]
[s7; -|-|x.Create<String>() `= `"Hello!`";&]
[s7; -|else&]
[s7; -|-|x.Create<Color>() `= Blue();&]
[s7; -|&]
[s7; -|if(x.Is<String>())&]
[s7; -|-|LOG(`"Any is now String: `" << x.Get<String>());&]
[s7; -|&]
[s7; -|if(x.Is<Color>())&]
[s7; -|-|LOG(`"Any is now Color: `" << x.Get<Color>());&]
[s7; `}&]
[s0; &]
[s17; Any is now Color: Color(0, 0, 128)&]
[s17; Any is now String: Hello!&]
[s0; &]
[s3;H4;:Section`_3`_13: 3.13 [C@5 InVector], [C@5 InArray]&]
[s5; [*C@5 InVector] и [*C@5 InArray] `- контейнерные типы, 
весьма подобные [*C@5 Vector]/``Array``, но они 
торгуют скоростью, присущей [*C@5 operator`[`],] 
и способностью вставлять или удалять 
элементы в любой позиции, и быстро. 
Можно ожидать от [*C@5 operator`[`]] в 10 раз 
большую медлительность, чем у Vector`'а 
(но это ещё пока не так уж и медленно!), 
в то время как [*C@5 Insert] в любой позиции 
может `"раздуваться`" до сотен мегабайт 
данных (например, [*C@5 InVector], содержащий 
100 Мб элементов String, справляется без 
проблем).&]
[s0; &]
[s7; InVector<int> v;&]
[s7; for(int i `= 0; i < 1000000; i`+`+)&]
[s7; -|v.Add(i);&]
[s7; v.Insert(0, `-1); // This is fast&]
[s0; &]
[s5; В то время как интерфейс [*C@5 InVector]/``InArray`` 
почти идентичен [*C@5 Vector]/``Array``, [*C@5 InVector]/``InArray`` 
в добавок реализует методы [*C@5 FindLowerBound]/``FindUpper
Bound`` `- пока работают нормальные генерные 
алгоритмы диапазона, можно предоставлять 
[*C@5 InVector]/``InArray`` специфичные оптимизации, 
которые в основном сверяют перформанс 
[*C@5 Find`*Bound] на простом [*C@5 Vector`'е].&]
[s0; &]
[s7; DUMP(v.FindLowerBound(55));&]
[s0; &]
[s17; v.FindLowerBound(55) `= 56&]
[s0; &]
[s3;H4;:Section`_3`_14: 3.14 [C@5 SortedIndex], [C@5 SortedVectorMap], 
[C@5 SortedArrayMap]&]
[s5; [*C@5 SortedIndex] подобен обычному (regular) [*C@5 Index`'у], 
но держит свои элементы в отсортированном 
порядке (предикат сортировки `- это 
шаблонный параметр, по дефолту `-  
[*C@5 StdLess]). Реализация использует [*C@5 InVector], 
так что работает отлично даже с очень 
большим числом элементов (перформанс 
подобен, основанному на дереве, [*C@5 std`::set]). 
В отличие от [*C@5 Index], [*C@5 SortedIndex] предоставляет 
поиск в нижних/верхних пределах, а 
также допускает поиск диапазона.&]
[s0; &]
[s7; SortedIndex<int> x;&]
[s7; x.Add(5);&]
[s7; x.Add(3);&]
[s7; x.Add(7);&]
[s7; x.Add(1);&]
[s7; &]
[s7; DUMPC(x);&]
[s7; DUMP(x.Find(3));&]
[s7; DUMP(x.Find(3));&]
[s7; DUMP(x.FindLowerBound(3));&]
[s7; DUMP(x.FindUpperBound(6));&]
[s0; &]
[s17; x:&]
[s17; -|`[0`] `= 1&]
[s17; -|`[1`] `= 3&]
[s17; -|`[2`] `= 5&]
[s17; -|`[3`] `= 7&]
[s17; x.Find(3) `= 1&]
[s17; x.Find(3) `= 1&]
[s17; x.FindLowerBound(3) `= 1&]
[s17; x.FindUpperBound(6) `= 3&]
[s0; &]
[s5; [*C@5 SortedVectorMap] и [*C@5 SortedArrayMap] это основанные 
на [*C@5 SortedIndex] эквиваленты [*C@5 VectorMap]/``ArrayMap``:&]
[s0; &]
[s7; SortedVectorMap<String, int> m;&]
[s7; m.Add(`"zulu`", 11);&]
[s7; m.Add(`"frank`", 12);&]
[s7; m.Add(`"alfa`", 13);&]
[s7; &]
[s7; DUMPM(m);&]
[s7; DUMP(m.Get(`"zulu`"));&]
[s0; &]
[s17; m:&]
[s17; -|`[0`] `= (alfa) 13&]
[s17; -|`[1`] `= (frank) 12&]
[s17; -|`[2`] `= (zulu) 11&]
[s17; m.Get(`"zulu`") `= 11&]
[s0; &]
[s3;H4;:Section`_3`_15: [@(128.0.255) 3.15 Кортежи]&]
[s5; Шаблонный класс [*C@5 Tuple] позволяет 
комбинировать 2`-4 значения разных 
типов. В принципе, это подобно [*C@5 std`::tuple], 
с некоторыми преимуществами. В отличие 
от [*C@5 std`::tuple], индивидуальные элементы 
прямо доступны, как переменные`-члены 
[*C@5 a]..``d``, [*C@5 Tuple] поддерживает паттерн 
персистентного хранения ([*C@5 Serialize], 
[*C@5 Jsonize], [*C@5 Xmlize]), хэш`-код ([*C@5 GetHashValue]), 
преобразование в [*C@5 String] и преобразования 
Value.&]
[s5; Чтобы создать значение [*C@5 Tuple`'а], можно 
использовать функцию [*C@5 MakeTuple].&]
[s0; &]
[s7; Tuple<int, String, String> x `= MakeTuple(12, `"hello`", `"world`");&]
[s0; &]
[s5; Индивидуальные значения доступны 
как члены [*C@5 a] .. [*C@5 d]:&]
[s0; &]
[s7; DUMP(x.a);&]
[s7; DUMP(x.b);&]
[s7; DUMP(x.c);&]
[s0; &]
[s17; x.a `= 12&]
[s17; x.b `= hello&]
[s17; x.c `= world&]
[s0; &]
[s5; Или с помощью [*C@5 Get]:&]
[s0; &]
[s7; DUMP(x.Get<1>());&]
[s7; DUMP(x.Get<int>());&]
[s0; &]
[s17; x.Get<1>() `= hello&]
[s17; x.Get<int>() `= 12&]
[s0; &]
[s5; Поскольку все индивидуальные типы 
имеют преобразование в [*C@5 String] ([*C@5 AsString]), 
кортеж тоже имеет такое преобразование, 
и, таким образом, может быть, например, 
легко логгирован:&]
[s0; &]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= (12, hello, world)&]
[s0; &]
[s5; Поскольку все индивидуальные типы 
определяют [*C@5 GetHashValue], тоже и у [*C@5 Tuple]:&]
[s0; &]
[s7; DUMP(GetHashValue(x));&]
[s0; &]
[s17; GetHashValue(x) `= 2465159845&]
[s0; &]
[s5; Поскольку у всех индивидуальных 
типов определён [*C@5 operator`=`=], [*C@5 Tuple] определяет 
[*C@5 operator`=`=] и [*C@5 operator!`=]:&]
[s0; &]
[s7; Tuple<int, String, String> y `= x;&]
[s7; DUMP(x `=`= y);&]
[s7; DUMP(x !`= y);&]
[s7; y.a`+`+;&]
[s7; DUMP(x `=`= y);&]
[s7; DUMP(x !`= y);&]
[s0; &]
[s17; x `=`= y `= true&]
[s17; x !`= y `= false&]
[s17; x `=`= y `= false&]
[s17; x !`= y `= true&]
[s0; &]
[s5; Поскольку у всех индивидуальных 
типов определён [*C@5 SgnCompare], Tuple имеет 
SgnCompare, метод Compare и операторы <, <`=, 
>, >`=:&]
[s0; &]
[s7; DUMP(x.Compare(y));&]
[s7; DUMP(SgnCompare(x, y));&]
[s7; DUMP(x < y);&]
[s0; &]
[s17; x.Compare(y) `= `-1&]
[s17; SgnCompare(x, y) `= `-1&]
[s17; x < y `= true&]
[s0; &]
[s5; GetCount возвращает ширину [*C@5 Tuple`'а]:&]
[s0; &]
[s7; DUMP(x.GetCount());&]
[s0; &]
[s17; x.GetCount() `= 3&]
[s0; &]
[s5; Элементы, прямо преобразуемые в [*C@5 Value], 
могут быть `'Get`'/`'Set`' (получены или 
установлены):&]
[s0; &]
[s7; for(int i `= 0; i < x.GetCount(); i`+`+)&]
[s7; -|DUMP(x.Get(i));&]
[s0; &]
[s17; x.Get(i) `= 12&]
[s17; x.Get(i) `= hello&]
[s17; x.Get(i) `= world&]
[s0; &]
[s0; &]
[s7; x.Set(1, `"Hi`");&]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= (12, Hi, world)&]
[s0; &]
[s5; Поскольку все индивидуальные типы 
преобразуемы через [*C@5 Value], можно преобразова
ть Tuple в [*C@5 ValueArray,] и обратно:&]
[s0; &]
[s7; ValueArray va `= x.GetArray();&]
[s7; DUMP(va);&]
[s7; &]
[s7; va.Set(2, `"Joe`");&]
[s7; x.SetArray(va);&]
[s0; &]
[s17; va `= `[12, Hi, world`]&]
[s0; &]
[s5; Всё OK с присваиванием [*C@5 Tuple`'а] к [*C@5 Tuple`'у] 
с иными индивидуальными типами, поскольку 
типы преобразуемы напрямую:&]
[s0; &]
[s7; Tuple<double, String, String> d `= x;&]
[s7; DUMP(d);&]
[s0; &]
[s17; d `= (12, Hi, Joe)&]
[s0; &]
[s5; Tie можно использовать для присваивания 
кортежа l`-values (левым значениям):&]
[s0; &]
[s7; int i;&]
[s7; String s1, s2;&]
[s7; &]
[s7; Tie(i, s1, s2) `= x;&]
[s7; &]
[s7; DUMP(i);&]
[s7; DUMP(s1);&]
[s7; DUMP(s2);&]
[s0; &]
[s17; i `= 12&]
[s17; s1 `= Hi&]
[s17; s2 `= Joe&]
[s0; &]
[s5; U`+`+ Tuples тщательно проработаны как 
POD`-типы, позволяющие инициализировать 
POD`-массивы в классическом Си`-стайле:&]
[s0; &]
[s7; static Tuple2<int, const char `*> map`[`] `= `{&]
[s7; -|`{ 1, `"one`" `},&]
[s7; -|`{ 2, `"one`" `},&]
[s7; -|`{ 3, `"one`" `},&]
[s7; `};&]
[s0; &]
[s5; Простая шаблонная функция FindTuple предназнача
ется для поиска кортежа, основываясь 
на первом значении ([*C@5 a]) (линейный 
поиск O(n) ):&]
[s0; &]
[s7; DUMP(FindTuple(map, `_`_countof(map), 3)`->b);&]
[s0; &]
[s17; FindTuple(map, `_`_countof(map), 3)`->b `= one&]
[s0; &]
[s22;:Chapter`_4: [@3 4. Диапазоны и алгоритмы]&]
[s3;:Section`_4`_1: [@(128.0.255) 4.1 Диапазон (Range)]&]
[s5; В отличие от STL, который `"интерфейсит`" 
алгоритмы с данными, используя пару 
[*C@5 begin] / [*C@5 end], алгоритмы U`+`+ обычно 
работают над [/ Range`'ами]. Range `- это объект, 
у которого есть методы [*C@5 begin] / [*C@5 end], 
предоставляющий случайный доступ 
к элементам (у всех контейнеров U`+`+ 
случайный доступ), [*C@5 operator`[`]] и метод 
[*C@5 GetCount].&]
[s5; Очевидно, что контейнеры U`+`+ `- это 
диапазоны:&]
[s0; &]
[s7; Vector<int> x `= `{ 1, 2, 3, 4, 5, 1, 2, 3, 4 `};&]
[s7; &]
[s7; DUMP(FindIndex(x, 2)); // FindIndex `-тривиальный 
алгоритм линейного поиска&]
[s0; &]
[s17; FindIndex(x, 2) `= 1&]
[s0; &]
[s5; Если требуется выполнить алгоритм 
над частью контейнера, используется 
экземпляр [*C@5 SubRange (ПодДиапазона)]:&]
[s0; &]
[s7; DUMP(SubRange(x, 3, 6));&]
[s7; DUMP(FindIndex(SubRange(x, 3, 6), 4));&]
[s0; &]
[s17; SubRange(x, 3, 6) `= `[4, 5, 1, 2, 3, 4`]&]
[s17; FindIndex(SubRange(x, 3, 6), 4) `= 0&]
[s0; &]
[s5; Как подработка, SubRange также создаваем... 
`"созидаем`"... из пары `'begin`' / `'end`', тем 
самым, например, позволяя алгоритмам 
работать над массивами Си:&]
[s0; &]
[s7; int a`[`] `= `{ 1, 22, 4, 2, 8 `};&]
[s7; &]
[s7; auto ar `= SubRange(std`::begin(a), std`::end(a));&]
[s7; &]
[s7; DUMP(ar);&]
[s0; &]
[s17; ar `= `[1, 22, 4, 2, 8`]&]
[s0; &]
[s0; &]
[s7; Sort(ar);&]
[s7; DUMP(ar);&]
[s0; &]
[s17; ar `= `[1, 2, 4, 8, 22`]&]
[s0; &]
[s5; Имеется несколько алиасов макроса, 
чем облегчается управление типами 
диапазонов:&]
[s0; &]
[s7; DUMP(typeid(ValueTypeOf<decltype(x)>).name());&]
[s7; DUMP(typeid(ValueTypeOf<decltype(SubRange(x, 1, 1))>).name());&]
[s7; DUMP(typeid(IteratorOf<decltype(x)>).name());&]
[s7; DUMP(typeid(ConstIteratorOf<decltype(SubRange(x, 1, 1))>).name());&]
[s7; DUMP(typeid(SubRangeOf<Vector<int>>).name());&]
[s0; &]
[s17; typeid(ValueTypeOf<decltype(x)>).name() `= i&]
[s17; typeid(ValueTypeOf<decltype(SubRange(x, 1, 1))>).name() `= i&]
[s17; typeid(IteratorOf<decltype(x)>).name() `= Pi&]
[s17; typeid(ConstIteratorOf<decltype(SubRange(x, 1, 1))>).name() 
`= Pi&]
[s17; typeid(SubRangeOf<Vector<int>>).name() `= N3Upp13SubRangeClassIPiEE&]
[s0; &]
[s5; В то время, как сами контейнеры и 
 SubRange, `- два самых общих типа диапазонов, 
у U`+`+ есть ещё два особых диапазона. 
[*C@5 ConstRange] просто провайдит диапазон 
единичного значения:&]
[s0; &]
[s7; DUMP(ConstRange(1, 10));&]
[s0; &]
[s17; ConstRange(1, 10) `= `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1`]&]
[s0; &]
[s5; [*C@5 ReverseRange] реверсирует порядок элементов 
в исходном диапазоне:&]
[s0; &]
[s7; Vector<int> v`{ 1, 2, 3, 4 `};&]
[s7; &]
[s7; DUMP(ReverseRange(v));&]
[s0; &]
[s17; ReverseRange(v) `= `[4, 3, 2, 1`]&]
[s0; &]
[s5; [*C@5 ViewRange] `"пикирует`" исходный диапазон 
и [*C@5 Vector] из целочисленных индексов 
и провайдит просмотр исходного диапазона 
через этот [*C@5 Vector]:&]
[s0; &]
[s7; Vector<int> h`{ 2, 4, 0 `};&]
[s7; &]
[s7; DUMP(ViewRange(x, clone(h)));&]
[s0; &]
[s17; ViewRange(x, clone(h)) `= `[3, 5, 1`]&]
[s0; &]
[s0; &]
[s7; Sort(ViewRange(x, clone(h)));&]
[s7; DUMP(ViewRange(x, clone(h)));&]
[s7; DUMP(x);&]
[s0; &]
[s17; ViewRange(x, clone(h)) `= `[1, 3, 5`]&]
[s17; x `= `[5, 2, 1, 4, 3, 1, 2, 3, 4`]&]
[s0; &]
[s5; [*C@5 SortedRange] возвращает диапазон отсортированн
ым по предикату (дефолт есть std`::less):&]
[s0; &]
[s7; DUMP(SortedRange(x));&]
[s0; &]
[s17; SortedRange(x) `= `[1, 1, 2, 2, 3, 3, 4, 4, 5`]&]
[s0; &]
[s5; Наконец, [*C@5 FilterRange] создаёт поддиапазон 
элементов, удовлетворяющий определённому 
условию:&]
[s0; &]
[s7; DUMP(FilterRange(x, `[`](int x) `{ return x > 3; `}));&]
[s0; &]
[s17; FilterRange(x, `[`](int x) `{ return x > 3; `}) `= `[5, 4, 4`]&]
[s0; &]
[s5; Различные функции Range`'а можно комбинировать
, производя комплексные результаты:&]
[s0; &]
[s7; DUMP(ReverseRange(FilterRange(x, `[`](int x) `{ return x < 4; 
`})));&]
[s0; &]
[s17; ReverseRange(FilterRange(x, `[`](int x) `{ return x < 4; `})) 
`= `[3, 2, 1, 3, 1, 2`]&]
[s0; &]
[s3;H4;:Section`_4`_2: [@(128.0.255) 4.2 Алгоритмы]&]
[s5; В принципе, можно применять алгоритмы 
из стандартной библиотеки C`+`+ к контейнерам 
или диапазонам U`+`+.&]
[s5; Алгоритмы U`+`+ имеют `"тюнинг`" под 
подход U`+`+ `- они работают над диапазонами 
и предпочитают индексы. Иногда алгоритм 
U`+`+ выполняется быстрее с типами U`+`+, 
чем алгоритм стандартной библиотеки.&]
[s5; [*C@5 FindIndex] выполняет линейный поиск, 
ища элемент с заданным значением, 
и возвращает его индекс или `-1, если 
не находит:&]
[s0; &]
[s7; Vector<int> data `{ 5, 3, 7, 9, 3, 4, 2 `};&]
[s7; &]
[s7; &]
[s7; DUMP(FindIndex(data, 3));&]
[s7; DUMP(FindIndex(data, 6));&]
[s0; &]
[s17; FindIndex(data, 3) `= 1&]
[s17; FindIndex(data, 6) `= `-1&]
[s0; &]
[s5; [*C@5 SubRange] можно использовать для применения 
алгоритма к поддиапазону контейнера:&]
[s0; &]
[s7; DUMP(FindIndex(SubRange(data, 2, data.GetCount() `- 2), 3));&]
[s0; &]
[s17; FindIndex(SubRange(data, 2, data.GetCount() `- 2), 3) `= 2&]
[s0; &]
[s5; [*C@5 FindMin] и [*C@5 FindMax] возвращает индекс 
минимального/максимального элемента:&]
[s0; &]
[s7; DUMP(FindMin(data));&]
[s7; DUMP(FindMax(data));&]
[s0; &]
[s17; FindMin(data) `= 6&]
[s17; FindMax(data) `= 3&]
[s0; &]
[s5; [*C@5 Min] и [*C@5 Max] возвращают [/ значение] 
минимального/максимального элемента:&]
[s0; &]
[s7; DUMP(Min(data));&]
[s7; DUMP(Max(data));&]
[s0; &]
[s17; Min(data) `= 2&]
[s17; Max(data) `= 9&]
[s0; &]
[s5; Если диапазон пуст, [*C@5 Min] и [*C@5 Max] неопределённ
ы (ASSERT не удаётся в отладочном режиме), 
но можно определить значение как 
второй параметр:&]
[s0; &]
[s7; -|Vector<int> empty;&]
[s7; //-|DUMP(Min(empty)); // Это неопределённо (неуспешный 
ASSERT)&]
[s7; -|DUMP(Min(empty, `-99999));&]
[s0; &]
[s17; Min(empty, `-99999) `= `-99999&]
[s0; &]
[s5; [*C@5 Count] возвращает число элементов 
с заданным значением, [*C@5 CountIf] `- число 
элементов, удовлетворяющих предикату:&]
[s0; &]
[s7; DUMP(Count(data, 11));&]
[s7; DUMP(CountIf(data, `[`=`](int c) `{ return c >`= 5; `}));&]
[s0; &]
[s17; Count(data, 11) `= 0&]
[s17; CountIf(data, `[`=`](int c) `{ return c >`= 5; `}) `= 3&]
[s0; &]
[s5; [*C@5 Sum] возвращает сумму всех элементов 
диапазона:&]
[s0; &]
[s7; DUMP(Sum(data));&]
[s0; &]
[s17; Sum(data) `= 33&]
[s0; &]
[s5; Отсортированные контейнеры допускают 
поиск с бисекцией (т.е. разбиением 
их содержимого надвое). U`+`+ предоставляет 
обычные алгоритмы верхнего/нижнего 
предела. [*C@5 FindBinary] возвращает индекс 
элемента с заданным значением или 
`-1, если не находит такового:&]
[s0; &]
[s7; data `= `{ 5, 7, 9,  9, 14, 20, 23, 50 `};&]
[s7;       // 0  1  2   3   4   5   6   7&]
[s7; DUMP(FindLowerBound(data, 9));&]
[s7; DUMP(FindUpperBound(data, 9));&]
[s7; DUMP(FindBinary(data, 9));&]
[s7; DUMP(FindLowerBound(data, 10));&]
[s7; DUMP(FindUpperBound(data, 10));&]
[s7; DUMP(FindBinary(data, 10));&]
[s0; &]
[s17; FindLowerBound(data, 9) `= 2&]
[s17; FindUpperBound(data, 9) `= 4&]
[s17; FindBinary(data, 9) `= 2&]
[s17; FindLowerBound(data, 10) `= 4&]
[s17; FindUpperBound(data, 10) `= 4&]
[s17; FindBinary(data, 10) `= `-1&]
[s0; &]
[s3;H4;:Section`_4`_3: [@(128.0.255) 4.3 Сортировка]&]
[s5; Неудивительно, но функция [*C@5 Sort] сортирует 
диапазон)) Можно указать предикат 
сортировки, по дефолту идёт [*C@5 operator<]:&]
[s0; &]
[s7; Vector<String> x `{ `"1`", `"2`", `"10`" `};&]
[s7; &]
[s7; Sort(x);&]
[s7; &]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= `[1, 10, 2`]&]
[s0; &]
[s0; &]
[s7; Sort(x, `[`](const String`& a, const String`& b) `{ return atoi(a) 
< atoi(b); `});&]
[s7; &]
[s7; DUMP(x);&]
[s0; &]
[s17; x `= `[1, 2, 10`]&]
[s0; &]
[s5; [*C@5 IndexSort] `- вариант сортировки, способный 
сортировать два диапазона (типа [*C@5 Vector] 
или [*C@5 Array]), одинакового размера, основываясь
 на значениях в первом диапазоне:&]
[s0; &]
[s7; Vector<int> a `{ 5, 10, 2, 9, 7, 3 `};&]
[s7; Vector<String> b `{ `"five`", `"ten`", `"two`", `"nine`", `"seven`", 
`"three`" `};&]
[s7; &]
[s7; IndexSort(a, b);&]
[s7; &]
[s7; DUMP(a);&]
[s7; DUMP(b);&]
[s0; &]
[s17; a `= `[2, 3, 5, 7, 9, 10`]&]
[s17; b `= `[two, three, five, seven, nine, ten`]&]
[s0; &]
[s0; &]
[s7; IndexSort(b, a);&]
[s7; &]
[s7; DUMP(a);&]
[s7; DUMP(b);&]
[s0; &]
[s17; a `= `[5, 9, 7, 10, 3, 2`]&]
[s17; b `= `[five, nine, seven, ten, three, two`]&]
[s0; &]
[s5; Также есть варианты [*C@5 IndexSort2] и [*C@5 IndexSort3], 
которые сотрируют 2 или 3 зависимых 
диапазона.&]
[s5; Иногда, вместо сортировки элементов 
в диапазоне, полезно узнать порядок 
элементов после сортировки,`- используется 
[*C@5 GetSortOrder]:&]
[s0; &]
[s7; Vector<int> o `= GetSortOrder(a);&]
[s7; &]
[s7; DUMP(o);&]
[s0; &]
[s17; o `= `[5, 4, 0, 2, 1, 3`]&]
[s0; &]
[s5; Нормальный [*C@5 Sort] нестабилен `- одинаковые 
элементы могут появляться в отсортированном
 диапазоне в случайном порядке. Если 
поддерживать исходный порядок равных 
элементов важно, тогда используйте 
вариант [*C@5 StableSort] (с пенальти по перформансу):&]
[s0; &]
[s7; Vector<Point> t `{ Point(10, 10), Point(7, 1), Point(7, 2), 
Point(7, 3), Point(1, 0) `};&]
[s7; StableSort(t, `[`](const Point`& a, const Point`& b) `{ return 
a.x < b.x; `});&]
[s7; &]
[s7; DUMP(t);&]
[s0; &]
[s17; t `= `[`[1, 0`], `[7, 1`], `[7, 2`], `[7, 3`], `[10, 10`]`]&]
[s0; &]
[s5; Все алгоритмы сортировки имеют свой 
`'Stable`' вариант. Так, существуют [*C@5 StableIndexSort], 
[*C@5 GetStableSortOrder] и т.д....&]
[s22;:Chapter`_5: [@3 5. Значение]&]
[s3;:Section`_5`_1: [@(128.0.255) 5.1 Value]&]
[s5; Value `- своего рода эквивалент полиморфным 
типам данных из скриптовых языков 
типа Python или JavaSript. [*C@5 Value] может представлять 
значения конкретных типов, некоторые 
типы также имеют расширенную интеропрерабил
ьность с [*C@5 Value], что делает возможным, 
например, сравнение [*C@5 Value`'й], содержащих 
такие типы, друг с другом, или их сериализаци
ю для постоянного хранения.&]
[s5; Обычно совместимые с Value типы имеют 
определение оператора typecast`'а в [*C@5 Value] 
и конструктор из [*C@5 Value. ]Таким образом, 
взаимодействие по большей часть несомненно:&]
[s0; &]
[s7; Value a `= 1;&]
[s7; Value b `= 2.34;&]
[s7; Value c `= GetSysDate();&]
[s7; Value d `= `"hello`";&]
[s7; &]
[s7; DUMP(a);&]
[s7; DUMP(b);&]
[s7; DUMP(c);&]
[s7; DUMP(d);&]
[s7; &]
[s7; int x `= a;&]
[s7; double y `= b;&]
[s7; Date z `= c;&]
[s7; String s `= d;&]
[s7; &]
[s7; DUMP(x);&]
[s7; DUMP(y);&]
[s7; DUMP(z);&]
[s7; DUMP(s);&]
[s0; &]
[s17; a `= 1&]
[s17; b `= 2.34&]
[s17; c `= 07/21/2021&]
[s17; d `= hello&]
[s17; x `= 1&]
[s17; y `= 2.34&]
[s17; z `= 07/21/2021&]
[s17; s `= hello&]
[s0; &]
[s5; Что касается примитивных типов, Value 
безупречно работает с [*C@5 int], [*C@5 int64], 
[*C@5 bool] и [*C@5 double]. Переброс (кастинг) [*C@5 Value] 
в тип, который оно не содержит, приводит 
к выводу ошибки:&]
[s0; &]
[s7; try `{&]
[s7; -|s `= a;&]
[s7; -|DUMP(s); // we never get here....&]
[s7; `}&]
[s7; catch(ValueTypeError) `{&]
[s7; -|LOG(`"Неудачное преобразование Value`");&]
[s7; `}&]
[s0; &]
[s17; Неудачное преобразование Value&]
[s0; &]
[s5; Однако, преобразование между взаимосвязанн
ыми типами возможно (поскольку оно 
поддерживается этими типами):&]
[s0; &]
[s7; double i `= a;&]
[s7; int j `= b;&]
[s7; Time k `= c;&]
[s7; WString t `= d;&]
[s7; &]
[s7; DUMP(i);&]
[s7; DUMP(j);&]
[s7; DUMP(k);&]
[s7; DUMP(t);&]
[s0; &]
[s17; i `= 1&]
[s17; j `= 2&]
[s17; k `= 07/21/2021 00:00:00&]
[s17; t `= hello&]
[s0; &]
[s5; Чтобы определить тип значения, сохранённого
 в [*C@5 Value], можно использовать метод 
[*C@5 Is]:&]
[s0; &]
[s7; DUMP(a.Is<int>());&]
[s7; DUMP(a.Is<double>());&]
[s7; DUMP(b.Is<double>());&]
[s7; DUMP(c.Is<int>());&]
[s7; DUMP(c.Is<Date>());&]
[s7; DUMP(d.Is<String>());&]
[s0; &]
[s17; a.Is<int>() `= true&]
[s17; a.Is<double>() `= false&]
[s17; b.Is<double>() `= true&]
[s17; c.Is<int>() `= false&]
[s17; c.Is<Date>() `= true&]
[s17; d.Is<String>() `= true&]
[s0; &]
[s5; Заметьте, что Is тестирует на абсолютное 
совпадение типов, а не на совместимые 
типы. По этой причине, определены 
вспомогательные функции для широко 
используемых совместимых типов:&]
[s0; &]
[s7; DUMP(IsNumber(a));&]
[s7; DUMP(IsNumber(b));&]
[s7; DUMP(IsDateTime(c));&]
[s7; DUMP(IsString(d));&]
[s0; &]
[s17; IsNumber(a) `= true&]
[s17; IsNumber(b) `= true&]
[s17; IsDateTime(c) `= true&]
[s17; IsString(d) `= true&]
[s0; &]
[s3;H4;:Section`_5`_2: 5.2 [C@5 Null]&]
[s5; U`+`+ определяет специальную константу 
[*C@5 Null], чтобы представлять пустое значение. 
Эта константа преобразуема во многие 
типы значений, включая примитивные 
типы [*C@5 double], [*C@5 int] и [*C@5 int64] (определяется 
как наименьшее число, которое может 
представлять тип). Если тип поддерживает 
упорядочивание (<, >), то все значения 
этого типа больше, чем значение Null. 
Для тестирования на пустое значение 
используется функция [*C@5 IsNull].&]
[s0; &]
[s7; int x `= Null;&]
[s7; int y `= 120;&]
[s7; Date d `= Null;&]
[s7; Date e `= GetSysDate();&]
[s7; &]
[s7; DUMP(x);&]
[s7; DUMP(y);&]
[s7; DUMP(d);&]
[s7; DUMP(e > d);&]
[s0; &]
[s17; x `= &]
[s17; y `= 120&]
[s17; d `= &]
[s17; e > d `= true&]
[s0; &]
[s5; [*C@5 Null] `- это единственный экземпляр 
типа [*C@5 Nuller]. Присваивание [*C@5 Null] примитивным 
типам достигается оператором переброса 
класса [*C@5 Nuller; ]другие типы могут выполнять 
это, используя конструктор из [*C@5 Nuller`'а].&]
[s5; Как особый случай, если [*C@5 Value] содержит 
[*C@5 Null], то оно конвертабильно в любой 
тип значения, который может содержать 
[*C@5 Null]:&]
[s0; &]
[s7; Value v `= x; // x is int&]
[s7; e `= v; // e is Date, but v is Null, so Null is assigned to 
e&]
[s7; &]
[s7; DUMP(IsNull(e));&]
[s0; &]
[s17; IsNull(e) `= true&]
[s0; &]
[s5; Функция [*C@5 Nvl] `- это U`+`+ аналог хорошо 
известной функции SQL coalesce (ifnull, Nvl), 
которая возвращает первый не`-null аргумент 
(или [*C@5 Null], если все равны [*C@5 Null]).&]
[s0; &]
[s7; int a `= Null;&]
[s7; int b `= 123;&]
[s7; int c `= 1;&]
[s7; &]
[s7; DUMP(Nvl(a, b, c));&]
[s0; &]
[s17; Nvl(a, b, c) `= 123&]
[s0; &]
[s3;H4;:Section`_5`_3: [@(128.0.255) 5.3 Клиентские типы 
и] [C@5 Value], [C@5 RawValue], [C@5 RichValue]&]
[s5; У Value есть два уровня совместимости. 
Простой, [*C@5 RawValue], имеет невысокие 
требования к используемому типу `- 
нужны только конструктор копии и 
оператор присваивания (существуют 
даже формы [*C@5 RawValue], которые работают 
с типами, у которые этого нет):&]
[s0; &]
[s7; struct RawFoo `{&]
[s7; -|String x;&]
[s7; -|// дефолтный конструктор копии и 
оператор присваивания предоставляет 
компилятор&]
[s7; `};&]
[s0; &]
[s5; Чтобы преобразовать такие типы в 
[*C@5 Value], используется [*C@5 RawToValue]:&]
[s0; &]
[s7; RawFoo h;&]
[s7; h.x `= `"hello`";&]
[s7; Value q `= RawToValue(h);&]
[s7; &]
[s7; DUMP(q.Is<RawFoo>());&]
[s0; &]
[s17; q.Is<RawFoo>() `= true&]
[s0; &]
[s5; Для обратного преобразования, используется
 шаблонная функция`-член `'To`' класса 
[*C@5 Value], она возвращает константную 
ссылку на это значение:&]
[s0; &]
[s7; DUMP(q.To<RawFoo>().x);&]
[s0; &]
[s17; q.To<RawFoo>().x `= hello&]
[s0; &]
[s5; Значения уровня[*C@5  RichValue] предоставляют 
дополнительные операции `- тест на 
равенство, тест [*C@5 IsNull], хэширование, 
преобразование в текст, сериализацию 
(можно в XML и Json), сравнение. Чтобы сериализаци
я работала, типу должен быть присвоен 
целочисленный идентификатор (клиентские 
типы должны использовать иды в диапазоне 
10000..20000). Тип может предоставлять поддержку 
этих операций через определение шаблонной 
функции, либо (что, возможно, удобней) 
с применением определённых методов 
и наследованием от шаблона класса`-основы 
[*C@5 ValueType]:&]
[s0; &]
[s7; struct Foo : ValueType<Foo, 10010> `{&]
[s7; -|int x;&]
[s7; -|&]
[s7; -|Foo(const Nuller`&)                  `{ x `= Null; `}&]
[s7; -|Foo(int x) : x(x) `{`}&]
[s7; -|Foo() `{`}&]
[s7; &]
[s7; -|// We provide these methods to allow automatic conversion of 
Foo to/from Value&]
[s7; -|operator Value() const              `{ return RichToValue(`*this); 
`}&]
[s7; -|Foo(const Value`& v)                 `{ `*this `= v.Get<Foo>(); 
`}&]
[s7; &]
[s7; -|String ToString() const             `{ return AsString(x); 
`}&]
[s7; -|unsigned GetHashValue() const       `{ return x; `}&]
[s7; -|void Serialize(Stream`& s)           `{ s % x; `}&]
[s7; -|bool operator`=`=(const Foo`& b) const `{ return x `=`= b.x; 
`}&]
[s7; -|bool IsNullInstance() const         `{ return IsNull(x); `}&]
[s7; -|int  Compare(const Foo`& b) const    `{ return SgnCompare(x, 
b.x); `}&]
[s7; -|// This type does not define XML nor Json serialization&]
[s7; `};&]
[s7; &]
[s7; INITBLOCK `{ // This has to be at file level scope&]
[s7; -|Value`::Register<Foo>(); // need to register value type integer 
id to allow serialization&]
[s7; `}&]
[s7; &]
[s7; Value a `= Foo(54321); // uses Foo`::operator Value&]
[s7; Value b `= Foo(54321);&]
[s7; Value c `= Foo(600);&]
[s7; &]
[s7; DUMP(a); // uses Foo`::ToString&]
[s7; DUMP(a `=`= b); // uses Foo`::operator`=`=&]
[s7; DUMP(a `=`= c);&]
[s7; DUMP(c < a); // uses Foo`::Compare&]
[s7; &]
[s7; DUMP(IsNull(a)); // uses Foo`::IsNullInstance&]
[s7; &]
[s7; Foo foo `= c; // Uses Foo`::Foo(const Value`&)&]
[s7; DUMP(foo);&]
[s0; &]
[s17; a `= 54321&]
[s17; a `=`= b `= true&]
[s17; a `=`= c `= false&]
[s17; c < a `= true&]
[s17; IsNull(a) `= false&]
[s17; foo `= 600&]
[s0; &]
[s0; &]
[s7; String s `= StoreAsString(a); // Uses Foo`::Serialize&]
[s7; &]
[s7; Value loaded;&]
[s7; // Using registered (Value`::Registered) integer id creates the 
correct type, then uses&]
[s7; // Foo`::Serialize to load the data from the stream&]
[s7; LoadFromString(loaded, s);&]
[s7; &]
[s7; DUMP(loaded);&]
[s0; &]
[s17; loaded `= 54321&]
[s0; &]
[s3;H4;:Section`_5`_4: 5.4 [C@5 ValueArray] и [C@5 ValueMap]&]
[s5; [*C@5 ValueArray] `- это тип, представляющий 
массив из [*C@5 Value`'й]:&]
[s0; &]
[s7; ValueArray va`{1, 2, 3`};&]
[s7; &]
[s7; DUMP(va);&]
[s0; &]
[s17; va `= `[1, 2, 3`]&]
[s0; &]
[s5; ValueArray можно присвоить к Value (и наоборот):&]
[s0; &]
[s7; Value v `= va;&]
[s7; &]
[s7; DUMP(v);&]
[s7; DUMP(v.Is<ValueArray>()); // must be exactly ValueArray&]
[s7; DUMP(IsValueArray(v)); // is ValueArray or ValueMap (which is 
convertible to ValueArray)&]
[s7; &]
[s7; ValueArray va2 `= v;&]
[s7; &]
[s7; DUMP(va2);&]
[s0; &]
[s17; v `= `[1, 2, 3`]&]
[s17; v.Is<ValueArray>() `= true&]
[s17; IsValueArray(v) `= true&]
[s17; va2 `= `[1, 2, 3`]&]
[s0; &]
[s5; Элементы могут приставляться с помощью 
метода [*C@5 Add] или [*C@5 operator<<.]Элементы 
по индексу изменяют методом [*C@5 Set]:&]
[s0; &]
[s7; va.Add(10);&]
[s7; va << 20 << 21;&]
[s7; va.Set(0, 999);&]
[s7; &]
[s7; DUMP(va);&]
[s0; &]
[s17; va `= `[999, 2, 3, 10, 20, 21`]&]
[s0; &]
[s5; Элементы можно удалять:&]
[s0; &]
[s7; va.Remove(0, 2);&]
[s7; &]
[s7; DUMP(va);&]
[s0; &]
[s17; va `= `[3, 10, 20, 21`]&]
[s0; &]
[s5; и вставлять:&]
[s0; &]
[s7; va.Insert(1, v);&]
[s7; &]
[s7; DUMP(va);&]
[s0; &]
[s17; va `= `[3, 1, 2, 3, 10, 20, 21`]&]
[s0; &]
[s5; Можно получить сылку на элемент по 
индексу, но помните, что здесь прилагаются 
кое`-какие [^topic`:`/`/Core`/srcdoc`/ValueReference`_ru`-ru^ особые 
правила]:&]
[s0; &]
[s7; va.At(0) `= 222;&]
[s7; &]
[s7; DUMP(va);&]
[s0; &]
[s17; va `= `[222, 1, 2, 3, 10, 20, 21`]&]
[s0; &]
[s5; Если [*C@5 Value] содержит [*C@5 ValueArray], метод 
[*C@5 Value`::GetCount] возвращает число элементов 
в массиве (если в [*C@5 Value ]отсутствует 
какой`-либо [*C@5 ValueArray], возвращается 
ноль). Можно использовать [*C@5 Value`::operator`[`](int)], 
чтобы получить ссылку на элементы 
[*C@5 ValueArray`'я]:&]
[s0; &]
[s7; for(int i `= 0; i < v.GetCount(); i`+`+)&]
[s7; -|LOG(v`[i`]);&]
[s0; &]
[s17; 1&]
[s17; 2&]
[s17; 3&]
[s0; &]
[s5; Есть возможность прямо добавлять 
элементы в [*C@5 Value], если оно содержит 
[*C@5 ValueArray]:&]
[s0; &]
[s7; v.Add(4);&]
[s7; &]
[s7; DUMP(v);&]
[s0; &]
[s17; v `= `[1, 2, 3, 4`]&]
[s0; &]
[s5; Или даже получать ссылку на элемент 
по какому`-либо индексу (с [^topic`:`/`/Core`/srcdoc`/ValueReference`_ru`-ru^ о
собыми правилами]):&]
[s0; &]
[s7; v.At(0) `= 111;&]
[s7; &]
[s7; DUMP(v);&]
[s0; &]
[s17; v `= `[111, 2, 3, 4`]&]
[s0; &]
[s5; [*C@5 ValueMap] может хранить пары ключ`-значение 
и быстро получать значение по ключу. 
Заметьте, что ключи не ограничиваются 
типом [*C@5 String], но могут быть любыми 
[*C@5 Value], с [*C@5 operator`=`=] и определением 
хэш`-кода.&]
[s5; Метод[*C@5  Add] или [*C@5 operator()] добавляют 
данные в [*C@5 ValueMap]:&]
[s0; &]
[s7; ValueMap m;&]
[s7; &]
[s7; m.Add(`"one`", 1);&]
[s7; m(`"two`", 2)(`"three`", 3);&]
[s7; &]
[s7; DUMP(m);&]
[s0; &]
[s17; m `= `{ one: 1, two: 2, three: 3 `}&]
[s0; &]
[s5; [*C@5 operator`[`]] получает значение по ключу:&]
[s0; &]
[s7; DUMP(m`[`"two`"`]);&]
[s0; &]
[s17; m`[`"two`"`] `= 2&]
[s0; &]
[s5; Когда ключ отсутствует в map`'е, [*C@5 operator`[`]] 
возвращает void (пустое) Value (которое 
также является Null):&]
[s0; &]
[s7; DUMP(m`[`"key`"`]);&]
[s7; DUMP(m`[`"key`"`].IsVoid());&]
[s7; DUMP(IsNull(m`[`"key`"`]));&]
[s0; &]
[s17; m`[`"key`"`] `= &]
[s17; m`[`"key`"`].IsVoid() `= true&]
[s17; IsNull(m`[`"key`"`]) `= true&]
[s0; &]
[s5; Подобно [*C@5 VectorMap], [*C@5 ValueMap] упорядочен, 
поэтому порядок добавления в него 
пар имеет значение:&]
[s0; &]
[s7; ValueMap m2;&]
[s7; &]
[s7; m2.Add(`"two`", 2);&]
[s7; m2(`"one`", 1)(`"three`", 3);&]
[s7; &]
[s7; DUMP(m2);&]
[s7; DUMP(m `=`= m2); // different order of adding means they are 
not equal&]
[s0; &]
[s17; m2 `= `{ two: 2, one: 1, three: 3 `}&]
[s17; m `=`= m2 `= false&]
[s0; &]
[s5; Тест на равенство `'Unordered`' можно выполнить 
посредством [*C@5 IsSame]:&]
[s0; &]
[s7; DUMP(m.IsSame(m2));&]
[s0; &]
[s17; m.IsSame(m2) `= true&]
[s0; &]
[s5; Итерирование по ValueMap может быть достигнуто 
через [*C@5 GetCount], [*C@5 GetKey] и [*C@5 GetValue]:&]
[s0; &]
[s7; for(int i `= 0; i < m.GetCount(); i`+`+)&]
[s7; -|LOG(m.GetKey(i) << `" `= `" << m.GetValue(i));&]
[s0; &]
[s17; one `= 1&]
[s17; two `= 2&]
[s17; three `= 3&]
[s0; &]
[s5; Можно получить [*C@5 ValueArray] из значений:&]
[s0; &]
[s7; LOG(m.GetValues());&]
[s0; &]
[s17; `[1, 2, 3`]&]
[s0; &]
[s5; [*C@5 GetKeys] получает константную ссылку 
на [*C@5 Index<Value>] ключей:&]
[s0; &]
[s7; LOG(m.GetKeys());&]
[s0; &]
[s17; `[one, two, three`]&]
[s0; &]
[s5; Значение изменяется посредством 
[*C@5 Set]:&]
[s0; &]
[s7; m.Set(`"two`", 4);&]
[s7; &]
[s7; DUMP(m);&]
[s0; &]
[s17; m `= `{ one: 1, two: 4, three: 3 `}&]
[s0; &]
[s5; Значение ключа изменяется посредством 
[*C@5 SetKey]:&]
[s0; &]
[s7; m.SetKey(1, `"four`");&]
[s7; &]
[s7; DUMP(m);&]
[s0; &]
[s17; m `= `{ one: 1, four: 4, three: 3 `}&]
[s0; &]
[s5; Можно получить ссылку на значение 
по ключу, (с [^topic`:`/`/Core`/srcdoc`/ValueReference`_ru`-ru^ особым
и правилами]) посредством [*C@5 GetAdd] или 
[*C@5 operator()]:&]
[s0; &]
[s7; Value`& h `= m(`"five`");&]
[s7; &]
[s7; h `= 5;&]
[s7; &]
[s7; DUMP(m);&]
[s0; &]
[s17; m `= `{ one: 1, four: 4, three: 3, five: 5 `}&]
[s0; &]
[s5; Когда ValueMap сохраняется в Value, [*C@5 operator`[`](String)] 
предоставляет доступ к значению по 
ключу. Заметьте, что это сужает ключи 
до текстовых значений:&]
[s0; &]
[s7; v `= m;&]
[s7; DUMP(v);&]
[s7; DUMP(v`[`"five`"`]);&]
[s0; &]
[s17; v `= `{ one: 1, four: 4, three: 3, five: 5 `}&]
[s17; v`[`"five`"`] `= 5&]
[s0; &]
[s5; [*C@5 Value`::GetAdd] и [*C@5 Value`::operator()] предоставляют 
ссылку на значение по ключу, с [^topic`:`/`/Core`/srcdoc`/ValueReference`_ru`-ru^ о
собыми правилами]:&]
[s0; &]
[s7; v.GetAdd(`"newkey`") `= `"foo`";&]
[s7; v(`"five`") `= `"FIVE`";&]
[s7; &]
[s7; DUMP(v);&]
[s0; &]
[s17; v `= `{ one: 1, four: 4, three: 3, five: FIVE, newkey: foo `}&]
[s0; &]
[s5; [*C@5 ValueMap] и [*C@5 ValueArray] взаимоконвертируемы. 
При присваивании [*C@5 ValueMap] к [*C@5 ValueArray], 
просто используются значения:&]
[s0; &]
[s7; ValueArray v2 `= m;&]
[s7; &]
[s7; DUMP(v2);&]
[s0; &]
[s17; v2 `= `[1, 4, 3, 5`]&]
[s0; &]
[s5; При присваивании [*C@5 ValueArray] к [*C@5 ValueMap], 
устанавливаются ключи как индексы 
элементов:&]
[s0; &]
[s7; ValueMap m3 `= v2;&]
[s7; &]
[s7; DUMP(m3);&]
[s0; &]
[s17; m3 `= `{ 0: 1, 1: 4, 2: 3, 3: 5 `}&]
[s0; &]
[s5; Базовые типы [*C@5 Value] `- [*C@5 int], [*C@5 String], 
[*C@5 ValueArray] и [*C@5 ValueMap `-] могут быть представлены 
в JSON:&]
[s0; &]
[s7; Value j `= ParseJSON(`"`{ `\`"array`\`" : `[ 1, 2, 3 `] `}`");&]
[s7; &]
[s7; DUMP(j);&]
[s0; &]
[s17; j `= `{ array: `[1, 2, 3`] `}&]
[s0; &]
[s0; &]
[s7; j(`"value`") `= m;&]
[s7; &]
[s7; DUMP(AsJSON(j));&]
[s0; &]
[s17; AsJSON(j) `= `{`"array`":`[1,2,3`],`"value`":`{`"one`":1,`"four`":4,`"three`":3,`"fiv
e`":5`}`}&]
[s0; &]
[s0; &]
[s7; j(`"array`").At(1) `= ValueMap()(`"key`", 1);&]
[s7; &]
[s7; DUMP(AsJSON(j));&]
[s0; &]
[s17; AsJSON(j) `= `{`"array`":`[1,`{`"key`":1`},3`],`"value`":`{`"one`":1,`"four`":4,`"thr
ee`":3,`"five`":5`}`}&]
[s0; &]
[s22;:Chapter`_6: [@3 6. Функция и лямбды]&]
[s3;:Section`_6`_1: [@(128.0.255) 6.1 Function]&]
[s5; U`+`+ [*C@5 Function] весьма подобна [*C@5 std`::function] 
`- это обёртка функции, способная хранить/коп
ировать/вызывать любую `"вызывабельную`" 
цель. Есть два важных различия. Во`-первых, 
вызов пустой [*C@5 Function] есть NOP, если 
[*C@5 Function] имеет тип возврата [*C@5 T], она 
возвращает [*C@5 T()]. Во`-вторых, [*C@5 Function] 
позволяет эффективно сцеплять `"вызывабельн
ые`" цели, используя [*C@5 operator<<;] если 
у [*C@5 Function] есть тип возврата, то используется 
тип возврата последнего приставленного 
`"вызывабельного`".&]
[s5; Обычно, `"вызывабельной`" целью является 
лямбда C`+`+11:&]
[s0; &]
[s7; Function<int (int)> fn `= `[`](int n) `{ LOG(`"Called A`"); 
return 3 `* n; `};&]
[s7; &]
[s7; LOG(`"About to call function`");&]
[s7; int n `= fn(7);&]
[s7; DUMP(n);&]
[s0; &]
[s17; About to call function&]
[s17; Called A&]
[s17; n `= 21&]
[s0; &]
[s5; Если приторочить ещё одну лямбду 
в [*C@5 Function], будут вызываться все, но 
использовано будет возвратное значение 
самой последней:&]
[s0; &]
[s7; fn << `[`](int n) `{ LOG(`"Called B`"); return n `* n; `};&]
[s7; LOG(`"About to call combined function`");&]
[s7; n `= fn(7);&]
[s7; DUMP(n);&]
[s0; &]
[s17; About to call combined function&]
[s17; Called A&]
[s17; Called B&]
[s17; n `= 49&]
[s0; &]
[s5; Вызов пустой лямбды ничего нед делает, 
возвращается дефолтно сконструированное 
возвратное значение. Это очень употребимо 
ГИП`-классами, у которых множество 
выводных событий, представленных 
[*C@5 Function], которая зачастую не присваивается 
ни к какому действию.&]
[s0; &]
[s7; fn.Clear();&]
[s7; LOG(`"About to call empty function`");&]
[s7; n `= fn(7);&]
[s7; DUMP(n);&]
[s0; &]
[s17; About to call empty function&]
[s17; n `= 0&]
[s0; &]
[s5; В то время как использование [*C@5 Function] 
с лямбда`-выражением обще распространено, 
можно использовать любую цель (target), 
у которой определён соответствующий 
[*C@5 operator()]:&]
[s0; &]
[s7; struct Functor `{&]
[s7; -|int operator()(int x) `{ LOG(`"Called Foo`"); return x % 2; 
`}&]
[s7; `};&]
[s7; &]
[s7; fn `= Functor();&]
[s7; LOG(`"About to call Functor`");&]
[s7; n `= fn(7);&]
[s7; DUMP(n);&]
[s0; &]
[s17; About to call Functor&]
[s17; Called Foo&]
[s17; n `= 1&]
[s0; &]
[s5; Так как наиболее часто используются 
[*C@5 Function] с типами возврата [*C@5 void] и [*C@5 bool,] 
U`+`+ определяет шаблонные алиасы [*C@5 Event]:&]
[s0; &]
[s7; Event<> ev `= `[`] `{ LOG(`"Вызвано Событие`"); 
`};&]
[s7; &]
[s7; ev();&]
[s0; &]
[s17; Вызвано Событие&]
[s0; &]
[s5; и [*C@5 Gate]:&]
[s0; &]
[s7; Gate<int> gt `= `[`](int x) `{ LOG(`"Gate invoked with `" << 
x); return x < 10; `};&]
[s7; &]
[s7; bool b `= gt(9);&]
[s7; DUMP(b);&]
[s7; b `= gt(10);&]
[s7; DUMP(b);&]
[s0; &]
[s17; Gate invoked with 9&]
[s17; b `= true&]
[s17; Gate invoked with 10&]
[s17; b `= false&]
[s0; &]
[s5; Использование лямбды для определения 
вызово методов с большим числом параметров 
может быть verbose и error`-prone. Эту проблему 
можно упростить использованием макроса 
[*C@5 THISFN]:&]
[s0; &]
[s7; struct Foo `{&]
[s7; -|void Test(int a, const String`& b) `{ LOG(`"Foo`::Test `" << 
a << `", `" << b); `}&]
[s7; -|&]
[s7; -|typedef Foo CLASSNAME; // required for THISFN&]
[s7; -|&]
[s7; -|void Do() `{&]
[s7; -|-|Event<int, const String`&> fn;&]
[s7; -|-|&]
[s7; -|-|fn `= `[`=`](int a, const String`& b) `{ Test(a, b); `};&]
[s7; -|-|fn(1, `"using lambda`");&]
[s7; -|-|&]
[s7; -|-|fn `= THISFN(Test); // this is functionally equivalent, but 
less verbose&]
[s7; -|-|fn(2, `"using THISFN`");&]
[s7; -|`}&]
[s7; `};&]
[s7; &]
[s7; Foo f;&]
[s7; f.Do();&]
[s0; &]
[s17; Foo`::Test 1, using lambda&]
[s17; Foo`::Test 2, using THISFN&]
[s0; &]
[s3;H4;:Section`_6`_2: [@(128.0.255) 6.2 Захват контейнеров 
U`+`+ в лямбды]&]
[s5; Захвата объектов с семантикой pick/clone 
может быть достигнуто посредством 
[/ захвата с инициализатором]:&]
[s0; &]
[s7; Vector<int> x`{ 1, 2 `};&]
[s7; Array<String> y`{ `"one`", `"two`" `};&]
[s7; Event<> ev `= `[x `= pick(x), y `= clone(y)`] `{ DUMP(x); DUMP(y); 
`};&]
[s7; &]
[s7; DUMP(x); // x is picked, so empty&]
[s7; DUMP(y); // y was cloned, so it retains original value&]
[s7; &]
[s7; LOG(`"About to invoke event`");&]
[s7; &]
[s7; ev();&]
[s0; &]
[s17; x `= `[`]&]
[s17; y `= `[one, two`]&]
[s17; About to invoke event&]
[s17; x `= `[1, 2`]&]
[s17; y `= `[one, two`]&]
[s0; &]
[s22;:Chapter`_7: [@3 7. Многопоточность]&]
[s3;:Section`_7`_1: 7.1 [C@5 Thread]&]
[s5; С C`+`+11 появилась резонная поддержка 
потоков (`"нитей`") в стандартной библиотеке. 
Но есть, однако, причины использовать 
вместо неё потоки U`+`+. Одна из них 
в том, что высокопроизводительный 
аллокатор памяти U`+`+  требует очищающего 
вызова на выходе потока, который, 
естественно, реализован в [*C@5 Upp`::Thread]. 
Второй `'веской`' причиной является 
компилятор Microsoft, использующий функцию 
Win32 API  для переменной условия, которая 
недоступна для Windows XP, в то время как 
у U`+`+ есть альтернативная реализация 
для Windows XP, что делает исполнимый совместимым
.&]
[s5; Кроме того, считаем, что в U`+`+ поддержка 
многопоточности / параллельного программиро
вания проще в использовании и приводит 
к более высокой производительности...&]
[s5; Класс[*C@5  Thread]  может запускать поток 
и позволяет запуску потока ждать 
([*C@5 Wait) ]его выполнения:&]
[s0; &]
[s7; Thread t;&]
[s7; t.Run(`[`] `{&]
[s7; -|for(int i `= 0; i < 10; i`+`+) `{&]
[s7; -|-|LOG(`"В потоке `" << i);&]
[s7; -|-|Sleep(100);&]
[s7; -|`}&]
[s7; -|LOG(`"Поток завершается...`");&]
[s7; `});&]
[s7; for(int i `= 0; i < 5; i`+`+) `{&]
[s7; -|LOG(`"В главном потоке `" << i);&]
[s7; -|Sleep(100);&]
[s7; `}&]
[s7; LOG(`"В ожидании финиша потока`");&]
[s7; t.Wait();&]
[s7; LOG(`"Ожидание потока выполнено`");&]
[s0; &]
[s17; В главном потоке 0&]
[s17; В потоке 0&]
[s17; В потоке 1&]
[s17; В главном потоке 1&]
[s17; В главном потоке 2&]
[s17; В потоке 2&]
[s17; В главном потоке 3&]
[s17; В потоке 3&]
[s17; В главном потоке 4&]
[s17; В потоке 4&]
[s17; В ожидании финиша потока&]
[s17; В потоке 5&]
[s17; В потоке 6&]
[s17; В потоке 7&]
[s17; В потоке 8&]
[s17; В потоке 9&]
[s17; Поток завершается...&]
[s17; Ожидание потока выполнено&]
[s0; &]
[s5; Деструктор[*C@5  Thread] вызывает метод 
[*C@5 Detach] с `'отключением`' [*C@5 Thread] от потока. 
Поток продолжает выполняться.&]
[s5; Статический метод[*C@5  Thread`::Start] запускает 
поток без возможности ожидания его 
завершения; если требуется подождать, 
нужно использовать другие методы:&]
[s0; &]
[s7; bool x `= false;&]
[s7; &]
[s7; Thread`::Start(`[`&x`] `{ LOG(`"In the Started thread`"); x `= 
true; `});&]
[s7; &]
[s7; LOG(`"About to wait for thread to finish`");&]
[s7; while(!x) `{ Sleep(1); `} // Do not do this in real code!&]
[s7; LOG(`"Wait for thread done`");&]
[s0; &]
[s17; About to wait for thread to finish&]
[s17; In the Started thread&]
[s17; Wait for thread done&]
[s0; &]
[s5; (используемый здесь метод ужасен, 
но должен продемонстрировать данный 
пункт).&]
[s3;H4;:Section`_7`_2: 7.2 [C@5 Mutex]&]
[s5; Mutex (`"mutual exclusion`" `- взаимное исключение) 
`- хорошо известное понятие из многопоточног
о программирования: Когда несколько 
потоков пишут и читают одни и те же 
данные, доступ нужно сериализовать 
с помощью Mutex. Следующий неправильный 
код показывает, почему:&]
[s0; &]
[s7; Thread t;&]
[s7; &]
[s7; int sum `= 0;&]
[s7; t.Run(`[`&sum`] `{&]
[s7; -|for(int i `= 0; i < 1000000; i`+`+)&]
[s7; -|-|sum`+`+;&]
[s7; `});&]
[s7; &]
[s7; for(int i `= 0; i < 1000000; i`+`+)&]
[s7; -|sum`+`+;&]
[s7; &]
[s7; t.Wait();&]
[s7; DUMP(sum);&]
[s0; &]
[s17; sum `= 1631489&]
[s0; &]
[s5; В то время как ожидаемое значение 
равно 2000000, произведёное значение 
другое. Проблема состоит в том, что 
чтение /изменение /запись значения 
[*C@5 sum] в обоих потоках выполняется 
без блокировки. Применение [*C@5 Mutex] 
блокирует [*C@5 sum], и, таким образом, сериализует
 доступ к ней `- последовательность 
чтение/ изменение / запись теперь 
выполняется исключительно для потока, 
который заблокировал [*C@5 Mutex], чем решил 
проблему. [*C@5 Mutex] может блокироваться 
/ разблокироваться методами [*C@5 Enter] 
/ [*C@5 Leave]. Альтернативно, вспомогательный 
класс [*C@5 Mutex`::Lock] блокирует [*C@5 Mutex] в 
своём конструкторе и разблокирует 
в деструкторе:&]
[s0; &]
[s7; Mutex m;&]
[s7; sum `= 0;&]
[s7; t.Run(`[`&sum, `&m`] `{&]
[s7; -|for(int i `= 0; i < 1000000; i`+`+) `{&]
[s7; -|-|m.Enter();&]
[s7; -|-|sum`+`+;&]
[s7; -|-|m.Leave();&]
[s7; -|`}&]
[s7; `});&]
[s7; &]
[s7; for(int i `= 0; i < 1000000; i`+`+) `{&]
[s7; -|Mutex`::Lock `_`_(m); // Блокирует m до конца 
масштаба(scope)&]
[s7; -|sum`+`+;&]
[s7; `}&]
[s7; &]
[s7; t.Wait();&]
[s7; DUMP(sum);&]
[s0; &]
[s17; sum `= 2000000&]
[s0; &]
[s3;H4;:Section`_7`_3: 7.3 [C@5 ConditionVariable]&]
[s5; [*C@5 ConditionVariable] в целом является примитивом 
синхронизации, используемым для блокировки/
пробуждения потока. [*C@5 ConditionVariable] ассоциирова
на с [*C@5 Mutex,] используемым для защиты 
данных; в блокируемом потоке [*C@5 Mutex] 
выполняет блокировку; при вызове 
[*C@5 Wait] автоматически разблокируется 
[*C@5 Mutex] и поток входит в ожидание. Затем 
другой поток может возобновить этот 
поток, вызвав [*C@5 Signal], который опять 
заставляет [*C@5 Mutex] заблокироваться. 
Несколько потоков могут ожидать единую 
[*C@5 ConditionVariable]; [*C@5 Signal] возобновляет 
единичный ждущий поток, [*C@5 Brodcast] возобновляет
 все ждущие потоки.&]
[s0; &]
[s7; bool  stop `= false;&]
[s7; BiVector<int> data;&]
[s7; Mutex m;&]
[s7; ConditionVariable cv;&]
[s7; &]
[s7; Thread t;&]
[s7; t.Run(`[`&stop, `&data, `&m, `&cv`] `{&]
[s7; -|Mutex`::Lock `_`_(m);&]
[s7; -|for(;;) `{&]
[s7; -|-|while(data.GetCount()) `{&]
[s7; -|-|-|int q `= data.PopTail();&]
[s7; -|-|-|LOG(`"Data received: `" << q);&]
[s7; -|-|`}&]
[s7; -|-|if(stop)&]
[s7; -|-|-|break;&]
[s7; -|-|cv.Wait(m);&]
[s7; -|`}&]
[s7; `});&]
[s7; &]
[s7; for(int i `= 0; i < 10; i`+`+) `{&]
[s7; -|`{&]
[s7; -|-|Mutex`::Lock `_`_(m);&]
[s7; -|-|data.AddHead(i);&]
[s7; -|`}&]
[s7; -|cv.Signal();&]
[s7; -|Sleep(1);&]
[s7; `}&]
[s7; stop `= true;&]
[s7; cv.Signal();&]
[s7; t.Wait();&]
[s0; &]
[s17; Data received: 0&]
[s17; Data received: 1&]
[s17; Data received: 2&]
[s17; Data received: 3&]
[s17; Data received: 4&]
[s17; Data received: 5&]
[s17; Data received: 6&]
[s17; Data received: 7&]
[s17; Data received: 8&]
[s17; Data received: 9&]
[s0; &]
[s5; Важное замечание: едва ли поток восстановитс
я после [*C@5 Wait], даже если никто другой 
не вызовет [*C@5 Signal]. Это не баг, а [^https`:`/`/en`.wikipedia`.org`/wiki`/Spurious`_wakeup^ д
изайнерское решение из соображений 
производительности]. На практике 
это означает только то, что ситуацию 
нужно (пере)проверить после возобновления.&]
[s3;H4;:Section`_7`_4: 7.4 [C@5 CoWork]&]
[s5; [*C@5 CoWork] предназначен для использования 
когда поток используем для ускорения 
путём распределения задачи на несколько 
ядер ЦПБ. [*C@5 CoWork] spans единый набор рабочих 
потоков, который существует на всём 
протяжении выполнения программы. 
Экземпляры [*C@5 CoWork] затем управляют 
присваиванием задач этим рабочим 
потокам и ожиданием завершения всей 
работы.&]
[s5; Единицы работы [*C@5 CoWork] представлены 
[*C@5 Function<void ()>] и, таким образом, могут 
записываться инлайн как лямбды.&]
[s5; В качестве примера,`- следующий код, 
по строкам, считывает вводный файл, 
разбивает строки на слова (это `"параллелиров
анная`" (запараллеленная!) работа), 
и затем добавляет итоговые слова 
в [*C@5 Index]:&]
[s0; &]
[s7; FileIn in(GetDataFile(`"test.txt`")); // откроем какие`-нибудь
 учебные тестовые данные&]
[s7; &]
[s7; Index<String> w;&]
[s7; Mutex m; // мютекс (`"стопор`") необходим 
для сериализации доступа к w&]
[s7; &]
[s7; CoWork co;&]
[s7; while(!in.IsEof()) `{&]
[s7; -|String ln `= in.GetLine();&]
[s7; -|co `& `[ln, `&w, `&m`] `{&]
[s7; -|-|Vector<String> h `= Split(ln, `[`](int c) `{ return IsAlpha(c) 
? 0 : c; `});&]
[s7; -|-|Mutex`::Lock `_`_(m);&]
[s7; -|-|for(const auto`& s : h)&]
[s7; -|-|-|w.FindAdd(s);&]
[s7; -|`};&]
[s7; `}&]
[s7; co.Finish();&]
[s7; &]
[s7; DUMP(w);&]
[s0; &]
[s17; w `= `[Lorem, ipsum, dolor, sit, amet, consectetur, adipiscing, 
elit, sed, do, eiusmod, tempor, incididunt, ut, labore, et, dolore, 
magna, aliqua, Ut, enim, ad, minim, veniam, quis, nostrud, exercitation, 
ullamco, laboris, nisi, aliquip, ex, ea, commodo, consequat, 
esse, cillum, eu, fugiat, nulla, pariatur, Excepteur, Duis, aute, 
irure, in, reprehenderit, voluptate, velit, officia, deserunt, 
mollit, anim, id, est, laborum, sint, occaecat, cupidatat, non, 
proident, sunt, culpa, qui`]&]
[s0; &]
[s5; Добавление слов в [*C@5 w] требует [*C@5 Mutex`'а]. 
Альтернативой этому `'собирающему 
результаты`' [*C@5 Mutex`'у] является [*C@5 CoWork`::FinLock]. 
За этим кроется идея, что CoWork требуется 
внутренний [*C@5 Mutex], чтобы сериализовать 
доступ к общим данным, вот почему 
[*C@5 FinLock] блокирует этот внутренний 
стопор немного раньше, сберегая циклы 
ЦПБ, необходимые на блокировку и разблокиров
ку используемого мютекса. С точки 
зрения контракта API (ИПП), можно рассмотреть 
[*C@5 FinLock] в качестве сериализатора кода 
до конца `"работы работяги`" (the worker 
job).&]
[s0; &]
[s7; in.Seek(0);&]
[s7; while(!in.IsEof()) `{&]
[s7; -|String ln `= in.GetLine();&]
[s7; -|co `& `[ln, `&w, `&m`] `{&]
[s7; -|-|Vector<String> h `= Split(ln, `[`](int c) `{ return IsAlpha(c) 
? 0 : c; `});&]
[s7; -|-|CoWork`::FinLock(); // заменяет мютекс, блокирован 
до конца работы CoWork&]
[s7; -|-|for(const auto`& s : h)&]
[s7; -|-|-|w.FindAdd(s);&]
[s7; -|`};&]
[s7; `}&]
[s7; co.Finish();&]
[s7; &]
[s7; DUMP(w);&]
[s0; &]
[s17; w `= `[Lorem, ipsum, dolor, sit, amet, consectetur, adipiscing, 
elit, sed, do, eiusmod, tempor, incididunt, ut, labore, et, dolore, 
magna, aliqua, Ut, enim, ad, minim, veniam, quis, nostrud, exercitation, 
ullamco, laboris, nisi, aliquip, ex, ea, commodo, consequat, 
esse, cillum, eu, fugiat, nulla, pariatur, Excepteur, Duis, aute, 
irure, in, reprehenderit, voluptate, velit, officia, deserunt, 
mollit, anim, id, est, laborum, sint, occaecat, cupidatat, non, 
proident, sunt, culpa, qui`]&]
[s0; &]
[s5; Конечно, код, выполняемый после [*C@5 FinLock, 
]не может продолжаться долго, иначе 
будет негативное влияние на все экземпляры 
[*C@5 CoWork]. Фактически, с этой точки зрения, 
код выще, вероятно, превышвет этот 
порог...&]
[s5; Когда в [*C@5 CoWork ]выводится исключение, 
оно распространяется на поток, который 
вызывает [*C@5 Finish] и [*C@5 CoWork] прекращается. 
Если исключение бросает не единственная 
`"работа`" (job), в таком случае случайно 
выбирается одно из исключений, которое 
повторно выбрасывается в Finish.&]
[s5; Так как деструктор [*C@5 CoWork] тоже вызывает 
[*C@5 Finish], можно сделать так, чтобы оно 
выводилось деструктором, но это то, 
что в  C`+`+ делать не рекомендуется, 
но отлично определено и в данном случае 
является наиболее уместной опцией:&]
[s0; &]
[s7; in.Seek(0);&]
[s7; try `{&]
[s7; -|while(!in.IsEof()) `{&]
[s7; -|-|String ln `= in.GetLine();&]
[s7; -|-|co `& `[ln, `&w, `&m`] `{&]
[s7; -|-|-|if(ln.GetCount() > 75)&]
[s7; -|-|-|-|throw `"Input line was too long!`";&]
[s7; -|-|-|Vector<String> h `= Split(ln, `[`](int c) `{ return IsAlpha(c) 
? 0 : c; `});&]
[s7; -|-|-|CoWork`::FinLock(); // replaces the mutex, locked till the 
end of CoWork job&]
[s7; -|-|-|for(const auto`& s : h)&]
[s7; -|-|-|-|w.FindAdd(s);&]
[s7; -|-|`};&]
[s7; -|`}&]
[s7; -|co.Finish();&]
[s7; `}&]
[s7; catch(const char `*exception) `{&]
[s7; -|DUMP(exception);&]
[s7; `}&]
[s0; &]
[s5; Иногда требуется прервать всю [*C@5 CoWork]. 
Метод [*C@5 Cancel] отменяет все запланированные 
роботы, которые пока ещё не выполнялись, 
и устанавливает [*C@5 CoWork] в отменённое 
состояние, которое можно проверить 
в процедуре работы с помощью [*C@5 CoWork`::IsCanceled]:&]
[s0; &]
[s7; for(int i `= 0; i < 100; i`+`+)&]
[s7; -|co `& `[`] `{&]
[s7; -|-|for(;;) `{&]
[s7; -|-|-|if(CoWork`::IsCanceled()) `{&]
[s7; -|-|-|-|LOG(`"Job was canceled`");&]
[s7; -|-|-|-|return;&]
[s7; -|-|-|`}&]
[s7; -|-|-|Sleep(1);&]
[s7; -|-|`}&]
[s7; -|`};&]
[s7; Sleep(200); // Give CoWork a chance to start some jobs&]
[s7; co.Cancel();&]
[s0; &]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s17; Job was canceled&]
[s0; &]
[s5; Отмена CoWork в ГИП`-проиложениях довольно 
распространена.&]
[s3;H4;:Section`_7`_5: 7.5 [C@5 AsyncWork]&]
[s5; [*C@5 AsyncWork] `- это инструмент, основанный 
на [*C@5 CoWork], напоминающий std`::future. Экземпляры 
[*C@5 AsyncWork] создаются посредством функции 
[*C@5 Async] и представляют собой работу, 
которая может выполняться параллельно 
с текущим потоком. [*C@5 AsyncWork] поддерживает 
возврат значений. Вызов [*C@5 AsyncWork`::Get] 
гарантирует, что рабочая процедура 
завершена, и выводит возвратное значение 
(если оно имеется):&]
[s0; &]
[s7; auto a `= Async(`[`](int n) `-> double `{&]
[s7; -|double f `= 1;&]
[s7; -|for(int i `= 2; i <`= n; i`+`+)&]
[s7; -|-|f `*`= i;&]
[s7; -|return f;&]
[s7; `}, 100);&]
[s7; &]
[s7; DUMP(a.Get());&]
[s0; &]
[s17; a.Get() `= 9.33262154439441e157&]
[s0; &]
[s5; Исключения, выбрасываемые при работе 
Async, пропагируются на вызов [*C@5 Get]:&]
[s0; &]
[s7; auto b `= Async(`[`] `{ throw `"error`"; `});&]
[s7; &]
[s7; try `{&]
[s7; -|b.Get();&]
[s7; `}&]
[s7; catch(...) `{&]
[s7; -|LOG(`"Exception has been caught`");&]
[s7; `}&]
[s0; &]
[s17; Exception has been caught&]
[s0; &]
[s5; Экземпляры[*C@5  AsyncWork] можно отменять 
(и они отменяются в деструкторе, если 
к ним не прилагается вызов Get):&]
[s0; &]
[s7; `{&]
[s7; -|auto c `= Async(`[`] `{&]
[s7; -|-|for(;;)&]
[s7; -|-|-|if(CoWork`::IsCanceled()) `{&]
[s7; -|-|-|-|LOG(`"Work was canceled`");&]
[s7; -|-|-|-|break;&]
[s7; -|-|-|`}&]
[s7; -|`});&]
[s7; -|Sleep(100); // give it chance to start&]
[s7; -|// c destructor cancels the work (can be explicitly canceled 
by Cancel method too)&]
[s7; `}&]
[s0; &]
[s17; Work was canceled&]
[s0; &]
[s3;H4;:Section`_7`_6: [@(128.0.255) 7.6 CoPartition]&]
[s5; Это некая перегрузка, связанная с 
рабочими потоками CoWork. Это и причина, 
по которой, например, выполнение простой 
операции над массивом, когда вызывается 
(spawning) рабочий поток для каждого элемента, 
не является хорошей идее, с точки 
зрения производительности:&]
[s0; &]
[s7; Vector<int> data;&]
[s7; for(int i `= 0; i < 10000; i`+`+)&]
[s7; -|data.Add(i);&]
[s7; &]
[s7; int sum `= 0;&]
[s7; &]
[s7; CoWork co;&]
[s7; for(int i `= 0; i < data.GetCount(); i`+`+)&]
[s7; -|co `& `[i, `&sum, `&data`] `{ CoWork`::FinLock(); sum `+`= data`[i`]; 
`};&]
[s7; co.Finish();&]
[s7; DUMP(sum);&]
[s0; &]
[s17; sum `= 49995000&]
[s0; &]
[s5; Код выше вычисляет сумму всех элементов 
в [*C@5 Vector`'е], для каждого элемента используетс
я работа CoWorker. Хотя  результат производится 
верно, вероятно, выполняться это будет 
медленнее, чем в однопоточной версии.&]
[s5; Решением является разбиение массива 
на небольшое число обширных поддиапазонов, 
обрабатываемых параллельно. Вот что 
делает шаблонный алгоритм [*C@5 CoPartition]:&]
[s0; &]
[s7; sum `= 0;&]
[s7; CoPartition(data, `[`&sum`](const auto`& subrange) `{&]
[s7; -|int partial`_sum `= 0;&]
[s7; -|for(const auto`& x : subrange)&]
[s7; -|-|partial`_sum `+`= x;&]
[s7; -|CoWork`::FinLock(); // доступно, так как CoPartition 
использует CoWork&]
[s7; -|sum `+`= partial`_sum;&]
[s7; `});&]
[s7; DUMP(sum);&]
[s0; &]
[s17; sum `= 49995000&]
[s0; &]
[s5; Заметьте, что CoWork внутренне продолжает 
использоваться, поэтому доступен 
[*C@5 CoWork`::FinLock]. Вместо работы над поддиапазонам
и, можно использовать итераторы:&]
[s0; &]
[s7; sum `= 0;&]
[s7; CoPartition(data.begin(), data.end(), `[`&sum`] (auto l, auto 
h) `{&]
[s7; -|int partial`_sum `= 0;&]
[s7; -|while(l !`= h)&]
[s7; -|-|partial`_sum `+`= `*l`+`+;&]
[s7; -|CoWork`::FinLock(); // доступно, так как CoPartition 
использует CoWork&]
[s7; -|sum `+`= partial`_sum;&]
[s7; `});&]
[s7; DUMP(sum);&]
[s0; &]
[s17; sum `= 49995000&]
[s0; &]
[s5; Поскольку нет никаких требований 
к типу итераторов, можно даже использовать 
просто индексы:&]
[s0; &]
[s7; sum `= 0;&]
[s7; CoPartition(0, data.GetCount(), `[`&sum, `&data`] (int l, int 
h) `{&]
[s7; -|int partial`_sum `= 0;&]
[s7; -|while(l !`= h)&]
[s7; -|-|partial`_sum `+`= data`[l`+`+`];&]
[s7; -|CoWork`::FinLock(); // доступно, так как CoPartition 
использует CoWork&]
[s7; -|sum `+`= partial`_sum;&]
[s7; `});&]
[s7; DUMP(sum);&]
[s0; &]
[s17; sum `= 49995000&]
[s0; &]
[s3;H4;:Section`_7`_7: [@(128.0.255) 7.7 CoDo]&]
[s5; Альтернативой [*C@5 CoPartition] является 
[*C@5 CoDo]. In this pattern, the job is simply started in all 
threads and the code is responsible for scheduling the work. 
[*C@5 CoDo] waits for all started threads to finish. Scheduling 
is the responsibility of client code, but can be easily managed 
using the std`::atomic counter. This way, the overhead associated 
with creating lambdas and scheduling them is kept to the minimum 
(basically the cost of atomic increment). Once again, CoDo is 
based on CoWork, so [*C@5 CoWork`::FinLock] is available.&]
[s0; &]
[s7; Vector<String> data;&]
[s7; for(int i `= 0; i < 100; i`+`+)&]
[s7; -|data.Add(AsString(1.0 / i));&]
[s7; &]
[s7; double sum `= 0;&]
[s7; &]
[s7; std`::atomic<int> ii(0);&]
[s7; &]
[s7; CoDo(`[`&`] `{&]
[s7; -|double m `= 0;&]
[s7; -|for(int i `= ii`+`+; i < data.GetCount(); i `= ii`+`+)&]
[s7; -|-|m `+`= atof(data`[i`]);&]
[s7; -|CoWork`::FinLock();&]
[s7; -|sum `+`= m;&]
[s7; `});&]
[s7; &]
[s7; DUMP(sum);&]
[s0; &]
[s17; sum `= 5.17737751763962&]
[s0; &]
[s3;H4;:Section`_7`_8: [@(128.0.255) 7.8 Параллельные алгоритмы]&]
[s5; U`+`+ provides a parallel versions of algorithms where it makes 
sense. The naming scheme is `'Co`' prefix before the name of 
algorithm designates the parallel version.&]
[s5; So the parallel version of e.g. [*C@5 FindIndex] is [*C@5 CoFindIndex], 
for [*C@5 Sort] it is [*C@5 CoSort]:&]
[s0; &]
[s7; Vector<String> x`{ `"zero`", `"one`", `"two`", `"three`", `"four`", 
`"five`" `};&]
[s7; &]
[s7; DUMP(FindIndex(x, `"two`"));&]
[s7; DUMP(CoFindIndex(x, `"two`"));&]
[s7; &]
[s7; CoSort(x);&]
[s7; DUMP(x);&]
[s0; &]
[s17; FindIndex(x, `"two`") `= 2&]
[s17; CoFindIndex(x, `"two`") `= 2&]
[s17; x `= `[five, four, one, three, two, zero`]&]
[s0; &]
[s5; Caution should be exercised when using these algorithms `- for 
small datasets, they are almost certainly slower than single`-threaded 
versions.&]
[s5; ]]