#ifndef _drx_RuCore_rustd_h_
#define _drx_RuCore_rustd_h_

#include <drxtypes.h>

extern "C"{

//Получить ид процесса.
цел дайпид();
          //getpid()
          
//Удалить файл.
цел удали(ткст фимя);
              // std::remove(фимя)
        
//Переименовать файл.
цел переименуй(ткст из, ткст в);
               // std::rename(из, в)
        
//Получить указатель на созданный временный файл.
фук времфл();
            //tmpfile()
       
//Получить имя для временного файла.
ткст времим(ткст s);
            // tmpnam(s)

//Закрыть открытый файл.
цел   закройфл(фук поток);
              // std::fclose(поток)
        
//Залить файл в поток.
цел   слейфл(фук поток);
              // std::fflush(поток)

//Открыть файл в указанном режиме доступа.
фук откройфл( ткст фимя, ткст режим);
               // std::fopen(фимя, режим)

//Повторно открыть файл в указанном режиме доступа по ранее
// полученному указателю.
фук переоткройфл(ткст фимя, ткст режим, фук поток);
                  // std::freopen(фимя, режим, поток)
        
//Отправить текст в буфер потока.
проц устбуффл(фук поток, ткст буф);
                    //std::setbuf(поток, буф)
    
//....................
цел  уствбуф(фук поток, ткст буф, цел режим, т_мера размер);
        // std::setvbuf(поток, буф, режим, размер)

//.....................
цел вфвыводф(фук поток, ткст формат, спис_ва арг);
        // vfprintf(поток, формат,арг)

//....................
цел вфсканф(фук поток, ткст формат, спис_ва арг);
        // vfscanf(поток, формат, арг)

//...................
цел всвыводф(ткст s, ткст формат, спис_ва арг);
        // vsprintf(s, формат, арг)

//...................
цел вссканф(ткст s, ткст формат, спис_ва арг);
        // vsscanf(s, формат, арг)

//...................
цел ввыводф(ткст формат, спис_ва арг);
        // vprintf(формат, арг)

//...................
цел всканф(ткст формат, спис_ва арг);
        // vscanf(формат, арг)

//...................
цел берисфл(фук поток);
        // fgetc(поток)

//...................
цел вставьсфл(цел c, фук поток);
        // fputc(c,поток)

//...................
ткст дайтфл(ткст s, цел n, фук поток);
        // fgets(s, n,поток)

//...................
цел   вставьтфл(ткст s, фук поток);
        // fputs(s, поток)

//...................
//ткст дайт(ткст s);
        // gets(s)
        
цел   вставьт(ткст s);
        // puts(s)

цел отдайс(цел c, фук поток);
        // ungetc(c, поток)

т_мера читайфл(ук указат, т_мера размер, т_мера nmemb, фук поток);
        // fread( указат, размер, nmemb, поток)
        
т_мера пишифл(ук указат, т_мера размер, т_мера nmemb, фук поток);
        // fwrite(указат, размер, nmemb, поток)

цел дайпозфл(фук поток, fpos_t *поз);
        // fgetpos(поток, поз)
        
цел устпозфл(фук поток, fpos_t *поз);
        // fsetpos(поток, поз)

цел    сместисьфл(фук поток, цел смещение, цел куда);
        // fseek(поток, смещение, куда)
        
цел скажифл(фук поток);
        // ftell(поток)

цел   вснвыводф(ткст s, т_мера n, ткст формат, спис_ва арг);
        // vsnprintf(s, n, формат, арг)

проц укошиб(ткст s);
        // perror(s)

цел     влеки(цел сиг);
        // raise(сиг)

цел числобукв_ли(шим c);
        // iswalnum(c)
        
цел буква_ли(шим c);
        // iswalpha(c)
        
цел пробел_ли(шим c);
        // iswblank(c)
        
цел управ_ли(шим c);
        // iswcntrl(c)
        
цел цифра_ли(шим c);
        // iswdigit(c)
        
цел граф_ли(шим c);
        // iswgraph(c)
        
цел проп_ли(шим c);
        // iswlower(c)
        
цел печат_ли(шим c);
        // iswprint(c)
        
цел пункт_ли(шим c);
        // iswpunct(c)
        
цел межбукв_ли(шим c);
        // iswspace(c)
        
цел заг_ли(шим c);
        // iswupper(c)
        
цел цифраикс_ли(шим c);
        // isxdigit(c)
        
цел впроп(шим c);
        // towlower(c)
        
цел взаг(шим c);
        // towupper(c)
        
шим    втрансш(шим ш, wctrans_t опис);
        // towctrans(ш, опис)
        
//шим трансш(wctrans_t свойство);
        // wctrans(свойство)

проц влекиисклфе(цел исклы);
    //feraiseexcept(исклы)
    
проц сотриисклфе(цел исклы);
    //feclearexcept(исклы)

цел тестисклфе(цел исклы);
        // fetestexcept(исклы)
цел задержиисклфе(т_фсред* средп);
        // feholdexcept((fenv_t*)средп)

проц дайфлагисклфе(цел* флагп, цел исклы);
    // fegetexceptflag((fexcept_t*) флагп, исклы)
    
проц устфлагисклфе(цел* флагп, цел исклы);
    // fesetexceptflag((fexcept_t*) флагп, исклы)

цел дайкругфе();
        // fegetround()
        
цел усткругфе(цел круг);
        // fesetround(круг)

проц дайсредфе(т_фсред* средп);
    //fegetenv((fenv_t*)средп)
    
проц устсредфе(т_фсред* средп);
    //fesetenv((fenv_t*) средп)
    
проц обновисредфе(т_фсред* средп);
    //feupdateenv((fenv_t*) средп)

ткст  устлокаль(цел категория, ткст локаль);
        // setlocale(категория, локаль)
        
лпреобр* преобрлокаль();
        // (лпреобр*) localeconv()

дво  алфнапз(ткст укнач);
        // atof(укнач)
        
цел     алфнац(ткст укнач);
        // atoi(укнач)
        
цел алфнадл(ткст укнач);
        // (цел) atol(укнач)
        
дол    алфнадлдл(ткст укнач);
        // atoll(укнач)

дво  стрнад(ткст укнач, ткст* укнакон);
        // strtod(укнач, укнакон)
        
плав   стрнапз(ткст укнач, ткст* укнакон);
        // strtof(укнач, укнакон)
        
реал    стрнадлд(ткст укнач, ткст* укнакон);
        // strtold(укнач, укнакон)
        
цел  стрнадл(ткст укнач, ткст* укнакон, цел ова);
        // (цел) strtol(укнач, укнакон, ова)
        
дол    стрнадлдл(ткст укнач, ткст* укнакон, цел ова);
        // strtoll(укнач, укнакон, ова)
        
бцел стрнабдл(ткст укнач, ткст* укнакон, цел ова);
        // (бцел) strtoul(укнач, укнакон, ова)
        
бдол   стрнабдлдл(ткст укнач, ткст* укнакон, цел ова);
        // strtoull(укнач, укнакон, ова)

//Генерировать случайное целое число (СЧ).
цел     случ();
        // rand()

//Задать "семя" генератору СЧ (т.е. ГСЧ).
проц    сслуч(бцел семя);
    //srand(семя)

//Получить указатель на размещение в памяти указанного числа байтов.
ук   празмести(т_мера разм);
        // malloc(разм)
        
//Комплексное размещение в память.
ук   кразмести(т_мера члочленов, т_мера разм);
        // calloc(члочленов, разм)

// Перемещает из указателя в указатель число байтов.
ук   перемести(ук указ, т_мера разм);
        // realloc(указ, разм)

//Удаляет из памяти ранее размещённое.
проц    освободи(ук указ);
    // free(указ)

проц    аборт();
    //abort()
//проц    выход(цел статус);
    // exit(статус)
//цел     навыходе(проц (*)(void) функц);
    // return atexit(функц)
проц    _Выход(цел статус);
    //_Exit(статус)

ткст   дайсреду(ткст имя);
        // getenv(имя)
        
цел     система(ткст текст);
        // system(текст)

цел     мбдлин(ткст s, т_мера n);
        // mblen(s, n)
цел     мбнашк(шткст pwc, кткст s, т_мера n);
        // mbtowc((wchar_t *)pwc, s, n)
цел     шкнамб(ткст s, шим wc);
        // wctomb(s,wc)
т_мера  мбтнашкт(шткст pwcs, ткст s, т_мера n);
        // mbstowcs((wchar_t *)pwcs, s, n)
т_мера  шктнамбт(ткст s, шткст pwcs, т_мера n);
        // wcstombs(s, (wchar_t *)pwcs, n)

ук разместа(т_мера разм);
        // alloca(разм); }// нестандартно

цел ширфл(фук поток, цел реж);
        // fwide( поток, реж)
/*
* memchr /ищисим/ ищет первый случай сим в
* строке, состоящей из члабайт буфера. Она
* останавливается, когда найдёт сим, либо
* проверив первое члобайт.
*/
ук ищисим(ук строка, цел симв, т_мера члобайт);
                    // memchr(строка, симв, члобайт)
/*
* memcmp /сравбуф/: Сравнение символов двух буферов.
* Если возврат < 0, то буф1 меньше буф2; возврат = 0, буферы идентичны;
* возврат > 0, буф1 больше буф2.
*/
цел сравбуф(ук буф1, ук буф2, т_мера члобайт);
                          // memcmp(буф1, буф2, члобайт)
/*
* memcpy /копирбуф/ копирует члобайт из истока в приёмник;
* если исток и приёмник накладываются, то поведение
* memcpy неопределено. Для обработки накладывающихся
* регионов лучше использовать memmove /перембуф/.
*/
ук копирбуф(ук приёмник, ук источник, т_мера члобайт);
                      //memcpy(приёмник, источник, члобайт)
/*
* memmove /перембуф/ копирует байты из откуда в куда.
* Если некоторые области исходной зоны и приёмной нахлёстываются,
* то гарантируется копирование исходных байтов из области
* накладки до того, как будет произведена перезапись.
*/
ук перембуф(ук куда, ук откуда, т_мера сколько);
                   //memmove(куда, откуда, сколько)
/*
* memset /устанбуф/ устанавливает первое чло символов приёмника
* где на символ сим.
*/
ук устбуф(ук куда, цел что, т_мера члосим);
                //memset(куда, что, члосим)
/*
* Функция strcpy /копиртекс/ копирует символы откуда,
* включая оканчивающий нуль, в место,
* указанное параметром куда. Поведение strcpy
* неопределено при накладке между источником и приёмником.
*/
ткст копиртекс(ткст куда, ткст откуда);
                      //strcpy(куда, откуда)
/*
* Функция strncpy /копирчтекс/ копирует начальное число символов
* из  откуда в куда, и возвращает куда. Если члосим меньше или
* равно длине откуда, то к копированной строке нулевой символ
* автоматически не добавляется. Если же члосим больше длины
* откуда, то принимающая строка заполняется на всю остаточную
* длину нулями. При накладке источника и приёмника поведение
* strncpy неопределено.
*/
ткст копирчтекс(ткст куда,ткст откуда, т_мера члосим);
                      //strncpy( куда, откуда, члосим )
/*
* Функция strcat /сотекс/ добавляет текст_плюс к ткст1,
* и завершает полученную строку нулевым символом.
* Начальный сивол текст_плюс переписывает конечный
* нулевой символ текст1. При накладке источника и
* приёмника поведение неопределено.
*/
ткст сотекс(ткст текст1, ткст текст_плюс);
                       //strcat(текст1, текст_плюс)
/*
* Функция strncat /сочтекс/ добавляет не более первого
* чласим ткст2 к ткст1. Начальный символ ткст2 переписывает
* конечный нулевой ткст1. Если до окончания добавления
* в стр2 попадается нулевой символ, то strncat добавляет
* все символы из ткст2, вплоть до нулевого. Если члосим
* больше длины ткст2, то эта длина ткст2 используется
* вместо члосим. Во всех случаях  получаемая строка
* оканчивается на нулевой символ. Если происходит копирование
* между налагающимися строками, то поведение её остаётся не выясненным.
*/
ткст сочтекс(ткст ткст1, ткст ткст2, т_мера члосим);
                         //strncat(ткст1, ткст2, члосим)
/*
* Сравнение символов двух строк. Функция strncmp /сравтекс/ сравнивает
* лексикографически текст1 и текст2 и возвращает значение, показывающее их
* взаимоотношение.
* Если возврат < 0, то текст1 меньше текст2; возврат = 0, тексты идентичны;
* возврат > 0, текст1 больше текст2.
*/
цел сравтекс(ткст текст1, ткст текст2);
                 // strcmp(текст1, текст2)

цел кодстрсравнитекс(ткст текст1, ткст текст2);
                           //strcoll(текст1, текст2)
/*
* Сравнение символов двух строк с использованием текущей локали
* или заданной локали. Функция strncmp /сравчтекс/ сравнивает
* лексикографически не более чем первые члосим в текст1 и текст2,
* и возвращает значение, показывающее взаимоотнощение между подстроками.
* strncmp - это регистрочувствительная версия _strnicmp.
*/
цел сравчтекс(ткст текст1, ткст текст2, т_мера члосим);
                             //strncmp(текст1, текст2, члосим)
/*
* Функция strxfrm /форматчтекс/ преобразует строку, указанную как
* из, в новую форму, сохраняемую в в. Преобразуется не более
* чла символов, включая и нулевой, который помещаются в
* результат. Трансформация происходит с применением
* установки категории LC_COLLATE локали.
*/
т_мера форматчтекс(ткст в, ткст из, т_мера чло);
                             //strxfrm(в, из, чло)
/*
* Функция strchr /найдипер/ находит первый случай с в строке т,
* либо возвращает NULL, если с не найден. В поиск включается и
* завершающий символ нуля.
*/
ткст  найдипер(ткст т, цел с);
                       //strchr(т, с)
/*
* strcspn /персиндекс/: Возвращает индекс первого случая символа
* что в строке где, который принадлежит к указанному в что
* набору символов.
*/
т_мера персинд (ткст где, ткст что);
                   //strcspn ( где, что)
/*
* Функция strpbrk /найдитексвнаб/ возвращает указатель на первый
* символ в строке вчём, принадлежащий набору символов
* из ряда изчего. Поиск не включает оканчивающего
* нулевого символа.
*/
ткст  найдитексвнаб(ткст вчём, ткст изчего);
                         //strpbrk( вчём, изчего )
/*
* Функция strrchr /найдипос/ находит последний случай символа сим
* (преобразованного в сим) в строке ткс. В поиск входит
* оканчивающий нулевой символ.
*/
ткст найдипос(ткст ткс, цел сим_);
                   //strrchr (ткс, сим_ )
/*
* Функция strspn /найдитекснеизнаб/ возвращает индекс
* первого символа в строке вчём,не принадлежащего набору
* символов изчего. В поиск не входят
* оканчивающие нулевые символы.
*/

т_мера найдитекснеизнаб(ткст вчём, ткст изчего);
                           //strspn(вчём, изчего)
/*
* Функция strstr /найдиподтекст/ возвращает указатель на первый случай
* искомой строки в строке стр. В поиске не участвуют
* завершающие нулевые символы.
*/
ткст  найдиподтекс(ткст стр, ткст иском);
                     //strstr( стр,  иском)
/*
* Функция strtok /стрзнак/ находит следующий знак в стрзнак.
* Набор символов в строгран определяет возможные
* разграничители искомого в стрзнак знака.
*/
ткст  стрзнак(ткст стрзнак, ткст строгран);
                        //strtok(стрзнак, строгран)
/*
* Функция strerror /строшиб/ преобразует номош в
* строку сообщения об ошибке, возвращая указатель на
* эту строку. Ни strerror, ни _strerror на самом деле
* не выводят сообщения: для этого требуется вызвать
* функцию вывода типа fprintf:

	if (( _access( "datafile",2 )) == -1 )
   fprintf( stderr, _strerror(NULL) );

* Если  strErrMsg передано как NULL, _strerror возвратит указатель
* на строку, содержащую системное сообщение об ошибке для последней
* вызваной библиотеки, создавшей ошибку. Строка сообщения об ошибке
* завершается символом перехода на новую строку ('\n'). Если strErrMsg
* не равно NULL, то _strerror возвращает уккзатель на строку,
* содержащую ваше сообщение об ошибке, точку с запятой, пробел, системное
* сообщение об ошибке последней вызванной библиотеки и символ новой строки.
* Строковое сообщение может быть длиной не более 94 символов.

* Действительный номер ошибки для _strerror хранится в переменной errno.
* Системные сообщения об ошибке доступны через переменную _sys_errlist,
* являющую собой масссив упорядоченных по номеру ошибки сообщений.
* _strerror получает доступ к соответствующему сообщению по значению errno,
* представляющему индекс в переменной _sys_errlist. Значение переменной _sys_nerr
* определено как максимальное число элементов в массиве _sys_errlist.
* Для правильной работы _strerror вызывается сразу после того, как процедура
* библиотеки вернула ошибку. Иначе последующие вызовы strerror или _strerror
* могут переписать значение errno.
*/
ткст  строшиб(цел номош);
         //strerror(номош)
/*
* strlen /длинтекс/ воспринимает строку как однобайтный символьный ряд, поэтому значение
* возврата всегда равно числу байтов, даже если в строке есть многобайтные
* символы. wcslen -это широкосимвольная версия strlen.
*/
т_мера длинтекс(ткст текст);
                 //strlen (текст)

т_мера длинашкс (шим* с);
         // wcslen((wchar_t*) с)
         
         
    дво  фдим(дво x, дво y);
                     //fdim(x, y)
    плав   фдимп(плав x, плав y);
                     //fdimf(x, y)
    реал    фдимр(реал x, реал y);
                     //fdiml(x, y)

    дво  фмакс(дво x, дво y);
                     //fmax(x, y)
    плав   фмаксп(плав x, плав y);
                     //fmaxf(x, y)
    реал    фмакср(реал x, реал y);
                     //fmaxl(x, y)

    дво  фмин(дво x, дво y);
                     //fmin(x, y)
    плав   фминп(плав x, плав y);
                     //fminf(x, y)
    реал    фминр(реал x, реал y);
                     //fminl(x, y)

    дво  фма(дво x, дво y, дво z);
                     //fma(x, y, z)
    плав   фмап(плав x, плав y, плав z);
                     //fmaf(x, y, z)
    реал    фмар(реал x, реал y, реал z);
                     //fmal(x, y, z)

}//endns стд
#endif
