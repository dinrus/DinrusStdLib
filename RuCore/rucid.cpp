#include "RuCore.h"

extern "C"{
цел удали(ткст фимя){return std::remove(фимя);}
цел переименуй(ткст из, ткст в){return std::rename(из, в);}

фук времфл(){return (фук) tmpfile();}
ткст времим(ткст s){return tmpnam(s);}

цел   закройфл(фук поток){return std::fclose(поток);}
цел   слейфл(фук поток){return std::fflush(поток);}
фук откройфл( ткст фимя, ткст режим){return std::fopen(фимя, режим);}
фук переоткройфл(ткст фимя, ткст режим, фук поток){return std::freopen(фимя, режим, поток);}

проц устбуффл(фук поток, ткст буф){std::setbuf(поток, буф);}
цел  уствбуф(фук поток, ткст буф, цел режим, т_мера размер){return std::setvbuf(поток, буф, режим, размер);}

цел вфвыводф(фук поток, ткст формат, спис_ва арг){return vfprintf(поток, формат,арг);}
цел вфсканф(фук поток, ткст формат, спис_ва арг){return vfscanf(поток, формат, арг);}
цел всвыводф(ткст s, ткст формат, спис_ва арг){return vsprintf(s, формат, арг);}
цел вссканф(ткст s, ткст формат, спис_ва арг){return vsscanf(s, формат, арг);}
цел ввыводф(ткст формат, спис_ва арг){return vprintf(формат, арг);}
цел всканф(ткст формат, спис_ва арг){return vscanf(формат, арг);}
цел берисфл(фук поток){return fgetc(поток);}
цел вставьсфл(цел c, фук поток){return fputc(c,поток);}

ткст дайтфл(ткст s, цел n, фук поток){return fgets(s, n,поток);}
цел   вставьтфл(ткст s, фук поток){return fputs(s, поток);}
//ткст дайт(ткст s){return gets(s);}
цел   вставьт(ткст s){return puts(s);}

цел отдайс(цел c, фук поток){return ungetc(c, поток);}

т_мера читайфл(ук указат, т_мера размер, т_мера nmemb, фук поток){return fread( указат, размер, nmemb, поток);}
т_мера пишифл(ук указат, т_мера размер, т_мера nmemb, фук поток){return fwrite(указат, размер, nmemb, поток);}

цел дайпозфл(фук поток, fpos_t *поз){return fgetpos(поток, поз);}
цел устпозфл(фук поток, fpos_t *поз){return fsetpos(поток, поз);}

цел    сместисьфл(фук поток, цел смещение, цел куда){return fseek(поток, смещение, куда);}
цел скажифл(фук поток){return ftell(поток);}

цел   вснвыводф(ткст s, т_мера n, ткст формат, спис_ва арг){return vsnprintf(s, n, формат, арг);}

проц укошиб(ткст s){return perror(s);}

//////////////////////////////////////////

//т_сигфн сигнал(цел сиг, т_сигфн функ){return (т_сигфн) signal(сиг, &функ);}
цел   влеки(цел сиг){return raise(сиг);}

цел числобукв_ли(шим c){return iswalnum(c);}
цел буква_ли(шим c){return iswalpha(c);}
цел пробел_ли(шим c){return iswblank(c);}
цел управ_ли(шим c){return iswcntrl(c);}
цел цифра_ли(шим c){return iswdigit(c);}
цел граф_ли(шим c){return iswgraph(c);}
цел проп_ли(шим c){return iswlower(c);}
цел печат_ли(шим c){return iswprint(c);}
цел пункт_ли(шим c){return iswpunct(c);}
цел межбукв_ли(шим c){return iswspace(c);}
цел заг_ли(шим c){return iswupper(c);}
цел цифраикс_ли(шим c){return isxdigit(c);}
цел впроп(шим c){return towlower(c);}
цел взаг(шим c){return towupper(c);}
шим    втрансш(шим ш, wctrans_t опис){return towctrans(ш, опис);}

//шим трансш(wctrans_t свойство){return wctrans(свойство);}
//цел дайНомош(){return getErrno();}
//цел устНомош(цел n){return setErrno(n);}

проц влекиисклфе(цел исклы){feraiseexcept(исклы);}
проц сотриисклфе(цел исклы){feclearexcept(исклы);}

цел тестисклфе(цел исклы){return fetestexcept(исклы);}
цел задержиисклфе(т_фсред* средп){return feholdexcept((fenv_t*)средп);}

проц дайфлагисклфе(цел* флагп, цел исклы){ fegetexceptflag((fexcept_t*) флагп, исклы);}
проц устфлагисклфе(цел* флагп, цел исклы){ fesetexceptflag((fexcept_t*) флагп, исклы);}

цел дайкругфе(){return fegetround();}
цел усткругфе(цел круг){return fesetround(круг);}

проц дайсредфе(т_фсред* средп){fegetenv((fenv_t*)средп);}
проц устсредфе(т_фсред* средп){fesetenv((fenv_t*) средп);}
проц обновисредфе(т_фсред* средп){feupdateenv((fenv_t*) средп);}

ткст  устлокаль(цел категория, ткст локаль)	{return setlocale(категория, локаль);}
лпреобр* преобрлокаль(){return (лпреобр*) localeconv();}

цел дайпид(){return getpid();}

/*
enum { П_ЖДИ = _P_WAIT, П_НЕЖДИ = _P_NOWAIT, П_ПОВЕРХ = _P_OVERLAY }

цел execl(сим *, сим *,...){}
цел execle(сим *, сим *,...){}
цел execlp(сим *, сим *,...){}
цел execlpe(сим *, сим *,...){}
цел execv(сим *, сим **){}
цел execve(сим *, сим **, сим **){}
цел execvp(сим *, сим **){}
цел execvpe(сим *, сим **, сим **){}

enum { WAIT_CHILD, WAIT_GRANDCHILD }

цел cwait(цел* ч,цел,цел){}
цел жди(цел* ч){}
*/
    дво  фдим(дво x, дво y){return fdim(x, y);}
    плав   фдимп(плав x, плав y){return fdimf(x, y);}
    реал    фдимр(реал x, реал y){return fdiml(x, y);}

    дво  фмакс(дво x, дво y){return fmax(x, y);}
    плав   фмаксп(плав x, плав y){return fmaxf(x, y);}
    реал    фмакср(реал x, реал y){return fmaxl(x, y);}

    дво  фмин(дво x, дво y){return fmin(x, y);}
    плав   фминп(плав x, плав y){return fminf(x, y);}
    реал    фминр(реал x, реал y){return fminl(x, y);}

    дво  фма(дво x, дво y, дво z){return fma(x, y, z);}
    плав   фмап(плав x, плав y, плав z){return fmaf(x, y, z);}
    реал    фмар(реал x, реал y, реал z){return fmal(x, y, z);}

   // проц перемотай(фук поток)   { fseek((фук) поток,0L,SEEK_SET); поток.Флаг&=~_IOERR; }
   // проц сбросьош(фук поток) { поток.Флаг &= ~(_IOERR|_IOEOF);                 }
   // цел  конфл(фук поток)     { return поток.Флаг&_IOEOF;                       }
   // цел  ошфл(фук поток)   { return поток.Флаг&_IOERR;                       }
    
//////////////////

//stdlib


дво  алфнапз(ткст укнач){return atof(укнач);}
цел     алфнац(ткст укнач){return atoi(укнач);}
цел алфнадл(ткст укнач){return (цел) atol(укнач);}
дол    алфнадлдл(ткст укнач){return atoll(укнач);}

дво  стрнад(ткст укнач, ткст* укнакон){return strtod(укнач, укнакон);}
плав   стрнапз(ткст укнач, ткст* укнакон){return strtof(укнач, укнакон);}
реал    стрнадлд(ткст укнач, ткст* укнакон){return strtold(укнач, укнакон);}
цел  стрнадл(ткст укнач, ткст* укнакон, цел ова){return (цел) strtol(укнач, укнакон, ова);}
дол    стрнадлдл(ткст укнач, ткст* укнакон, цел ова){return strtoll(укнач, укнакон, ова);}
бцел стрнабдл(ткст укнач, ткст* укнакон, цел ова){return (бцел) strtoul(укнач, укнакон, ова);}
бдол   стрнабдлдл(ткст укнач, ткст* укнакон, цел ова){return strtoull(укнач, укнакон, ова);}


цел     случ(){return rand();}
проц    сслуч(бцел семя){srand(семя);}


ук   празмести(т_мера разм){return malloc(разм);}
ук   кразмести(т_мера члочленов, т_мера разм){return calloc(члочленов, разм);}
ук   перемести(ук указ, т_мера разм){return realloc(указ, разм);}
проц    освободи(ук указ){ free(указ);}


проц    аборт(){abort();}
//цел     навыходе(проц (*)(void) функц){ return atexit(функц);}
проц    _Выход(цел статус){_Exit(статус);}
//проц    выход(цел статус){exit(статус);}


ткст    дайсреду(ткст имя){return getenv(имя);}
цел     система(ткст текст){return system(текст);}


//ук   бпоиск(ук key, ук ова, т_мера члочленов, т_мера разм, цел (*)(ук, ук) compar){return bsearch(key, ова, члочленов, разм, compar);}
//проц    бсорт(ук ова, т_мера члочленов, т_мера разм, цел (*)(ук, ук) compar){ qsort(ова, члочленов, разм, compar);}


цел     абс(цел j){return abs(j);}
ц64    абс64(ц64  j){return labs(j);}
ц64_2   абсд(ц64_2 j){return llabs(j);}

//т_дели   дели(цел число, цел делитель){return (т_дели) div(число, делитель);}
//т_делиц  делиц(цел число, цел делитель){return (т_делиц) ldiv((c_long) число, (c_long) делитель);}
//т_делид делид(дол число, дол делитель){return (т_делид) lldiv(число, делитель);}

цел     мбдлин(ткст s, т_мера n){return mblen(s, n);}
цел     мбнашк(шткст pwc, кткст s, т_мера n){return mbtowc(pwc, s, n);}
цел     шкнамб(ткст s, шим wc){return wctomb(s,wc);}
т_мера  мбтнашкт(шткст pwcs, ткст s, т_мера n){return mbstowcs(pwcs, s, n);}
т_мера  шктнамбт(ткст s, шткст pwcs, т_мера n){return wcstombs(s, pwcs, n);}

ук разместа(т_мера разм){return alloca(разм); }// нестандартно

цел ширфл(фук поток, цел реж){return fwide( поток, реж);}

/*
//alias цел     mbstate_t;
////alias wchar_t wцел_t;

//const wchar_t WEOF = 0xFFFF;

цел fwprintf(фук поток, in wchar_t* format, ...);
цел fwscanf(фук поток, in wchar_t* format, ...);
цел swprintf(wchar_t* s, т_мера n, in wchar_t* format, ...);
цел swscanf(wchar_t* s, in wchar_t* format, ...);
цел vfwprintf(фук поток, in wchar_t* format, va_list арг);
цел vfwscanf(фук поток, in wchar_t* format, va_list арг);
цел vswprintf(wchar_t* s, т_мера n, in wchar_t* format, va_list арг);
цел vswscanf(wchar_t* s, in wchar_t* format, va_list арг);
цел vwprintf(wchar_t* format, va_list арг);
цел vwscanf(wchar_t* format, va_list арг);
цел wprintf(wchar_t* format, ...);
цел wscanf(wchar_t* format, ...);

wint_t fgetwc(фук поток);
wint_t fputwc(wchar_t c, фук поток);

wchar_t* fgetws(wchar_t* s, цел n, фук поток);
цел      fputws(wchar_t* s, фук поток);

extern  (D)
{
    wint_t getwchar()                     { return fgetwc(stdin);     }
    wint_t putwchar(wchar_t c)            { return fputwc(c,stdout);  }
    wint_t getwc(фук поток)            { return fgetwc(поток);    }
    wint_t putwc(wchar_t c, фук поток) { return fputwc(c, поток); }
}

wint_t ungetwc(wint_t c, фук поток);
цел    fwide(фук поток, цел mode);

double  wcstod(wchar_t* nptr, wchar_t** endptr);
float   wcstof(wchar_t* nptr, wchar_t** endptr);
real    wcstold(wchar_t* nptr, wchar_t** endptr);
c_long  wcstol(wchar_t* nptr, wchar_t** endptr, цел base);
дол    wcstoll(wchar_t* nptr, wchar_t** endptr, цел base);
c_ulong wcstoul(wchar_t* nptr, wchar_t** endptr, цел base);
ulong   wcstoull(wchar_t* nptr, wchar_t** endptr, цел base);

wchar_t* wcscpy(wchar_t* s1, in wchar_t* s2);
wchar_t* wcsncpy(wchar_t* s1, in wchar_t* s2, т_мера n);
wchar_t* wcscat(wchar_t* s1, in wchar_t* s2);
wchar_t* wcsncat(wchar_t* s1, in wchar_t* s2, т_мера n);
цел      wcscmp(wchar_t* s1, in wchar_t* s2);
цел      wcscoll(wchar_t* s1, in wchar_t* s2);
цел      wcsncmp(wchar_t* s1, in wchar_t* s2, т_мера n);
т_мера   wcsxfrm(wchar_t* s1, in wchar_t* s2, т_мера n);
wchar_t* wcschr(wchar_t* s, wchar_t c);
т_мера   wcscspn(wchar_t* s1, in wchar_t* s2);
wchar_t* wcspbrk(wchar_t* s1, in wchar_t* s2);
wchar_t* wcsrchr(wchar_t* s, wchar_t c);
т_мера   wcsspn(wchar_t* s1, in wchar_t* s2);
wchar_t* wcsstr(wchar_t* s1, in wchar_t* s2);
wchar_t* wcstok(wchar_t* s1, in wchar_t* s2, wchar_t** ptr);
т_мера   wcslen(wchar_t* s);

wchar_t* wmemchr(wchar_t* s, wchar_t c, т_мера n);
цел      wmemcmp(wchar_t* s1, in wchar_t* s2, т_мера n);
wchar_t* wmemcpy(wchar_t* s1, in wchar_t* s2, т_мера n);
wchar_t* wmemmove(wchar_t*s1, in wchar_t* s2, т_мера n);
wchar_t* wmemset(wchar_t* s, wchar_t c, т_мера n);

т_мера wcsftime(wchar_t* s, т_мера maxsize, in wchar_t* format, in tm* timeptr);

version( Windows )
{
    wchar_t* _wasctime(tm*);      // нестандартно
    wchar_t* _wctime(time_t*);	  // нестандартно
    wchar_t* _wstrdate(wchar_t*); // нестандартно
    wchar_t* _wstrtime(wchar_t*); // нестандартно
}

wцел_t btowc(цел c);
цел    wctob(wint_t c);
цел    mbsinit(mbstate_t* ps);
т_мера mbrlen(сим* s, т_мера n, mbstate_t* ps);
т_мера mbrtowc(wchar_t* pwc, in сим* s, т_мера n, mbstate_t* ps);
т_мера wcrtomb(сим* s, wchar_t wc, mbstate_t* ps);
т_мера mbsrtowcs(wchar_t* dst, in сим** src, т_мера len, mbstate_t* ps);
т_мера wcsrtombs(сим* dst, in wchar_t** src, т_мера len, mbstate_t* ps);
*/

/////////////////////////////////////////////////////
/*
* memchr /ищисим/ ищет первый случай сим в
* строке, состоящей из члабайт буфера. Она
* останавливается, когда найдёт сим, либо
* проверив первое члобайт.
*/
ук ищисим(ук строка, цел симв, т_мера члобайт)
	{
	return memchr(строка, симв, члобайт);
	}

//alias ищисим ищи_символ;

///////////////////////////////////////////////////////////
/*
* memcmp /сравбуф/: Сравнение символов двух буферов.
* Если возврат < 0, то буф1 меньше буф2; возврат = 0, буферы идентичны;
* возврат > 0, буф1 больше буф2.
*/
цел сравбуф(ук буф1, ук буф2, т_мера члобайт)
	{
	return   memcmp(буф1, буф2, члобайт);
	}

//alias  сравбуф сравни_буферы;

///////////////////////////////////////////////////////////
/*
* memcpy /копирбуф/ копирует члобайт из истока в приёмник;
* если исток и приёмник накладываются, то поведение
* memcpy неопределено. Для обработки накладывающихся
* регионов лучше использовать memmove /перембуф/.
*/
ук копирбуф(ук приёмник, ук источник, т_мера члобайт)
{
	return memcpy(приёмник, источник, члобайт);
}

//alias  копирбуф копируй_буфер;

/////////////////////////////////////////////////////////////
/*
* memmove /перембуф/ копирует байты из откуда в куда.
* Если некоторые области исходной зоны и приёмной нахлёстываются,
* то гарантируется копирование исходных байтов из области
* накладки до того, как будет произведена перезапись.
*/
ук перембуф(ук куда, ук откуда, т_мера сколько)
	{
	return memmove(куда, откуда, сколько);
	}

//alias перембуф перемести_буфер;

///////////////////////////////////////////////////
/*
* memset /устанбуф/ устанавливает первое чло символов приёмника
* где на символ сим.
*/
ук устбуф(ук куда, цел что, т_мера члосим)
	{
	return memset(куда, что, члосим);
	}

//alias  устбуф установи_буфер ;

/////////////////////////////////////////////
/*
* Функция strcpy /копиртекс/ копирует символы откуда,
* включая оканчивающий нуль, в место,
* указанное параметром куда. Поведение strcpy
* неопределено при накладке между источником и приёмником.
*/
ткст копиртекс(ткст куда, ткст откуда)
	{
	return strcpy(куда, откуда);
	}

//alias копиртекс копируй_символы;

/////////////////////////////////////////////////
/*
* Функция strncpy /копирчтекс/ копирует начальное число символов
* из  откуда в куда, и возвращает куда. Если члосим меньше или
* равно длине откуда, то к копированной строке нулевой символ
* автоматически не добавляется. Если же члосим больше длины
* откуда, то принимающая строка заполняется на всю остаточную
* длину нулями. При накладке источника и приёмника поведение
* strncpy неопределено.
*/
ткст копирчтекс(ткст куда,ткст откуда, т_мера члосим)
	{
	return strncpy( куда, откуда, члосим );
	}

//alias  копирчтекс копируй_чло_сим;

/////////////////////////////////////////////
/*
* Функция strcat /сотекс/ добавляет текст_плюс к ткст1,
* и завершает полученную строку нулевым символом.
* Начальный сивол текст_плюс переписывает конечный
* нулевой символ текст1. При накладке источника и
* приёмника поведение неопределено.
*/
ткст сотекс(ткст текст1, ткст текст_плюс)
	{
	return strcat(текст1, текст_плюс);
	}

//alias сотекс соедини_тексты;

////////////////////////////////////////////////////
/*
* Функция strncat /сочтекс/ добавляет не более первого
* чласим ткст2 к ткст1. Начальный символ ткст2 переписывает
* конечный нулевой ткст1. Если до окончания добавления
* в стр2 попадается нулевой символ, то strncat добавляет
* все символы из ткст2, вплоть до нулевого. Если члосим
* больше длины ткст2, то эта длина ткст2 используется
* вместо члосим. Во всех случаях  получаемая строка
* оканчивается на нулевой символ. Если происходит копирование
* между налагающимися строками, то поведение её остаётся не выясненным.
*/
ткст сочтекс(ткст ткст1, ткст ткст2, т_мера члосим)
	{
	return strncat(ткст1, ткст2, члосим);
	}

//alias  сочтекс соедини_чло_сим;

////////////////////////////////////////////
/*
* Сравнение символов двух строк. Функция strncmp /сравнитекс/ сравнивает
* лексикографически текст1 и текст2 и возвращает значение, показывающее их
* взаимоотношение.
* Если возврат < 0, то текст1 меньше текст2; возврат = 0, тексты идентичны;
* возврат > 0, текст1 больше текст2.
*/
цел сравтекс(ткст текст1, ткст текст2)
	{
	return strcmp(текст1, текст2);
	}

//alias сравтекс сравни_тексты ;

/////////////////////////////////////////////
/*
.........................
*/
цел кодстрсравнитекс(ткст текст1, ткст текст2)
	{
	return strcoll(текст1, текст2);
	}

//alias кодстрсравнитекс кссравтекс;
///////////////////////////////////////////////
/*
* Сравнение символов двух строк с использованием текущей локали
* или заданной локали. Функция strncmp /сравничтекс/ сравнивает
* лексикографически не более чем первые члосим в текст1 и текст2,
* и возвращает значение, показывающее взаимоотнощение между подстроками.
* strncmp - это регистрочувствительная версия _strnicmp.
*/
цел сравчтекс(ткст текст1, ткст текст2, т_мера члосим)
	{
	return strncmp(текст1, текст2, члосим);
	}

//alias сравчтекс сравни_чло_сим ;

/////////////////////////////////////////////////
/*
* Функция strxfrm /форматчтекс/ преобразует строку, указанную как
* из, в новую форму, сохраняемую в в. Преобразуется не более
* чла символов, включая и нулевой, который помещаются в
* результат. Трансформация происходит с применением
* установки категории LC_COLLATE локали.
*/
т_мера форматчтекс(ткст в, ткст из, т_мера чло)
	{
	return strxfrm(в, из, чло);
	}

//alias форматчтекс преобразуй_чло_сим_лок ;

//////////////////////////////////////////
/*
* Функция strchr /найдипер/ находит первый случай с в строке т,
* либо возвращает NULL, если с не найден. В поиск включается и
* завершающий символ нуля.
*/
ткст  найдипер(ткст т, цел с)
	{
	return strchr(т, с);
	}

//alias найдипер найди_перв_сим ;

/////////////////////////////////////////
/*
* strcspn /персиндекс/: Возвращает индекс первого случая символа
* что в строке где, который принадлежит к указанному в что
* набору символов.
*/
т_мера персинд (ткст где, ткст что)
	{
	return strcspn ( где, что);
	}

//alias персинд дай_индекс_перв_сим ;

///////////////////////////////////////
/*
* Функция strpbrk /найдитексвнаб/ возвращает указатель на первый
* символ в строке вчём, принадлежащий набору символов
* из ряда изчего. Поиск не включает оканчивающего
* нулевого символа.
*/
ткст  найдитексвнаб(ткст вчём, ткст изчего)
	{
	return  strpbrk( вчём, изчего );
	}

////alias  найдитексвнаб найди_сим_из_набора ;

/////////////////////////////////////
/*
* Функция strrchr /найдипос/ находит последний случай символа сим
* (преобразованного в сим) в строке ткс. В поиск входит
* оканчивающий нулевой символ.
*/
ткст найдипос(ткст ткс, цел сим_)
	{
	return  strrchr (ткс, сим_ );
	}

//alias найдипос найди_посл_сим ;

/////////////////////////////////////
/*
* Функция strspn /найдитекснеизнаб/ возвращает индекс
* первого символа в строке вчём,не принадлежащего набору
* символов изчего. В поиск не входят
* оканчивающие нулевые символы.
*/

т_мера найдитекснеизнаб(ткст вчём, ткст изчего)
	{
	return strspn(вчём, изчего);
	}

//alias найдитекснеизнаб найди_сим_не_из_набора ;

/////////////////////////////////////////
/*
* Функция strstr /найдиподтекст/ возвращает указатель на первый случай
* искомой строки в строке стр. В поиске не участвуют
* завершающие нулевые символы.
*/
ткст  найдиподтекс(ткст стр, ткст иском)
	{
	return strstr( стр,  иском);
	}

//alias найдиподтекс найди_подтекст ;

/////////////////////////////////////////
/*
* Функция strtok /стрзнак/ находит следующий знак в стрзнак.
* Набор символов в строгран определяет возможные
* разграничители искомого в стрзнак знака.
*/
ткст  стрзнак(ткст стрзнак, ткст строгран)
	{
	return strtok(стрзнак, строгран);
	}
////////////////////////////////////////
/*
* Функция strerror /строшиб/ преобразует номош в
* строку сообщения об ошибке, возвращая указатель на
* эту строку. Ни strerror, ни _strerror на самом деле
* не выводят сообщения: для этого требуется вызвать
* функцию вывода типа fprintf:

	if (( _access( "datafile",2 )) == -1 )
   fprintf( stderr, _strerror(NULL) );

* Если  strErrMsg передано как NULL, _strerror возвратит указатель
* на строку, содержащую системное сообщение об ошибке для последней
* вызваной библиотеки, создавшей ошибку. Строка сообщения об ошибке
* завершается символом перехода на новую строку ('\n'). Если strErrMsg
* не равно NULL, то _strerror возвращает уккзатель на строку,
* содержащую ваше сообщение об ошибке, точку с запятой, пробел, системное
* сообщение об ошибке последней вызванной библиотеки и символ новой строки.
* Строковое сообщение может быть длиной не более 94 символов.

* Действительный номер ошибки для _strerror хранится в переменной errno.
* Системные сообщения об ошибке доступны через переменную _sys_errlist,
* являющую собой масссив упорядоченных по номеру ошибки сообщений.
* _strerror получает доступ к соответствующему сообщению по значению errno,
* представляющему индекс в переменной _sys_errlist. Значение переменной _sys_nerr
* определено как максимальное число элементов в массиве _sys_errlist.
* Для правильной работы _strerror вызывается сразу после того, как процедура
* библиотеки вернула ошибку. Иначе последующие вызовы strerror или _strerror
* могут переписать значение errno.
*/
ткст  строшиб(цел номош)
	{
	return strerror(номош);
	}

////////////////////////////////////////
/*
* strlen /длинтекс/ воспринимает строку как однобайтный символьный ряд, поэтому значение
* возврата всегда равно числу байтов, даже если в строке есть многобайтные
* символы. wcslen -это широкосимвольная версия strlen.
*/
т_мера длинтекс(ткст текст)
	{
	return strlen (текст);
	}
////////////////

т_мера длинашкс (шим* с){return wcslen((wchar_t*) с);}

/* export extern (D)
{
    цел getсим()                 { return getc(stdin);     }
    цел putсим(цел c)            { return putc(c,stdout);  }
    цел getc(фук stream)        { return fgetc(stream);   }
    цел putc(цел c, фук stream) { return fputc(c,stream); }
}

extern  (D)
{
    wint_t getwchar()                     { return fgetwc(stdin);     }
    wint_t putwchar(wchar_t c)            { return fputwc(c,stdout);  }
    wint_t getwc(фук stream)            { return fgetwc(stream);    }
    wint_t putwc(wchar_t c, фук stream) { return fputwc(c, stream); }
}




	//цел fpclassify(реал-floating x);
//    цел птклассифицируй(плав x)     { return __fpclassify_f(x); }
 //   цел птклассифицируй(дво x)    { return __fpclassify_d(x); }
  //  цел птклассифицируй(реал x)
  //  {
     //   return (реал.sizeof == дво.sizeof)
        //    ? __fpclassify_d(x)
        //    : __fpclassify_ld(x);
   // }

    //цел isfinite(реал-floating x);
    цел конечен_ли(плав x)       { return птклассифицируй(x) >= FP_NORMAL; }
    цел конечен_ли(дво x)      { return птклассифицируй(x) >= FP_NORMAL; }
    цел конечен_ли(реал x)        { return птклассифицируй(x) >= FP_NORMAL; }

    //цел isinf(реал-floating x);
    цел беск_ли(плав x)          { return птклассифицируй(x) == FP_INFINITE; }
    цел беск_ли(дво x)         { return птклассифицируй(x) == FP_INFINITE; }
    цел беск_ли(реал x)           { return птклассифицируй(x) == FP_INFINITE; }

    //цел isnan(реал-floating x);
    цел нечисло_ли(плав x)          { return птклассифицируй(x) <= FP_NAN;   }
    цел нечисло_ли(дво x)         { return птклассифицируй(x) <= FP_NAN;   }
    цел нечисло_ли(реал x)           { return птклассифицируй(x) <= FP_NAN;   }

    //цел isnormal(реал-floating x);
    цел нормаль_ли(плав x)       { return птклассифицируй(x) == FP_NORMAL; }
    цел нормаль_ли(дво x)      { return птклассифицируй(x) == FP_NORMAL; }
    цел нормаль_ли(реал x)        { return птклассифицируй(x) == FP_NORMAL; }

    //цел signbit(реал-floating x);
    цел знакбит(плав x)     { return ((крат*)&(x))[1] & 0x8000; }
    цел знакбит(дво x)    { return ((крат*)&(x))[3] & 0x8000; }
    цел знакбит(реал x)
    {
        return (реал.sizeof == дво.sizeof)
            ? ((крат*)&(x))[3] & 0x8000
            : ((крат*)&(x))[4] & 0x8000;
    }
	/+
	  //цел isgreater(реал-floating x, реал-floating y);
    цел больше_ли(плав x, плав y)        { return !(x !>  y); }
    цел больше_ли(дво x, дво y)      { return !(x !>  y); }
    цел больше_ли(реал x, реал y)          { return !(x !>  y); }

    //цел большеравны_ли(реал-floating x, реал-floating y);
    цел большеравен_ли(плав x, плав y)   { return !(x !>= y); }
    цел большеравен_ли(дво x, дво y) { return !(x !>= y); }
    цел большеравен_ли(реал x, реал y)     { return !(x !>= y); }

    //цел isless(реал-floating x, реал-floating y);
    цел меньше_ли(плав x, плав y)           { return !(x !<  y); }
    цел меньше_ли(дво x, дво y)         { return !(x !<  y); }
    цел меньше_ли(реал x, реал y)             { return !(x !<  y); }

    //цел меньше_ли(реал-floating x, реал-floating y);
    цел меньшеравен_ли(плав x, плав y)      { return !(x !<= y); }
    цел меньшеравен_ли(дво x, дво y)    { return !(x !<= y); }
    цел меньшеравен_ли(реал x, реал y)        { return !(x !<= y); }

    //цел меньше_лиgreater(реал-floating x, реал-floating y);
    цел меньшебольше_ли(плав x, плав y)    { return !(x !<> y); }
    цел меньшебольше_ли(дво x, дво y)  { return !(x !<> y); }
    цел меньшебольше_ли(реал x, реал y)      { return !(x !<> y); }

    //цел isunordered(реал-floating x, реал-floating y);
    цел беспорядочны_ли(плав x, плав y)      { return (x !<>= y); }
    цел беспорядочны_ли(дво x, дво y)    { return (x !<>= y); }
    цел беспорядочны_ли(реал x, реал y)        { return (x !<>= y); }
	+/
*/
}//endns стд