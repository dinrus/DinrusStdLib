topic "Draw";
[l288;i704;a17;O9;~~~.992;2 $$1,0#10431211400427159095818037425705:param]
[a83;*R6 $$2,5#31310162474203024125188417583966:caption]
[b83;*2 $$3,5#07864147445237544204411237157677:title]
[b167;a42;C2 $$4,6#40027414424643823182269349404212:item]
[b42;a42;2 $$5,5#45413000475342174754091244180557:text]
[l288;a17;2 $$6,6#27521748481378242620020725143825:desc]
[l321;t246;C@5;1 $$7,7#20902679421464641399138805415013:code]
[b2503;2 $$8,0#65142375456100023862071332075487:separator]
[*@(0.0.255)2 $$9,0#83433469410354161042741608181528:base]
[t4167;C2 $$10,0#37138531426314131251341829483380:class]
[l288;a17;*1 $$11,11#70004532496200323422659154056402:requirement]
[i417;b42;a42;O9;~~~.416;2 $$12,12#10566046415157235020018451313112:tparam]
[b167;C2 $$13,13#92430459443460461911108080531343:item1]
[i288;a42;O9;C2 $$14,14#77422149456609303542238260500223:item2]
[*@2$(0.128.128)2 $$15,15#34511555403152284025741354420178:NewsDate]
[l321;*C$7;2 $$16,16#03451589433145915344929335295360:result]
[l321;b83;a83;*C$7;2 $$17,17#07531550463529505371228428965313:result`-line]
[l160;t4167;*C+117 $$18,5#88603949442205825958800053222425:package`-title]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[s2; [@3 Draw]&]
[s0; Эта статья пытается описать роль 
внешнего вида объекта Draw в процессе 
отчерчивания.&]
[s0; &]
[s0; Пожалуйста, помните: Draw `- это не само 
растровое изображение, кодированное 
в определённом формате. Было бы лучше 
представить себе Draw как канал или 
тулбокс с интерфейсом к процедурам 
рисования (к той части программы, 
которая намерена что`-то изобразить; 
в данный момент не будем говорить 
о различиях между отчерчиванием векторов 
и растров) , к той действительной канве 
(`"canvas`"), на которой происходит отрисовка. 
Главная роль Draw состоит в превращении 
ваших логических команд по отчерчиванию 
(например, `"начертить линию`", `"начертить 
кусок текста`", `"начертить растровый 
рисунок`" и т.д..) в нечто, что должно 
понять устройство (`"device`") вывода.&]
[s0; &]
[s0; А теперь общая история. В реальности 
есть в основном два семейства `- относящихся 
к Draw `- объектов, у которых много общих 
черт. Это:&]
[s0; &]
[s0;i150;O2; растрово`-ориентированные объекты 
Draw: в них, как правило, входят объект 
Draw в Ctrl`::Paint override, плюс ViewDraw, плюс BackDraw, 
плюс ImageDraw `& ImageMaskDraw и иногда PrintDraw.&]
[s0; &]
[s0;i150;O2; векторно`-ориентированные объекты 
Draw: DrawingDraw, WinMetaFileDraw и иногда PrintDraw, 
а также (по норме) PageDraw, PdfDraw и Report.&]
[s0; &]
[s0; Несмотря на то, что некоторые предпочли 
бы объяснить характеристики выше 
упомянутых объектов в абстрактной 
форме (с множеством ссылок на `"вам 
не положено знать про то и это`" :`-) 
), будем честны, и честно расскажем 
о том, как это работает, поскольку 
это продвинет вас гораздо дальше 
в нужном направлении.&]
[s0; &]
[s0; На деле это Draw есть нечто типа полуразумного
 художника (painter) с многоцветной палитрой 
логических объектов отрисовки; некоторые 
из них по природе векторно`-ориентированные,
 типа линий, прямоугольников, многоугольнико
в и проч.; некоторые по природе растровые, 
типичные Images; а некоторые `- немного 
и то и другое, в особенности текстовые 
объекты.&]
[s0; &]
[s0; Итак, когда это Draw получает команду 
начертить что`-либо (в терминологии 
U`+`+, при операции отчерчивания (a drawing 
operation),`- смотрим хост методов xxxOp в 
декларации Draw), этот `"художник`" для 
необходимого устройства вывода должен 
решить, что с этим делать. Как правило, 
когда объекты того же типа, что и средство 
вывода (output medium) (как вектор, так и 
растр), работы не так уж и много. Когда 
исходник (эта drawing operation) векторно`-ориентиров
анная, а устройство вывода `- растровое, 
тогда векторный объект требует `"растеризаци
и`".&]
[s0; &]
[s0; Типично растровые объекты Draw связаны 
с рисованием в окнах и рисунками; 
это Draw передаётся Ctrl`::Paint через `"оконный 
механизм`" U`+`+, также как и ViewDraw, BackDraw 
или ImageDraw, и ImageMaskDraw. Все эти объекты 
отрисовки используют механизм MS Windows 
или X Windows, называемый GDI (`"интерфейсом 
графического устройства`"), чтобы 
`"спустить в канал`" объекты отрисовки 
во встроенный растеризатор (rasterizer), 
который (возможно, применяя в некоторых 
случаях ускоритель графической карты 
(graphic card accelerator)) заканчивает изменением 
нужных пикселей на целевом устройстве 
(target device) (это область Ctrl`'а или Image).&]
[s0; &]
[s0; Называя другие классы Draw, `"vector`-based`", 
мы не говорим, что они не справятся 
с растровыми данными. Здесь мы немного 
нарушим стандартное понимание этого 
слова, чтобы поставить ударение на 
тот факт, что последняя группа может 
манипулировать векторными объектами 
напрямую, без предварительной их 
растеризации. Так, например, DrawingDraw 
и WinMetaFileDraw используются для генерации 
сериализованного представления выполненной
 последовательности операций отчерчивания, 
которую позже можно воспроизвести 
(`"play back`"), тем самым воспроизводя оригинальны
й чертёж.&]
[s0; &]
[s0; Заметьте, в выше приведённых случаях 
отсутствует действительный `"canvas`" 
(холст), на котором рисуют. Как DrawingDraw, 
так и WinMetaFileDraw по меньшей мере поддерживают 
поток данных, который используется 
для записи индивидуальных операций 
отчерчивания (поступающих в Draw через 
функции`-члены xxxOp), глубоко не волнуясь 
о том, что именно отчерчивается. Это 
также та причина, по которой вы не 
можете считывать растровые данные 
из такого типа Draw: если вызвать DrawToImage, 
например, для DrawingDraw, то ничего не 
получится. Ну, так, даже при вызове 
DrawToImage над ViewDraw, нельзя никогда рассчитывать
 на получение правильного рисунка, 
так как в ситуациях, когда порция 
окна замутнена (is obscured) другим приложением, 
вы получите снимок (a snapshot) этого другого 
приложения, а не вашего окна.&]
[s0; &]
[s0; Главное преимущество DrawingDraw по сравнению 
с ImageDraw (если попробовать рассмотреть 
эти два класса как два разных средства 
для создания чертежа, который затем 
можно сохранить, допустим, в файл 
или кэш программы) в том, что позже 
он может (при play`-back`'е) воспроизвести 
исходные векторные операции (типа 
линий и многоугольников) в точности, 
даже если размер `"painting`'а`" ремасштабирован, 
без затрудняющих артефактов, неизбежных 
в растрах.&]
[s0; &]
[s0; Для суммирования этого всего в несколько 
практических руководств, попробуйте, 
пожалуйста, запомнить следующее:&]
[s0; &]
[s0;i150;O2; Чтобы создать запись изображения, 
используются DrawingDraw или ImageDraw (об отличиях 
между ними смотрите выше). Например:&]
[s0; &]
[s7; DrawingDraw ddraw(100, 100);&]
[s7; myobject.Paint(ddraw);&]
[s7; Drawing dwg `= ddraw.GetResult(); // dwg `- это запись 
на выходе&]
[s7; &]
[s7; Image img(100, 100);&]
[s7; ImageDraw idraw(img);&]
[s7; myobject.Paint(idraw);&]
[s7; idraw.Close();&]
[s7; // теперь этот Image изменён операциями 
отчерчивания myobject`'а&]
[s7; // и может быть, например, сохранён 
на диск&]
[s0; &]
[s0;i150;O2; При использовании DrawToImage,нужно 
побеспокоиться о выше упомянутых 
ограничениях. В частности, не всегда 
мудро применять DrawToImage над Draw, который 
не полностью у вас под контролем. 
Короче говоря, всё хорошо с ImageDraw и, 
возможно, с BackDraw, но не очень с чем`-либо 
ещё, так как в большинстве случаев 
нет гарантии на то, что получится 
в итоге (например, с ViewDraw или PrintDraw).В 
определённых случаях можно уверенно 
сказать, что вообще ничего не получится 
(например, с DrawingDraw).&]
[s0; &]
[s0;i150;O2; Что касается разницы между Image 
и AlphaArray, то логически их нет (оба представляю
т собой `"маскированные`" растровые 
изображения). А физически разница 
очень велика (её можно рассматривать 
более или менее в отношении оптимизации), 
так как AlphaArray `- это физическая матрица 
пикселей, прямо поддерживаемая приложением,
 в то время как Image (как минимум, иногда) 
`- это логический объект bitmap, поддерживаемый 
оконной системой (что особенно важно 
для X Windows, так как AlphaArray сохраняется 
на клиенте, а Images хранятся на X Server`'е). 
Другое различие в том, что можно создать 
AlphaArray в любом желаемом пиксельном 
формате, но поддерживаемые пиксельные 
форматы изображений (или уже, или 
могут быть) ограничены свойствами 
вашей оконной системы.&]
[s0; &]
[s0;i150;O2; Что касается сохранения рисунков 
в различных стандартных форматах 
(типа jpg, png или gif), опять`-таки эти форматы 
не принадлежат ни объекту Draw, ни объекту 
Image. Лучше всего понимать ImageEncoder`'ы 
как процессоры данных, получающие 
растровый ввод ( AlphaArray или Image) и производящие
 кодированный линеаризованный image 
как свой вывод (очевидно, что фазе 
кодирования соответвуют процедуры 
сохранения; с процедурами загрузки 
ситуация противоположна). Следовательно, 
как только у вас есть Image (или AlphaArray), 
их можно сохранить (Save) в любом нужном 
формате. Точно так же, можно взять 
файл изображения в одном их стандартных 
форматов и считать его в AlphaArray или 
Image.&]
[s0; ]]