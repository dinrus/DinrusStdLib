topic "Об округлении значений double";
[l288;i704;a17;O9;~~~.992;2 $$1,0#10431211400427159095818037425705:param]
[a83;*R6 $$2,5#31310162474203024125188417583966:caption]
[b83;*2 $$3,5#07864147445237544204411237157677:title]
[b167;a42;C2 $$4,6#40027414424643823182269349404212:item]
[b42;a42;2 $$5,5#45413000475342174754091244180557:text]
[l288;a17;2 $$6,6#27521748481378242620020725143825:desc]
[l321;t246;C@5;1 $$7,7#20902679421464641399138805415013:code]
[b2503;2 $$8,0#65142375456100023862071332075487:separator]
[*@(0.0.255)2 $$9,0#83433469410354161042741608181528:base]
[t4167;C2 $$10,0#37138531426314131251341829483380:class]
[l288;a17;*1 $$11,11#70004532496200323422659154056402:requirement]
[i417;b42;a42;O9;~~~.416;2 $$12,12#10566046415157235020018451313112:tparam]
[b167;C2 $$13,13#92430459443460461911108080531343:item1]
[i288;a42;O9;C2 $$14,14#77422149456609303542238260500223:item2]
[*@2$(0.128.128)2 $$15,15#34511555403152284025741354420178:NewsDate]
[l321;*C$7;2 $$16,16#03451589433145915344929335295360:result]
[l321;b83;a83;*C$7;2 $$17,17#07531550463529505371228428965313:result`-line]
[l160;t4167;*C+117 $$18,5#88603949442205825958800053222425:package`-title]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%EN-US 
[s2; [@3 Об округлении двойных значений]&]
[s0; В стандартной математической библиотеке 
Си определено две функции округления:&]
[s0; &]
[s0; floor `- округляет до ближайшего не`-большего 
float без десятичных цифр, т.е..&]
[s0; &]
[s0; floor(`-2.8) `= floor(`-2.4) `= `-3, floor(8) `= floor(8.2) 
`= floor(8.8) `= 8&]
[s0; &]
[s0; ceil `- округляет до ближайшего не`-меньшего 
float без десятичных цифр, т.е.&]
[s0; &]
[s0; ceil(`-2.8) `= ceil(`-2.4) `= `-2, ceil(8.2) `= ceil(8.8) `= 
ceil(9) `= 9&]
[s0; &]
[s0; В дополнение к этим стандартных функциям, 
U`+`+ определяет (в Core/util.h) несколько 
собственных:&]
[s0; &]
[s7;%- int fround(double x);&]
[s7;%- int ffloor(double x);&]
[s7;%- int fceil(double x);&]
[s0; &]
[s0; Они комбинируют округление (к ближайшему 
целому, к ближайшему не`-большему, 
к ближайшему не`-меньшему целому, 
соответственно) с сокращением типа 
float до integer.&]
[s0; &]
[s7;%- int ilog10(double d);&]
[s7;%- double ipow10(int i);&]
[s7;%- double normalize(double d, int`& exponent);&]
[s0; &]
[s0; Эти функции могут использоваться 
для манипуляции `"магнитудой порядка`" 
floats. ilog10 возвращает наибольшее целое 
i, так что 10`^i <`= d, ipow10 вычисляет 10`^i 
(должно быть относительно быстро,как 
минимум, для разумных экспонент), 
нормализует и трансформирует float 
d в форму мантисса `* 10`^экспонента, 
где мантисса (возвращаемый double) располагаетс
я в полузакрытом интервале `[1, 10).&]
[s0; &]
[s7;%- double roundr(double d, int digits);&]
[s7;%- double floorr(double d, int digits);&]
[s7;%- double ceilr(double d, int digits);&]
[s0; &]
[s0; Эти функции округляют заданный float 
до указанного числа `_`_valid`_`_ цифр (т.е. 
относительно к его величине).&]
[s0; &]
[s0; В общем, простое округление, о котором 
вы спрашивали, на данный момент отсутствует,
 но его сравнительно легко реализовать, 
например:&]
[s0; &]
[s0; round(d, n) `= floor(d / ipow10(n) `+ 0.5) `* ipow10(n)&]
[s0; &]
[s0; Но ваш пример (где вы используете 
функции округления для инициализации 
поля редактирования), нечто совсем 
иное. Здесь вы демонстрируете форматировани
е float до заданного числа цифр. Если 
посмотрите в Core/Format.h, то там вы найдёте 
следующие функции:&]
[s0; &]
[s7;%- enum&]
[s7;%- `{&]
[s7;%- -|FD`_SIGN     `= 0x01, // всегда приставлять 
знак (`+10)&]
[s7;%- -|FD`_REL      `= 0x02, // относительные десятичные 
места(полноценные цифры)&]
[s7;%- -|FD`_SIGN`_EXP `= 0x04, // всегда приставлять 
знак к экспоненте (1e`+2)&]
[s7;%- -|FD`_CAP`_E    `= 0x08, // заглавная E для экспоненты 
(1E10)&]
[s7;%- -|FD`_ZERO     `= 0x10, // сохранять завершающие 
нули (1.25000)&]
[s7;%- -|FD`_FIX      `= 0x20, // всегда использовать 
закреплённые нотации (FormatDouble)&]
[s7;%- -|FD`_EXP      `= 0x40, // всегда использовать 
экспоненциальные нотации (FormatDouble)&]
[s7;%- `};&]
[s7;%- String         FormatDoubleDigits(double d, int digits, int 
flags, int`& exponent);&]
[s7;%- String         FormatDouble(double d, int digits, int flags 
`= 0, int fill`_exp `= 0);&]
[s7;%- String         FormatDoubleFix(double d, int digits, int flags 
`= 0);&]
[s7;%- String         FormatDoubleExp(double d, int digits, int flags 
`= 0, int fill`_exp `= 0);&]
[s0; &]
[s0; Их можно использовать для выполнения 
почти любого вообразимого (разумного) 
форматирования float. Для начала попробуйте 
FormatDouble(x, digits), полагаю, итог будет 
похож на ваше MyRoundDouble.&]
[s0; &]
[s0; Остаётся ещё одна опция, связанная 
с использованием EditDouble. У него есть 
метод Образец, устанавливающий строку 
форматирования для NFormat, используемую 
для генерации текстового представления 
данного числа. Чтобы округлить фиксированно
е число десятичных цифр, используйте, 
например:&]
[s7;%- EditDouble dedit;&]
[s7;%- dedit.Образец(`"%4n`");&]
[s0; &]
[s0; (Можете использовать также более 
традиционные форматировщики в стиле 
Си, типа %4g или %3f, но наиболее гибок 
форматировщик %n). &]
[s0; &]
[s0; Заметьте, что Образец на деле `- метод 
из ConvertDouble, являющийся одним из класс`-основ 
для EditDouble.&]
[s0;3 ]]