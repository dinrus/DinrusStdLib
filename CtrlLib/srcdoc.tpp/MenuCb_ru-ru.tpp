topic "Об Обрвызах и Брусах";
[l288;i1120;a17;O9;~~~.1408;2 $$1,0#10431211400427159095818037425705:param]
[a83;*R6 $$2,5#31310162474203024125188417583966:caption]
[b83;*4 $$3,5#07864147445237544204411237157677:title]
[i288;O9;C2 $$4,6#40027414424643823182269349404212:item]
[b42;a42;2 $$5,5#45413000475342174754091244180557:text]
[l288;b17;a17;2 $$6,6#27521748481378242620020725143825:desc]
[l321;t246;C@5;1 $$7,7#20902679421464641399138805415013:code]
[b2503;2 $$8,0#65142375456100023862071332075487:separator]
[*@(0.0.255)2 $$9,0#83433469410354161042741608181528:base]
[t4167;C2 $$10,0#37138531426314131251341829483380:class]
[l288;a17;*1 $$11,11#70004532496200323422659154056402:requirement]
[i417;b42;a42;O9;~~~.416;2 $$12,12#10566046415157235020018451313112:tparam]
[b167;C2 $$13,13#92430459443460461911108080531343:item1]
[i288;a42;O9;C2 $$14,14#77422149456609303542238260500223:item2]
[*@2$(0.128.128)2 $$15,15#34511555403152284025741354420178:NewsDate]
[l321;*C$7;2 $$16,16#03451589433145915344929335295360:result]
[l321;b83;a83;*C$7;2 $$17,17#07531550463529505371228428965313:result`-line]
[l160;t4167;*C+117 $$18,5#88603949442205825958800053222425:package`-title]
[2 $$19,0#53580023442335529039900623488521:gap]
[t4167;C2 $$20,20#70211524482531209251820423858195:class`-nested]
[b50;2 $$21,21#03324558446220344731010354752573:Par]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[s2; [@3 Об Обрвызах и Брусах]&]
[s0; В этой статье обсуждаются типы обратных 
вызовов и перегрузки функций, которые 
используются в операциях с брусами 
( Bar`'ами) (MenuBar, ToolBar).  Класс Bar является 
классом`-основой BarCtrl, который `- в 
свою очередь `- является основой для 
MenuBar и ToolBar.&]
[s0; &]
[s0; Типичный паттерн, который можно найти 
в коде U`+`+, для обработки Bars, выглядит 
примерно так:&]
[s0; &]
[s7; void HelloWorld`::About()&]
[s7; `{&]
[s7; -|...&]
[s7; `}&]
[s7; &]
[s7; void HelloWorld`::FileMenu(Bar`& bar)&]
[s7; `{&]
[s7; -|bar.Add(`"О программе..`", THISBACK(About));&]
[s7; -|bar.Separator();&]
[s7; -|bar.Add(`"Выход`", THISBACK(Close));&]
[s7; `}&]
[s7; &]
[s7; void HelloWorld`::FileMenu2(Bar`& bar, int val)&]
[s7; `{&]
[s7; -|bar.Add(`"О программе..`", THISBACK(About));&]
[s7; -|if (val `=`= 1)&]
[s7; -|`{&]
[s7; -|-|bar.Separator();&]
[s7; -|-|bar.Add(`"Выход`", THISBACK(Close));&]
[s7; -|`}&]
[s7; `}&]
[s7; &]
[s7; HelloWorld`::HelloWorld()&]
[s7; `{&]
[s7; -|menu.Add(`"Файл`", THISBACK(FileMenu));&]
[s7; -|menu.Add(`"Файл2`",THISBACK1(FileMenu2,0);&]
[s0; &]
[s0; Здесь макрос THISBACK разворачивается 
в &]
[s0; &]
[s0; -|[* callback](this, `&HelloWorld`::FileMenu)&]
[s0; &]
[s0; [* callback] `- это перегруженная нечленская 
функция`-шаблон, перегрузки которой 
позволяют обратно вызываемой членской 
функции иметь ни одного, 1,2,3 или 4 аргумента. 
 Так функция FileMenu может иметь ни одного, 
1,2,3 или 4 параметра, и будет выбран 
соответстующий overload (`"перегруз`") 
[* callback] (обратного вызова). Когда вызывается 
целевая обратновызываемая функция 
(напр., FileMenu), действительные передаваемые 
ей аргументы передаёт диспетчер событий, 
который знает сколько аргументов 
ему нужно передать для определённого 
события. В примере выше, конструктор 
HelloWorld вызывает функцию`-[* обрвызов], 
создающую объект Callback (на куче), содержащий 
`"идентичность целевой функции`" (FileMenu), 
которая будет вызвана.  Функция меню.Add 
сохраняет адрес объекта Callback, который 
будет использоваться для вызова функции 
FileMenu при триггировании события.  Существует 
несколько разных классов Callback, включая 
класс Callback1MethodAction, используемый для 
случая, показанного выше.  Классы 
Callback являются функторами. Обычно 
у них есть функция`-член Execute, вызываемая 
механизмом отправки событий. Для 
класса Callback1MethodAction функция`-член Execute 
 принимает один параметр (предоставляемый 
диспетчером событий) , который передаётся 
к целевой функции обратного вызова 
FileMenu.&]
[s0; &]
[s0; Также существует макрос THISBACK1,который 
позволяет указать дополнительное 
значение, передаваемое обратно вызываемой 
функции (напр., FileMenu2), в момент, когда 
триггируется событие.&]
[s0; &]
[s0; Макрос THISBACK1 в примере выше разворачивается
 в &]
[s0; &]
[s0; -|[* callback1](this, `&HelloWorld`::FileMenu2, 0)&]
[s0; &]
[s0; Функция FileMenu2 принимает два параметра, 
первый из которых поставляется диспетчером 
событий, а второй берётся от дополнительного
 значения 0, указанного при вызове 
THISBACK1.  Возможное использование этого 
`- сделать возможным вызов целевой 
функции из нескольких мест, каждое 
из которых идентифицирует себя использовани
ем дополнительного параметра. Для 
примера выше, фигурирует объект Callback 
типа CallbackMethodActionArg1. И этот объект сохраняет 
дополнительное значение (в данном 
случае 0), которое будет передано функции 
FileMenu2 при триггировании события.  
Если используется макрос THISBACK1 с функцией`-чл
еном, принимающей только один аргумент, 
тогда объект Callback принимает тип CallbackMethodActionAr
g.&]
[s0; &]
[s0; Существует также макрос THISBACK2, у которого 
два дополнительных аргумента. Функция`-член,
 используемая с THISBACK, может иметь 
0,1,2,3 или 4 параметра.  Для THISBACK1, функция`-член 
должна иметь, как минимум, один параметр, 
а для THISBACK2 у функции`-члена могут 
быть 2,3 или 4 параметров.&]
[s0; &]
[s0; Если функция`-член, используемая 
в макросах THISBACK, перегружена (например, 
FileMenu(int)), тогда код не скомпилируется. 
В этом случае нужно использовать 
неперегруженную форвардинговую функцию`-чле
н. (При взятии адреса функции`-члена 
невозможно предоставить ей типы аргументов.
  Если функция перегружена, та, которая 
выбирается, зависит от цели, но в данном 
случае цель также перегружена, и её 
нельзя разрешить).&]
[s0; &]
[s0; В примере выше функция`-член Add из 
Bar является перегруженной,и то, какая 
функция Add будет использована, зависит 
от возвратного значения функции [* обратного 
вызова]. Для примера FileMenu, показанного 
выше, возвратное значение функции`-[* обрвызов
а] является Callback1<Bar`&>. (В U`+`+, классы 
Callback начинаются с заглавной C, а функции`-обрв
ызовы `- с прописной c).&]
[s0; ]]