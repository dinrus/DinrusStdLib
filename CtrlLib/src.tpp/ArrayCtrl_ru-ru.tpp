topic "Класс ArrayCtrl (МассивКтрл)";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,2#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[ {{10000t/25b/25@3 [s0; [*@(229)4 Класс ArrayCtrl (МассивКтрл)]]}}&]
[s5;K &]
[s0; 
@@image:2362&1443
(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)
&]
[s0;*@3;3 &]
[s1;:ArrayCtrl`:`:class: [@(0.0.255)3 class][3 _][*3 ArrayCtrl][3 _:_][@(0.0.255)3 public][3 _][*@3;3 C
trl]&]
[s1; &]
[s0; [* 
@@image:1843&731
(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)
]&]
[s0;* &]
[s0; [* ArrayCtrl] реализует основу функционала 
сетки. Он, как правило, используется 
для отображения и редактирования 
массивов значений или (неоднородных) 
записей. Записи соответствуют рядам 
в массиве. Индивидуальные поля в каждой 
записи могут быть привязаны либо 
к колонкам, либо к любым генерным 
[* Ctrl]`'ам, тем самым поддерживая базовый 
функционал.&]
[s0; &]
[s0; Стандартные производные классы расширяют 
различные аспекты функционала ArrayCtrl. 
[* SqlArray] добавляет `"болты и гайки`", необходимые
 для редактирования таблиц на базе 
SQL, тогда как [* PopupTable] удваивает функционал 
ArrayCtrl `"ниспадающим`" механизмом, очень 
похожим на используемый во всплывающих 
меню (popup menus). Это открывает дверцу 
для реализации `"ниспадающих`" контролов 
типа [* DropList] (aka [/ combo box]) или [* DropChoice] (обычно 
используемый вместе с контролом семейства 
[* EditField ]или [* DataPusher], чтобы поддерживать 
нативное редактирование данных с 
ниспадающим (drop`-down) выбором, широко 
используемым для истории или общих 
предопределённых значений. [* ArrayPair], 
как говорит имя, представляет пару 
из [* ArrayCtrl]`'ов с кнопками`-стрелками 
между ними, позволяя визуально выбирать 
поднаборы определённого набора, перемещение
м его элементов между этими двумя 
списками.&]
[s0; &]
[s0; [*+117 Организация данных массива: индексы 
и колонки]&]
[s0;*+117 &]
[s0; Немалая `"генерность`" (genericity) поддерживается
 ArrayCtrl как в отношении его исходных 
данных, так и в отношении визуального 
представления. Исходные данные как 
массив понимаются как матрица значений 
([* Value)]. Имеется ряд методов для доступа 
к этим исходным данным, основными 
являются [* Set] и [* Get]. Адресация к рядам 
ведётся через целочисленные индексы 
(с нулем в основании), к колонкам можно 
адресоваться либо также с помощью 
целочисленных индексов, либо, альтернативно
, любой колонке можно присваивать 
идентификатор [* Id] и адресоваться через 
него. Это особенно удобно в таблицах 
на базе SQL, где для идентификаторов 
можно использовать имена колонок 
таблицы. Пару методов, [* GetPos] и [* GetId], 
используют для трансляции этих двух 
режимов адресации к колонкам. В терминологии
 кода, колонки в исходной матрице 
данных называются [/ индексами], тогда 
как визуальные (выводные) колонки 
называют просто [/ колонками.]&]
[s0; &]
[s0; Визуальная (зримая) структура ArrayCtrl 
может быть целиком независима от 
исходной структуры данных (хотя редко 
бывает пользы от того, что маппинг 
целиком произвольный). Как правило, 
каждая колонка может иметь произвольное 
число индексов, определяющих её исходные 
данные. Конечно же, наиболее общий 
случай `- один индекс на колонку. Он 
же `- самый простой в адресации, так 
как индексы этой колонки равны индексам 
исходных данных. Однако возможны 
и многие другие комбинации, каждая 
из которых может пригодиться в определённой
 ситуации:&]
[s0; &]
[s0;i150;O0; Индекс без колонки: наиболее 
общий из `"особых`" случаев,используемый, 
в основном, для идентификаторов рядов 
или иных внутренне важных данных 
без визуального представления. Того 
же поведения можно добиться, сделав 
колонку невидимой.&]
[s0;i150;O0; Колонка без индекса (a [/ rownum column]): 
этот менее общий случай может использоватьс
я для отображения внешних данных 
(не сохранённых в этой таблице). &]
[s0;i150;O0; Несколько колонок с одним и тем 
же индексом: можно использовать для 
отображения различных аспектов объекта 
комплексных данных, либо для отображения 
одних и тех же исходных данных разными 
способами (например, температура 
по шкале Цельсия и в градусах по Фаренгейту).
&]
[s0;i150;O0; Колонка с несколькими индексами: 
может использоваться для отображения 
информации, собранной из нескольких 
колонок исходных данных. Это используется, 
например, в IconDes DinrusIDE для отображения 
идентификаторов изображений с их 
размерами в списке. Это самый сложный 
случай, так как нужно реализовать 
особый [* Display] для такой много`-индексной 
колонки.&]
[s0; &]
[s0; [* Примечание:] в текущей версии U`+`+, 
реализация безиндексных колонок 
(массивов с внешними данными, не сохранённым
и в исходной матрице) довольно скромна. 
Планируется улучшить эту фишку в 
будущем, добавив поддержку для доступа 
к внешним данным через объект интерфеса 
доступа к данным. &]
[s0; &]
[s0; [*+117 ArrayCtrl ГИП: выделение, редактирование 
и локальное меню]&]
[s0; &]
[s0; Ряды массива можно выделить с помощью 
мыши или клавиатуры. ArrayCtrl`'ы поддерживают 
как единичное выделение (plain cursor) , 
так и мультиселлективную модель. 
Конечно, выделение ряда можно контролироват
ь также через программный интерфейс 
массива. Выделение и курсор всегда 
спанирует все ряды, нельзя (без значительног
о пропатчивания) выделить только 
определённые колонки или индивидуальные 
ячейки.&]
[s0; &]
[s0; Ряды ArrayCtrl можно вставлять, редактировать 
и удалять либо программно, либо через 
общие ГИП`-элементы (выделение мышью 
и клавиатурой, локальное меню).Можно 
изменять стандартное меню ArrayCtrl с 
помощью обратного вызова [* WhenBar].&]
[s0; &]
[s0; [* Примечание:] не стоит волноваться, 
что стандартные клавиши редактирования 
([* Insert] `= вставка ряда, [* Ctrl`+Enter] `= редактировани
е и [* Ctrl`+Delete] `= удаление) не `"жёстко 
закодированы`" в метод ArrayCtrl`'а [* Key], 
`- это по меньшей мере hotkeys (`"горячие 
клавиши`") для соответствующих элементов 
локального меню. Когда вы меняете 
локальное меню ArrayCtrl`'а, эти редактирующие 
горячие клавиши меняются соответственно.&]
[s0; &]
[s0; Особый, и достаточно важный, случай 
редактирования [/ массива] `- [/ сортировка]: 
для этого не существует никакого 
специального стандартного ГИП. Если 
вас не устраивает программная сортировка 
(например, после открытия диалогового 
окна или загрузки данных массива), 
то вам для этого нужно реализовать 
какой`-то ГИП. В некоторых случаях, 
круто использовать метод [* HeaderCtrl] [* WhenAction], 
позволяющий сортировать массив путём 
кликания на колонках`-хедерах; альтернативно
 можно добавить функцию сортировки 
в локальное меню массива или куда`-нибудь 
ещё (типа отдельной кнопки в диалоговом 
окне).&]
[s0; &]
[s0; [* Трюки вставки: перед, после, и секреты 
AppendLine]&]
[s0; &]
[s0; В современных текстовых редакторах, 
при наборе новой буквы, вполне очевидно, 
куда будет помещаться новый текст. 
Это так, поскольку каретка всегда 
помещена между парой последовательных 
букв и, таким образом, место вставки 
отлично определено. В дополнение, 
каретку можно поместить перед первой 
буквой или после последней, что, естественно
, позволяет набирать какой`-либо текст 
в самом начале или конце.&]
[s0; &]
[s0; При вставке новых рядов в контролы 
массива, вещи выглядят несколько 
более замысловато. Это от того, что, 
в отличие от текстового редактора, 
курсор не помещается [/ между] двумя 
последовательными рядами, а [/ над] 
 конкретным рядом. Это, конечно, нужно 
для того, чтобы стало возможным редактироват
ь ряд (заметьте, что в упомянутой аналогии 
с текстовым редактором, единичная 
буква является `"атомным`" объектом, 
в то время как в массиве потенциально 
это сложная структура, состоящая 
из множества колонок и элементов 
данных). Однако, что касается вставки 
рядов, то тут есть две основные замороки:&]
[s0; &]
[s0;i150;O9; [* 1.]-|Нужно решать каким`-то образом, 
куда пойдёт новый ряд,`-  [/ выше] или 
[/ ниже] курсорного ряда.&]
[s0;i150;O9; [* 2.]-|В массиве с [/ n] рядов, [/ n`+1] возможных 
положений для нового ряда (перед рядом 
#0, #1 ... #([/ n`-1]) и после последнего ряда), 
и только [/ n] курсорных позиций.&]
[s0; &]
[s0; В течении лет, разрабатывая U`+`+, мы 
экспериментировали с несколькими 
способами преодоления этих логических 
проблем. В итоге, ArrayCtrl поддерживает 
несколько методов, позволяющих настроить 
механизм вставки ряда. Не стоит волноваться,
 что  бывают случаи, типа случая с 
таблицами на основе SQL, когда порядок 
рядов произволен или неявен и точное 
`'размещение`' нового ряда неясно. 
В таких случаях, можно заменить функцию 
[/ вставки ]массива  на функцию [/ append 
(приставления),] делая ударение на 
том факте, что визуальный порядок 
рядов неважен и что вставка означает 
добавление новой записи в набор.&]
[s0; &]
[s0; Для массивов, у которых порядок важен, 
есть два способа решения дилеммы 
[/ n`+1] ряда:&]
[s0; &]
[s0;i150;O9; [* 1.]-|Замена функции Insert на пару 
функций для вставки нового ряда [/ перед] 
/ [/ за] текущим рядом.&]
[s0;i150;O9; [* 2.]-|Визуальное расширение массива, 
добавлением псевдо`-ряда без реальных 
данных в конце; это создаёт позицию 
[/ n`+1]`-го курсора, необходимую для отметки 
всех доступных позиций вставки ряда.&]
[s0; &]
[s0; В первом случае, возможно также выбрать, 
какая функция вставки (перед / после) 
имеет преимущество (какое из двух 
действий будет привязано к стандартной 
горячей клавише [* Insert]). Это соответствует 
методам [* BeforeAfterInserting] и [* AfterBeforeInserting]. 
Второй случай называется [* AppendLine] и 
активируется установкой свойства 
с одноимённым названием.&]
[s0; &]
[s0; Чтобы всё это стало ещё интересней, 
доступен специальный механизм, называемый 
[* InsertAppend,] делающий заполнение области 
довольно тривиальным делом. Когда 
он активирован и пользователь приставляет 
новый ряд в конец таблицы, после нажатия 
[* Enter] (чтобы `"скоммитить`" вставленный 
ряд) добавляется автоматически ещё 
ряд после него, и открывается для 
редактирования. Этот механизм по 
умолчанию включен, но может быть выключен 
установкой свойства [* NoInsertAppend] в true.&]
[s3; &]
[s0; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 Категоризированная сводка по 
методам]]}}&]
[s9; Следующая таблица суммирует методы 
ArrayCtrl согласно аспекту функциональности, 
которую они поддерживают, заодно 
с кратким описанием. Более подробная 
документация отдельных методов приводится 
ниже.&]
[s0; &]
[ {{2337:7663-1 [s0; [*@(229)$(0.128.128)3 Инициализация и конфигурация]]
:: [s0;%- ]
:: [s0; [*@3 Reset]]
:: [s0; очищает определение колонок `& индекса 
и восстанавливает все дефолтные свойства 
ArrayCtrl]
:: [s0; [*@3 IsEdit]]
:: [s0; true `= автомат состояния массива сейчас 
в режиме редактировании ряда]
:: [s0; [*@3 IsInsert]]
:: [s0; true `= автомат состояния массива сейчас 
в состоянии вставки ряда]
:: [s0; [*@3 SetLineCy]]
:: [s0; устанавливает высоту ряда массива 
(глобально или индивидуально для 
одного ряда)]
:: [s0; [*@3 GetLineCy]]
:: [s0; возвращает логическую высоту ряда 
массива (значение, установленное 
предыдущим SetLineCy)]
:: [s0; [*@3 GetLineY]]
:: [s0; возвращает позицию [/ y] данного ряда 
(относительно начала таблицы)]
:: [s0; [*@3 `[No`]AppendLine]]
:: [s0; `[не`] отображать дополнительный псевдо`-ряд,
 используемый для вставки ряда]
:: [s0; [*@3 IsAppendLine]]
:: [s0; возвращает действительное значение 
свойства [* AppendLine]]
:: [s0; [*@3 ShowAppendLine]]
:: [s0; прокручивает вид таблицы, чтобы отобразить 
приставляемый ряд]
:: [s0; [*@3 `[No`]Inserting]]
:: [s0; `[не`] позволять вставку новых рядов]
:: [s0; [*@3 IsInserting]]
:: [s0; возвращает действительное значение 
свойства [* Inserting]]
:: [s0; [*@3 BeforeAfterInserting]]
:: [s0; позволяет вставку ряда перед / после 
текущего ряда (дефолт `= перед)]
:: [s0; [*@3 AfterBeforeInserting]]
:: [s0; позволяет вставку ряда перед / за 
текущим рядом (дефолт `= за)]
:: [s0; [*@3 NoInsertAppend]]
:: [s0; не делать автовставку другого ряда 
после `"закоммичивания`" последней 
вставки ряда]
:: [s0; [*@3 IsEditing]]
:: [s0; true `= (хотя бы одна из колонок) ArrayCtrl 
поддерживает редактирование]
:: [s0; [*@3 `[No`]Duplicating]]
:: [s0; `[не`] допускать дубликации рядов]
:: [s0; [*@3 IsDuplicating]]
:: [s0; возвращает действительное значение 
свойства [* Duplicating]]
:: [s0; [*@3 Appending]]
:: [s0; разрешает приставление нового ряда 
в конце таблицы]
:: [s0; [*@3 IsAppending]]
:: [s0; возвращает действительное состояние 
свойства [* Appending]]
:: [s0; [*@3 AutoAppending]]
:: [s0; разрешает приставление нового ряда 
в конце таблицы, Enter приставляет ещё 
один]
:: [s0; [*@3 IsAutoAppending]]
:: [s0; возвращает действительное состояние 
свойства [* AutoAppending]]
:: [s0; [*@3 `[No`]Removing]]
:: [s0; `[не`] допускать удаление ряда таблицы]
:: [s0; [*@3 IsRemoving]]
:: [s0; возвращает действительное состояние 
свойства [* Removing]]
:: [s0; [*@3 `[No`]AskRemove]]
:: [s0; `[не`] подсказывать пользователю подтвержден
ие на удаление ряда]
:: [s0; [*@3 IsAskRemove]]
:: [s0; возвращает действительное состояние 
свойства [* AskRemove]]
:: [s0; [*@3 Moving]]
:: [s0; позволить переворот рядов (перемещение 
ряда перед /после соседнего ряда)]
:: [s0; [*@3 IsMoving]]
:: [s0; возвращает действительное состояние 
свойства [* Moving]]
:: [s0; [*@3 `[No`]Header]]
:: [s0; `[не`] отображать заголовочник таблицы]
:: [s0; [*@3 `[No`]Track]]
:: [s0; `[не`] анимировать ширину колонок 
трэкинговой таблицы]
:: [s0; [*@3 `[No`]VertGrid]]
:: [s0; `[не`] показывать разрывы колонок]
:: [s0; [*@3 `[No`]HorzGrid]]
:: [s0; `[не`] показывать разрывы рядов]
:: [s0; [*@3 `[No`]Grid]]
:: [s0; `[не`] отображать обе сетки (VertGrid `+ 
HorzGrid)]
:: [s0; [*@3 GridColor]]
:: [s0; установить цвет линии сетки]
:: [s0; [*@3 EvenRowColor]]
:: [s0; фоновый цвет для чётных рядов]
:: [s0; [*@3 OddRowColor]]
:: [s0; фоновый цвет для нечётных рядов]
:: [s0; [*@3 RowFormat]]
:: [s0; форматирует элементы меню, подставляя 
данное слово вместо `'ряд`']
:: [s0; [*@3 RowName]]
:: [s0; устанавливает контекстно`-релевантное 
слово для подстановки вместо `'ряд`' 
в текстах локального меню]
:: [s0; [*@3 NoCursor]]
:: [s0; не подсвечивать курсорный ряд]
:: [s0; [*@3 `[No`]MouseMoveCursor]]
:: [s0; автоматически премещать курсор за 
мышью (используется, напр., в PopupTable)]
:: [s0; [*@3 `[No`]AutoHideSb]]
:: [s0; `[не`] отображать полосу прокрутки 
только при необходимости]
:: [s0; [*@3 MultiSelect]]
:: [s0; позволить выделение одновременно 
нескольких рядов]
:: [s0; [*@3 ColumnWidths]]
:: [s0; устанавливает ширины логических 
колонок, используя форматированную 
строку, напр.. `"1 5 10 10 5 1`"]}}&]
[s0; &]
[ {{2337:7663-1 [s0; [*@(229)$(0.128.128)3 Управление индексом массива 
`& структурой колонок]]
:: [s0;%- ]
:: [s0; [*@3 IndexInfo]]
:: [s0; возвращает структуру [* IdInfo], описывающую 
индекс (смотрите ниже)]
:: [s0; [*@3 AddIndex]]
:: [s0; добавляет новый индекс в матрицу 
исходных данных]
:: [s0; [*@3 GetIndexCount]]
:: [s0; возвращает число индексных колонок 
(колонок в матрице исходных данных)]
:: [s0; [*@3 GetId]]
:: [s0; возвращает идентификатор данного 
индекса (заданный его интегральным 
индексом)]
:: [s0; [*@3 GetPos]]
:: [s0; возвращает интегральный индекс колонки 
исходной матрицы ([/ индекс]), идентифицируемой
 через [* Id]]
:: [s0; [*@3 SetId]]
:: [s0; устанавливает идентификатор [* Id] для 
данного индекса (колонки исходной 
матрицы)]
:: [s0; [*@3 AddKey]]
:: [s0; устанавливает первый индекс в роли 
первичного ключа (часто используется 
для таблиц SQL)]
:: [s0; [*@3 GetKeyId]]
:: [s0; возвращает идентификатор первичного 
ключа (равно [* GetId(0)])]
:: [s0; [*@3 AddColumn]]
:: [s0; добавляет в таблицу пару колонка`-индекс 
(одна колонка данных, одна колонка 
вывода)]
:: [s0; [*@3 AddColumnAt]]
:: [s0; добавляет колонку, привязанную к 
указанному индексу]
:: [s0; [*@3 AddRowNumColumn]]
:: [s0; добавляет колонку без индекса (используется
 для внешних данных)]
:: [s0; [*@3 GetColumnCount]]
:: [s0; возвращает число (визуальных) колонок 
в таблице]
:: [s0; [*@3 FindColumnWithPos]]
:: [s0; лоцирует колонку таблицы, согласно 
указанному индексному числу]
:: [s0; [*@3 FindColumnWithId]]
:: [s0; лоцирует колонку таблицы, согласно 
идентификатора индекса]
:: [s0; [*@3 ColumnAt]]
:: [s0; возвращает структуру [* ArrayCtrl`::Column], 
описывающую данную колонку]
:: [s0; [*@3 HeaderTab]]
:: [s0; возвращает структуру [* HeaderCtrl`::Column] 
для указанной колонки]
:: [s0; [*@3 HeaderObject]]
:: [s0; возвращает ссылку на объект [* HeaderCtrl] 
для данной таблицы]
:: [s0; [*@3 SerializeHeader]]
:: [s0; сериализует информацию о выкладке 
заголовочника (ширины колонок и проч.)]
:: [s0; [*@3 AddCtrl]]
:: [s0; добавляет в таблицу внешнюю пару 
контрол`-индекс (одна колонка данных, 
один внешний Ctrl)]
:: [s0; [*@3 AddCtrlAt]]
:: [s0; добавляет внешний контрол, привязанный 
к указанному индексу]
:: [s0; [*@3 AddRowNumCtrl]]
:: [s0; добавляет внешний контрол без индекса 
`- используется ([/ редко])  для внешних 
данных]
:: [s0; [*@3 SetDisplay]]
:: [s0; устанавливает отображение данной 
колонки или ячейки]
:: [s0; [*@3 GetDisplay]]
:: [s0; возвращает отображение колонки/ячейки]
:: [s0; [*@3 SetCtrl]]
:: [s0; устанавливает объект [* Ctrl] для кастомного 
редактирования указанной ячейки]
:: [s0; [*@3 GetTotalCy]]
:: [s0; возвращает общую высоту рядов]
:: [s0; [*@3 GetLineAt]]
:: [s0; Лоцирует ряд таблицы при заданной 
позиции [/ y] (относительно верха таблицы)]
:: [s0; [*@3 GetClickColumn]]
:: [s0; возвращает номер колонки, кликнутой 
последней (Null, если кликнуто вне существующи
х рядов)]
:: [s0; [*@3 GetClickRow]]
:: [s0; возвращает номер ряда, кликнутого 
 последним (Null, если кликнуто вне существующи
х рядов)]
:: [s0; [*@3 GetClickPos]]
:: [s0; возвращает Point(GetClickColumn(), GetClickRow())]}}&]
[s0; &]
[ {{2337:7663-1 [s0; [*@(229)$(0.128.128)3 Установка `& получение 
данных]]
:: [s0;%- ]
:: [s0; [*@3 SetCount]]
:: [s0; устанавливает число рядов в массиве]
:: [s0; [*@3 SetVirtualCount]]
:: [s0; устанавливает число рядов в массие 
с внешними данными]
:: [s0; [*@3 GetCount]]
:: [s0; возвращает число рядов]
:: [s0; [*@3 Clear]]
:: [s0; очищает данные массива, идентичен 
[* SetCount(0)]]
:: [s0; [*@3 Shrink]]
:: [s0; расширяет матрицу исходных данных 
до минимально необходимого размера]
:: [s0; [*@3 Get]]
:: [s0; возвращает заданный элемент Value из 
матрицы исходных данных]
:: [s0; [*@3 GetOriginal]]
:: [s0; возвращает заданный элемент матрицы 
исходных данных перед редактированием]
:: [s0; [*@3 Set]]
:: [s0; устанавливает заданный элемент матрицы 
исходных данных]
:: [s0; [*@3 GetKey]]
:: [s0; возвращает заданный первичный ключ 
(колонка #0 в матрице данных)]
:: [s0; [*@3 GetOriginalKey]]
:: [s0; возвращает `'старое`' значение первичного 
ключа до редактирования]
:: [s0; [*@3 GetColumn]]
:: [s0; возвращает значение заданной колонки 
вывода (согласно её маппингу индексов)]
:: [s0; [*@3 GetConvertedColumn]]
:: [s0; возвращает значение данной колонки 
вывода после применения [* Convert]]
:: [s0; [*@3 ReadRow]]
:: [s0; возвращает ряд из матрицы исходных 
данных]
:: [s0; [*@3 Add]]
:: [s0; добавляет новый ряд в конец таблицы]
:: [s0; [*@3 Insert]]
:: [s0; вставляет новый ряд в таблицу]
:: [s0; [*@3 Remove]]
:: [s0; удаляет заданный ряд таблицы]
:: [s0; [*@3 SwapUp]]
:: [s0; обменивает местами ряд таблицы с 
предыдущим рядом]
:: [s0; [*@3 SwapDown]]
:: [s0; обменивает местами ряд таблицы со 
следующим рядом]
:: [s0; [*@3 Sort]]
:: [s0; сортирует ряды таблицы, используя 
заданный предикат]
:: [s0; [*@3 ClearCache]]
:: [s0; очищает кэш преобразования данных]
:: [s0; [*@3 InvalidateCache]]
:: [s0; инвалидирует заданный табличный 
ряд в кэше преобразования]}}&]
[s0; &]
[ {{2337:7663-1 [s0; [*@(229)$(0.128.128)3 Управление курсором `& 
выделением]]
:: [s0;%- ]
:: [s0; [*@3 GetSelectCount]]
:: [s0; возвращает число текущих выделенных 
рядов]
:: [s0; [*@3 IsSelection]]
:: [s0; проверяет, есть ли выделенные ряды 
(идентично [* GetSelectCount() > 0])]
:: [s0; [*@3 Select]]
:: [s0; выделяет / снимает выделение с указанного 
ряда или серии рядов]
:: [s0; [*@3 IsSelected]]
:: [s0; проверяет, выделен ли заданный ряд]
:: [s0; [*@3 ClearSelection]]
:: [s0; очищает текущее выделение]
:: [s0; [*@3 SetCursor]]
:: [s0; перемещает курсор массива к новому 
ряду]
:: [s0; [*@3 KillCursor]]
:: [s0; удаляет курсор из таблицы]
:: [s0; [*@3 CancelCursor]]
:: [s0; отменяет редактирование текущего 
ряда]
:: [s0; [*@3 IsCursor]]
:: [s0; проверяет, в таблице ли курсор (идентично 
[* GetCursor() >`= 0])]
:: [s0; [*@3 GetCursor]]
:: [s0; возвращает текущий курсорный ряд, 
`-1, если нет ни одного]
:: [s0; [*@3 GoBegin]]
:: [s0; перемещает курсор к первому ряду 
таблицы]
:: [s0; [*@3 GoEnd]]
:: [s0; перемещает курсор к последнему ряду 
таблицы]
:: [s0; [*@3 GetCursorSc]]
:: [s0; возвращает размещение ряда курсора 
в видимой области таблицы]
:: [s0; [*@3 ScCursor]]
:: [s0; проматывает таблицу, перемещая курсорный 
ряд в заданное положение в пределах 
вида таблицы]
:: [s0; [*@3 CenterCursor]]
:: [s0; проматывает таблицу, перемещая курсор 
в середину текущего вида]
:: [s0; [*@3 ScrollInto]]
:: [s0; проматывает таблицу на минимальное 
необходимое количество, чтобы текущий 
ряд стал видимым]
:: [s0; [*@3 ScrollIntoCursor]]
:: [s0; проматывает таблицу на минимальное 
необходимое количество, чтобы курсорный 
ряд стал видимым]
:: [s0; [*@3 GetScroll]]
:: [s0; возвращает расположение текущей 
полосы прокрутки таблицы]
:: [s0; [*@3 ScrollTo]]
:: [s0; устанавливает расположение полосы 
прокрутки таблицы]
:: [s0; [*@3 Find]]
:: [s0; лоцирует ряд таблицы, содержащий 
заданный элемент]
:: [s0; [*@3 FindSetCursor]]
:: [s0; перемещает курсор к ряду таблицы, 
содержащему заданный элемент]}}&]
[s0;3 &]
[s0; &]
[s0; &]
[ {{2337:7663-1 [s0; [*@(229)$(0.128.128)3 Элементы ГИП]]
:: [s0;%- ]
:: [s0; [*@3 StdBar]]
:: [s0; дефолтное локальное меню массива]
:: [s0; [*@3 IsModified]]
:: [s0; проверяет состояние модификации 
заданной ячейки массива]
:: [s0; [*@3 StartEdit]]
:: [s0; открывает текущий ряд массива для 
редактирования]
:: [s0; [*@3 GetEditColumn]]
:: [s0; возвращает в данный момент редактируемую 
колонку]
:: [s0; [*@3 DoEdit]]
:: [s0; соответствует функции локального 
меню `'Редактировать`']
:: [s0; [*@3 DoInsert]]
:: [s0; соответствует функции локального 
меню `'Вставить`']
:: [s0; [*@3 DoInsertBefore]]
:: [s0; соответствует функции локального 
меню `'Вставить перед`']
:: [s0; [*@3 DoInsertAfter]]
:: [s0; соответствует функции локального 
меню `'Вставить после`']
:: [s0; [*@3 DoAppend]]
:: [s0; соответствует функции локального 
меню `'Приставить`']
:: [s0; [*@3 DoRemove]]
:: [s0; соответствует функции локального 
меню `'Удалить`']
:: [s0; [*@3 DoDuplicate]]
:: [s0; соответствует функции локального 
меню `'Дублировать`']
:: [s0; [*@3 DoSelectAll]]
:: [s0; выделить весь массив]
:: [s0; [*@3 AcceptEnter]]
:: [s0; `"коммитит`" текущий отредактированный 
ряд и, возможно, начинает вставку 
другого ряда]}}&]
[ {{2337:7663-1 [s0; [*@(229)$(0.128.128)3 Нотификационные обратные 
вызовы]]
:: [s0;%- ]
:: [s0; [*@3 WhenLeftClick]]
:: [s0; клик левой кнопки мыши в пределах 
массива]
:: [s0; [*@3 WhenLeftDouble]]
:: [s0; двойной клик левой кнопки мыши в 
пределах массива]
:: [s0; [*@3 WhenSel]]
:: [s0; вызывается при изменении курсора 
или статуса выделения]
:: [s0; [*@3 WhenCursor]]
:: [s0; вызывается при изменении размещения 
курсора [/ (депрекировано, использовать 
WhenSel)]]
:: [s0; [*@3 WhenKillCursor]]
:: [s0; вызывается при перемещение курсора 
вне пределов таблицы [/ (депрекировано, 
использовать WhenSel)]]
:: [s0; [*@3 WhenSelection]]
:: [s0; вызывается, когда изменено текущее 
выделение [/ (депрекировано, использовать 
WhenSel)]]
:: [s0; [*@3 WhenEnterRow]]
:: [s0; вызывается при перемещении курсора 
к новому ряду [/ (депрекировано, использовать 
WhenSel)]]
:: [s0; [*@3 WhenUpdateRow]]
:: [s0; вызывается после обновления ряда]
:: [s0; [*@3 WhenAcceptRow]]
:: [s0; дополнительный братный вызов валидации 
ряда]
:: [s0; [*@3 WhenStartEdit]]
:: [s0; вызывается после инициации редактирования 
ряда]
:: [s0; [*@3 WhenAcceptEdit]]
:: [s0; вызывается после принятия изменений 
указанного ряда]
:: [s0; [*@3 WhenArrayAction]]
:: [s0; вызывается при изменении исходных 
данных массива (после вставки / удаления 
/ редактирования)]
:: [s0; [*@3 WhenBar]]
:: [s0; может использоваться для `"поставки`" 
кастомного локального меню для массива]
:: [s0; [*@3 WhenCtrlsAction]]
:: [s0; вызывается обратными вызовами [* WhenAction] 
внутренне созданных контролов]}}&]
[s3; &]
[s0; &]
[s0; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 Детальное описание методов]]}}&]
[s0; &]
[s0; [*@(229)$(0.128.128)3 Инициализация и конфигурация]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:Reset`(`): [@(0.0.255) void]_[* Reset]()&]
[s2; Очищает ряды таблицы и устанавливает 
все свойства массива на их дефолтные 
значения.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ShowAppendLine`(`): [@(0.0.255) void]_[* ShowAppendLine]()&]
[s2; Показывает дополнительный превдоряд 
в конце таблицы. При клике к массиву 
добавляется новый ряд.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:AcceptRow`(`):%- [@(0.0.255) bool]_[* AcceptRow]()&]
[s2; Когда имеются зависимые виджеты 
(подключенные посредством AddCtrl), видимый 
контент строки ArrayCtrl`'а, как правило, 
обновляется при перемещении курсора 
к новой строке (и перемещение предотвращаетс
я, если у какого`-то из зависимых виджетов 
неверное значение). Этот метод пытается 
проверить на неверные значения и 
обновляет сразу же ряд. Возвращает 
 true, если в зависимых виджетах неверные 
значения отсутствуют.&]
[s3;%- &]
[s4; &]
[s5;:ArrayCtrl`:`:IsEdit`(`)const: [@(0.0.255) bool]_[* IsEdit]()_[@(0.0.255) const]&]
[s2; Проверяет, не редактируется ли ряд 
в настоящее время.&]
[s7; [*/ Возвратное значение]-|[* true] `= ряд сейчас 
открыт для редактирования, [* false] `= 
массив в обычном режиме просмотра.&]
[s0; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsInsert`(`)const: [@(0.0.255) bool]_[* IsInsert]()_[@(0.0.255) const]&]
[s2; Провееряет, не добавляется ли в данный 
момент новый ряд.&]
[s7; [*/ Возвратное значение]-|[* true] `= в данный 
момент редактируется новый вставляемый 
ряд, [* false] `- ничего такого нет))&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetLineCy`(int`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* SetLineCy]([@(0.0.255) i
nt]_[*@3 cy])&]
[s2; Устанавливает (дефолтную) высоту 
ряда массива. Для некоторых рядов 
её нужно переписать версией данного 
метода с двумя параметрами.&]
[s7; [*C@3 cy]-|высота ряда в пикселях&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SetEditLineCy`(`):%- [_^Upp`:`:ArrayCtrl^ ArrayCtrl][@(0.0.255) `&
]_[* SetEditLineCy]()&]
[s2; Устанавливает дефолтную высоту ряда 
массива, так что редакторы, основанные 
на EditField, удачно помещаются в данный 
ArrayCtrl.&]
[s3;%- &]
[s4; &]
[s5;:ArrayCtrl`:`:SetLineCy`(int`,int`): [@(0.0.255) void]_[* SetLineCy]([@(0.0.255) int]_[*@3 i
], [@(0.0.255) int]_[*@3 cy])&]
[s2; Устанавливает высоту для заданного 
ряда. Переписывает дефолтное значение, 
установленное версией этого метода 
с одним параметром.&]
[s7; [*C@3 i]-|индекс ряда (на основании нуля)&]
[s7; [*C@3 cy]-|высота ряда в пикселях, [* Null] `= 
использовать дефолтную высоту ряда&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetLineCy`(`)const: [@(0.0.255) int]_[* GetLineCy]()_[@(0.0.255) const]&]
[s2; Возвращает  дефолтную высоту ряда 
массива.&]
[s7; [*/ Возвратное значение]-|высота ряда 
в пикселях&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetLineY`(int`)const: [@(0.0.255) int]_[* GetLineY]([@(0.0.255) int]_[*@3 i
])_[@(0.0.255) const]&]
[s2; Возвращает  позицию [/ y] данного ряда 
массива (расстояние в пикселях между 
верхом первого ряда массива и [/ i]`-ным 
рядом, т.е. сумму высот всех рядов, 
расположенных выше данного ряда).&]
[s7; [*C@3 i]-|индекс ряда (на основании нуля)&]
[s7; [*/ Возвратное значение]-|Вертикальная 
позиция верха ряда в пикселях (относительно 
начала массива)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetLineCy`(int`)const: [@(0.0.255) int]_[* GetLineCy]([@(0.0.255) int]_[*@3 i
])_[@(0.0.255) const]&]
[s2; Возвращает  высоту данного ряда (либо 
специфичную для ряда высоту, либо, 
при Null, дефолтную высоту ряда).&]
[s7; [*C@3 i]-|индекс ряда (на основании нуля)&]
[s7; [*/ Возвратное значение]-|высота ряда 
 пикселях&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AppendLine`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AppendLine
]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Свойство AppendLine контролирует, будет 
ли данный массив отображать дополнительный 
ряд `"приставки`" после своего последнего 
(реального) ряда. &]
[s7; [*C@3 b]-|[* true] `= показывать добавляемый 
ряд, [* false] `= скрыть его&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoAppendLine`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoAppendLine
]()&]
[s2; Скрыть приставляемую строку (идентично 
[* AppendLine(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsAppendLine`(`)const: [@(0.0.255) bool]_[* IsAppendLine]()_[@(0.0.255) c
onst]&]
[s2; Возвращает  текущее состояние свойства 
[* AppendLine].&]
[s7; [*/ Возвратное значение]-|[* true] `= показывать 
приставочный псевдоряд в конце массива&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Inserting`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Inserting](
[@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Активировать/ дезактивировать вставку 
новых рядов в массив (неважно, какой 
механизм вставки выбран).&]
[s7; [*C@3 b]-|[* true] `= активировать вставку, [* false] 
`= дезактивировать её&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoInserting`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoInserting](
)&]
[s2; Дезактивирует вставку рядов (идентично 
[* Inserting(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsInserting`(`)const: [@(0.0.255) bool]_[* IsInserting]()_[@(0.0.255) con
st]&]
[s2; Возвращает  текущее состояние свойства 
[* Inserting].&]
[s7; [*/ Возвратное значение]-|[* true] `= вставка 
рядов активирована, [* false] `- когда нет.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Appending`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Appending](
[@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Активирует/ дезактивирует добавку 
новых рядов в конце таблицы.&]
[s7; [*C@3 b]-|[* true] `= активировать приставление 
ряда, [* false] `= дезактивировать&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsAppending`(`)const: [@(0.0.255) bool]_[* IsAppending]()_[@(0.0.255) con
st]&]
[s2; Возвращает  текущее состояние свойства 
[* Appending].&]
[s7; [*/ Возвратное значение]-|[* true] `= приставление 
ряда активировано, [* false] `-когда нет.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AutoAppending`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AutoApp
ending]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; То же, что и [* Appending], но нажатие Enter 
при редактировании нового ряда принимает 
его и добавляет в конец таблицы.&]
[s7; [*C@3 b]-|[* true ]для активирования этого режима&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsAutoAppending`(`)const: [@(0.0.255) bool]_[* IsAutoAppending]()_[@(0.0.255) c
onst]&]
[s2; Возвращает  текущее состояние свойства 
[* AutoAppending].&]
[s7; [*/ Возвратное значение]-|[* true] `= [* AutoAppending 
]активен&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:BeforeAfterInserting`(int`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* B
eforeAfterInserting]([@(0.0.255) int]_[*@3 q]_`=_[@3 1])&]
[s2; Активирует механизм вставки перед 
/ после ряда (горячая клавиша [* Insert] 
`= перед).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AfterBeforeInserting`(int`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* A
fterBeforeInserting]([@(0.0.255) int]_[*@3 q]_`=_[@3 2])&]
[s2; Активирует механизм вставки перед 
/ после ряда (горячая клавиша [* Insert] 
`= после).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Duplicating`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Duplicati
ng]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Включить/ выключить дубликацию рядов. 
Заметьте, что это свойство которолирует 
только то, должен ли элемент `'Duplicate`' 
находиться в локальном меню массива. 
Конечно, ничто не мешает поддерживать 
дубликацию иным образом, или вызывать 
метод [* DoDuplicate], если это необходимо.&]
[s7; [*C@3 b]-|[* true] `= включить дубликацию, [* false] 
`= отключить её&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoDuplicating`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoDuplicati
ng]()&]
[s2; Выключить дубликацию рядов (то же, 
что и [* Duplicating(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsDuplicating`(`)const: [@(0.0.255) bool]_[* IsDuplicating]()_[@(0.0.255) c
onst]&]
[s2; Возвращает состояние свойства [* Duplicating].&]
[s7; [*/ Возвратное значение]-|[* true] `= локальное 
меню предлагает дублирование рядов, 
[* false] если нет&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoInsertAppend`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoInse
rtAppend]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Включает/ отключает механизм авто`-приставл
ения (смотрите выше раздел о вставке 
рядов).&]
[s7; [*C@3 b]-|[* true] `= отключить механизм InsertAppend, 
[* false] `= включить его (дефолт)&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsEditing`(`)const: [@(0.0.255) bool]_[* IsEditing]()_[@(0.0.255) const]&]
[s2; Проверяет, поддерживает ли хотя бы 
одна колонка массива редактирование( 
можно ли [/ открыть] ряд для редактирования).&]
[s7; [*/ Возвратное значение]-|[* true] `= редактирование 
ряда возможно, [* false] если нет&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Removing`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Removing]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Включить/ выключить удаление рядов 
из таблицы.&]
[s7; [*C@3 b]-|[* true] `= включить удаление, [* false] 
`= выключить его&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoRemoving`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoRemoving]()&]
[s2; Выключить редактирование рядов таблицы 
(то же, что и [* Removing(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsRemoving`(`)const: [@(0.0.255) bool]_[* IsRemoving]()_[@(0.0.255) const
]&]
[s2; Возвращает текущее состояние свойства 
[* Removing].&]
[s7; [*/ Возвратное значение]-|[* true] `= удаление 
рядов включено, [* false] если нет&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AskRemove`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AskRemove](
[@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Устанавливает, должен ли пользователь 
вручную подтверждать удаление ряда 
массива. При установке в [* true], при каждом 
удалении ряда выскакивает диалоговое 
окно подтверждения. При установке 
в [* false], ряды удаляются автоматически 
без всякого подтверждения.&]
[s7; [*C@3 b]-|[* true] `= предлагать пользователю 
подтверждение удаления ряда, [* false] 
`= удалять ряды тотчас же&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoAskRemove`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoAskRemove](
)&]
[s2; Отключает подтверждение пользователем 
удаления ряда (аналогично [* AskRemove(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsAskRemove`(`)const: [@(0.0.255) bool]_[* IsAskRemove]()_[@(0.0.255) con
st]&]
[s2; Возвращает текущее состояние свойства 
[* AskRemove].&]
[s7; [*/ Возвратное значение]-|[* true] `= для удаления 
ряда нужно подтверждение пользователя, 
[* false] `= ряды удаляются немедленно.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Moving`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Moving]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Активировать/ выключить перестановку 
рядов. Когда установлено в [* true], можно 
перемещать ряд массива вверх или 
вниз, меняя его местами с предыдущим 
/ следующим рядом. Это можно применять 
для изменения порядка следования 
рядов массива вполне наглядным образом.&]
[s7; [*C@3 b]-|[* true] `= предлагать перестановку 
рядов в локальном меню, [* false] `= не предлагать.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsMoving`(`)const: [@(0.0.255) bool]_[* IsMoving]()_[@(0.0.255) const]&]
[s2; Возвращает текущее состояние свойства 
[* Moving].&]
[s7; [*/ Возвратное значение]-|[* true] `= локальное 
меню поддерживает перестановку рядов, 
[* false] `= не поддерживает.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Header`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Header]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Показать/ скрыть объект [*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`$en`-us^ H
eaderCtrl] для этой таблицы.&]
[s7; [*C@3 b]-|[* true] `= показывать header таблицы, 
[* false] `= скрывать его&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoHeader`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoHeader]()&]
[s2; Скрыть заголовочник таблицы (равнозначно 
[* Header(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Track`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Track]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Анимировать изменение размера колонок 
массива. Равнозначно установке свойства 
[*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`_ru`-ru^ Track] в HeaderCtrl 
массива.&]
[s7; [*C@3 b]-|[* true] `= повторно перерисовывать 
массив при перетягивании колонок 
в ширину, [* false] `= регенерировать все 
только после окончания тяга`-броса.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoTrack`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoTrack]()&]
[s2; Не анимировать изменение размера 
колонок массива (равнозначно [* Track(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:VertGrid`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* VertGrid]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Показать/ скрыть вертикальные линии 
сетки массива (разделяющие его колонки).&]
[s7; [*C@3 b]-|[* true] `= показать вертикальные линии 
сетки, [* false] `= скрыть их&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoVertGrid`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoVertGrid]()&]
[s2; Скрыть вертикальные линии сетки 
(равноценно [* VertGrid(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HorzGrid`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* HorzGrid]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Показать/ скрыть горизонтальные 
линии сетки (разделяющие ряды массива).&]
[s7; [*C@3 b]-|[* true] `= показать горизонтальные 
линии сетки, [* false] `= скрыть их&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoHorzGrid`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoHorzGrid]()&]
[s2; Скрыть горизонтальные линии сетки 
(равноценно [* HorzGrid(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Grid`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Grid]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Показать / скрыть как горизонтальные, 
так и вертикальные линии сетки (равноценно 
[* HorzGrid(b).VertGrid(b)]).&]
[s7; [*C@3 b]-|[* true] `= показать матрицу линий 
сетки, [* false] `= скрыть все линии сетки.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoGrid`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoGrid]()&]
[s2; Скрыть горизонтальные и вертикальные 
линии сетки (равноценно [* Grid(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GridColor`(Color`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* GridColor](
[_^Color^ Color]_[*@3 c])&]
[s2; Устанавливает цвет для линий сетки.&]
[s7; [*C@3 c]-|новый цвет линии сетки&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:EvenRowColor`(Color`,Color`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* E
venRowColor]([_^Color^ Color]_[*@3 paper]_`=_Blend(SColorMark, SColorPaper, 
[@3 220]), [_^Color^ Color]_[*@3 ink]_`=_SColorText)&]
[s2; Устанавливает цвета бумаги и чернил 
(фоновый и переднеплановый цвет) для 
чётных рядов массива. В некоторых 
случаях установка другого фонового 
цвета для нечётных и чётных рядов 
помогает облегчить зрительную ориентацию 
по массивам (особенно, если много 
колонок).&]
[s2; [* Примечание:] терминология чётных 
/ нечётных рядов ссылается на естественное 
исчисление рядов массива, так, первый 
ряд массива [/ нечётный, ]а второй `- 
[/ чётный]. Это отличается от целочисленного 
индексирования, когда первый ряд 
массива имеет индекс 0.&]
[s7; [*C@3 paper]-|фоновый цвет, используемый 
для второго, четвёртого, шестого и 
т.д. ряда.&]
[s7; [*C@3 ink]-|передний цвет для чётных рядов.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:OddRowColor`(Color`,Color`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* O
ddRowColor]([_^Color^ Color]_[*@3 paper]_`=_SColorInfo, [_^Color^ Color]_[*@3 ink]_`=_SCo
lorText)&]
[s2; Устанавливает цвета бумаги и чернил 
(фоновый и переднеплановый цвет) для 
нечётных рядов массива.&]
[s7; [*C@3 paper]-|фоновый цвет для первого, третьего, 
пятого и т.д. ряда&]
[s7; [*C@3 ink]-|переднеплановый цвет для нечётных 
рядов.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoCursor`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoCursor]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Включает / отключает подсветку курсорного 
ряда.&]
[s7; [*C@3 b]-|[* true] `= не подствечивать курсорный 
ряд, [* false] `= дефолтное поведение (курсорный 
ряд показан инверсными цветами)&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:MouseMoveCursor`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Mouse
MoveCursor]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Включает/ отключает автоматическое 
переключение курсорного ряда при 
перемещении курсора мыши над рядами 
массива.&]
[s7; [*C@3 b]-|[* true] `= автоматически включать 
курсорный ряд, [* false] `= только при кликах 
и клавиатурной навигации&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoMouseMoveCursor`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoMouse
MoveCursor]()&]
[s2; Отключить автоматическое переключение 
курсорного ряда (равноценно [* MouseMoveCursor(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AutoHideSb`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AutoHideSb
]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; При установке в [* true], вертикальная 
полоса промотки у правого края массива 
показана только тогда, когда общая 
высота ряда превышает высоту видимости 
массива. При установке в [* false], полоса 
промотки показана постоянно.&]
[s7; [*C@3 b]-|[* true] `= показать/ скрыть полосу 
промотки, [* false] `= показывать её без 
условия&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoAutoHideSb`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoAutoHideSb
]()&]
[s2; Постоянно показывать вертикальную 
полоку промотки (равнозначно [* AutoHideSb(false)]).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HideSb`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* HideSb]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Скрывает вертикальную полосу промотки 
(даже, если она необходима).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AutoHideHorzSb`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AutoHi
deHorzSb]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Заставляет автоматически скрываться 
полосу промотки (активно, только если 
HeaderCtrl в абсолютном режиме). По умолчанию 
включено.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoAutoHideHorzSb`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoAutoHi
deHorzSb]()&]
[s2; То же, что и AutoHideHorzSb(false).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HideHorzSb`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* HideHorzSb
]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Без условий скрывает горизонтальную 
полосу промотки (активно, только если 
HeaderCtrl в абсолютном режиме)).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:MultiSelect`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* MultiSele
ct]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Включает/ отключает выделение нескольких 
рядов. &]
[s7; [*C@3 b]-|[* true] `= позволить выделять сразу 
несколько рядов, [* false] `= только один 
ряд за один раз.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsMultiSelect`(`)const: [@(0.0.255) bool]_[* IsMultiSelect]()_[@(0.0.255) c
onst]&]
[s2; Возвращает true, если ArrayCtrl находится 
в режиме мультивыбора.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoBackground`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoBackgr
ound]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Устанавливает виджет в прозрачный 
режим: фон не отрисовывается и активируется 
режим прозрачности (Transparent),`- в итоге 
всё, что рисуется за виджетом видно, 
и это позволяет клиентскому коду 
обеспечивать любой необходимый фон.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:PopUpEx`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* PopUpEx]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Активирует показ небольших всплывающих 
окон с контентом ячейки, при наведении 
мыши, если ячейка большая и не помещается 
в текущие пропорции окна. По умолчанию 
активировано.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoPopUpEx`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoPopUpEx]()&]
[s2; То же, что и PopUpEx(false).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoFocusSetCursor`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoFocusS
etCursor]()&]
[s2; Как правило, когда ArrayCtrl получает 
фокус и нет установленного курсора 
(но курсор допустим и есть хотя бы 
одна строка), ArrayCtrl устанавливает 
курсор на первую строку. Этот модификатор 
отключает данную фичу.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:MovingHeader`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* MovingHe
ader]([@(0.0.255) bool]_[*@3 b])&]
[s2; Активирует перетяг колонок в `"чердаке`" 
(header). По умолчанию активировано.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoMovingHeader`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoMovingHe
ader]()&]
[s2; То же, что и MovingHeader(false).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnSortFindKey`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Col
umnSortFindKey]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Перед упорядочиванием ColumnSort`'ом элементов 
в ArrayCtrl`'е, сохраняется ключ текущего 
ряда (с курсором), а после сортировки 
он восстанавливается.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AllSorting`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AllSorting]()&]
[s2; Если установлено, вызывается Sorting() 
`- сортировка `- для всех колонок (добавляется
 либо до, либо после вызова этого модификатор
а).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnSortSecondary`(const ArrayCtrl`:`:Order`&`): [_^ArrayCtrl^ Arra
yCtrl][@(0.0.255) `&]_[* ColumnSortSecondary]([@(0.0.255) const]_[_^ArrayCtrl`:`:Order^ O
rder][@(0.0.255) `&]_[*@3 order])&]
[s2; Устанавливает второй предикат сортировки 
для сортировки колонок (смотрите 
ColumnSort, Sorting) `- если две ячейки одинаковы, 
при выполнении поколоночной сортировки, 
они упорядочиваются согласно этому 
предикату.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoColumnSortSecondary`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoC
olumnSortSecondary]()&]
[s2; Удаляет второй предикат сортировки.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SortingFrom`(int`):%- [_^Upp`:`:ArrayCtrl^ ArrayCtrl][@(0.0.255) `&
]_[* SortingFrom]([@(0.0.255) int]_[*@3 from])&]
[s2; При сортировке ArrayCtrl`'а (без указания 
диапазона строк), определяет первую 
сотрируемую колонку. При этом наличие 
`"чердака`" (header) или строки суммирования 
ничем не препятствует.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnWidths`(const char`*`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* C
olumnWidths]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 s])&]
[s2; Инициализует ширины колонок, основываясь 
на текстовой строке, содержащей разделённые
 пробелами десятичные цифры, например,. 
`"1 4 6 4 1`".&]
[s7; [*C@3 s]-|контрольная строка, задающая 
ширины колонок.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetColumnWidths`(`): [_^String^ String]_[* GetColumnWidths]()&]
[s2; Возвращает текущие ширины колонок 
в формате, совместимом с ColumnWidths.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:CursorOverride`(const Image`&`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&
]_[* CursorOverride]([@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 arrow])&]
[s2; Переписывает кусрор мыши как [*@3 arrow]. 
Установка Null заканчивает перезапись.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoCursorOverride`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoCursor
Override]()&]
[s2; То же, что и CursorOverride(Null).&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SpanWideCells`(bool`):%- [_^Upp`:`:ArrayCtrl^ ArrayCtrl][@(0.0.255) `&
]_[* SpanWideCells]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; В этом режиме, если контент ячейки 
(определённый Display`::GetStdSize) шире, чем 
ширина ячейки, а следующая ячейка 
равна Null (пустая), ширина ячейки расширяется 
до промежутка над следующей ячейкой 
(подобно как в большинстве приложений 
с spreadsheet). `"Чердак`" ArrayCtrl`'а, для корректности 
операции, не должен находиться в режиме 
перемещения Moving. Возвращает `*this.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:RowFormat`(const char`*`): [_^String^ String]_[* RowFormat]([@(0.0.255) c
onst]_[@(0.0.255) char]_`*[*@3 s])&]
[s2; Форматирует текст подстановкой вместо 
[* %s] специфичного для массива термина 
`'row`' (установленого свойством [* RowName 
](ИмяРяда)). Используется для элементов 
массива локального меню. Возвращает 
`*this.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:RowName`(const char`*`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* RowNa
me]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 s])&]
[s2; Устанавливает специфичный для массива 
термин `'row`'. Может использоваться 
для адаптации терминологии локального 
меню в соответствии с логическим 
контентом данного массива. Например, 
если имеется массив со списком сотрудников, 
можно вызвать [* RowName(`"сотрудник`")] и 
в элементах меню будет читаться [/ `'Вставить 
сотрудник (`-а)`', `'Удалить сотрудник 
(`-а)`'] и т.п.&]
[s7; [*C@3 s]-|термин для замены `'ряд массива`' 
в элементах меню&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s0;* &]
[s0; [*@(229)$(0.128.128)3 Программирование структуры 
колонки]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:IndexInfo`(int`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* Index
Info]([@(0.0.255) int]_[*@3 ii])&]
[s2; Возвращает ссылку на структуру [* IdInfo], 
описывающую заданный индекс массива( 
колонку в матрице исходных данных).&]
[s7; [*C@3 ii]-|порядковый номер (с основанием 
ноль) индекса массива&]
[s7; [*/ Возвратное значение]-|Ссылка на IdInfo 
для данного индекса&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IndexInfo`(const Id`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_
[* IndexInfo]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s2; Возвращает ссылку на структуру [* IdInfo], 
описывающую индекс данного массива.&]
[s7; [*C@3 id]-|идентификатор индекса&]
[s7; [*/ Возвратное значение]-|Ссылка на IdInfo 
для данного индекса&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddIndex`(const Id`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_
[* AddIndex]([@(0.0.255) const] [_^Id^ Id]`&_[*@3 id])&]
[s2; Добавляет новый индекс в массив и 
присваивает ему заданный идентификатор 
[* Id].&]
[s7; [*C@3 id]-|идентификатор нового индекса&]
[s7; [*/ Возвратное значение]-|Ссылка на структуру 
[* IdInfo, ]описывающую вновь добавленный 
индекс. Она может использоваться 
для установки дополнительных свойств 
индекса.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddIndex`(`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* AddIndex](
)&]
[s2; Добавляет в массив новый индекс (без 
идентификатора).&]
[s7; [*/ Возвратное значение]-|Ссылка на структуру 
[* IdInfo, ]описывающую вновь добавленный 
индекс.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetIndexCount`(`)const: [@(0.0.255) int]_[* GetIndexCount]()_[@(0.0.255) c
onst]&]
[s2; Возвращает число индексов в массиве.&]
[s7; [*/ Возвратное значение]-|число индексов&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetId`(int`)const: [_^Id^ Id]_[* GetId]([@(0.0.255) int]_[*@3 ii])_[@(0.0.255) c
onst]&]
[s2; Возвращает идентификатор данного 
индекса (адресуясь по его порядковому 
номеру с основанием ноль).&]
[s7; [*C@3 ii]-|порядковый номер опрашиваемого 
индекса, с основанием ноль&]
[s7; [*/ Возвратное значение]-|идентификатор 
индекса или [* Null], если у индекса нет 
идентификатора&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetPos`(const Id`&`)const: [@(0.0.255) int]_[* GetPos]([@(0.0.255) const 
][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Возвращает позиционный номер индекса 
массива с основанием ноль, у которого 
указанный идентификатор.&]
[s7; [*C@3 id]-|идентификатор индекса массива&]
[s7; [*/ Возвратное значение]-|индексное 
число с основанием ноль, `-1, если не 
найден.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetId`(int`,const Id`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&
]_[* SetId]([@(0.0.255) int]_[*@3 ii], [@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s2; Устанавливает идентификатор для 
указанного индекса массива. Может 
использоваться для установки или 
изменения идентификатора для ранее 
добавленного индекса.&]
[s7; [*C@3 ii]-|порядковый номер индекса с основанием 
ноль, для которого устанавливается 
этот идентификатор&]
[s7; [*C@3 id]-|новый идентификатор индекса 
([* Null], когда нет)&]
[s7; [*/ Возвратное значение]-|Ссылка на описательну
ю структуру [* IdInfo] для [/ ii]`-ного индекса. 
Ссылка может использоваться для установки 
дополнительных свойств изменяемого 
индекса.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddKey`(const Id`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* A
ddKey]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s2; Добавляет индекс [/ первичного ключа] 
в эту таблицу. [/ Первичный ключ] `- это 
просто ещё одно имя для первого индекса 
(индекса с порядковым номером 0). Это 
удобное соглашение, часто используемое 
для таблиц на основе SQL. [* AddKey] может 
быть вызван только один раз после 
инициализации массива или его сброса 
через [* Reset], и до вызова любых иных 
функций, добавляющих индексы (типа 
[* AddIndex], [* AddColumn] или [* AddCtrl]). Когда [* GetIndexCount() 
> 0, ]ещё до вызова этой функции, то 
у этого метода не срабатывает [* ASSERT].&]
[s7; [*C@3 id]-|идентификатор первичного ключа&]
[s7; [*/ Возвратное значение]-|Ссылка на описательну
ю структуру [* IdInfo] для индекса первичного 
ключа.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddKey`(`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* AddKey]()&]
[s2; Добавляет в таблицу индекс первичного 
ключа без идентификатора. Равноценно 
[* AddKey(Null)].&]
[s7; [*/ Возвратное значение]-|Ссылка на описательну
ю структуру [* IdInfo] для индекса первичного 
ключа.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetKeyId`(`)const: [_^Id^ Id]_[* GetKeyId]()_[@(0.0.255) const]&]
[s2; Возвращает идентификатор первичного 
ключа для данной таблицы. Равноценно 
вызову [* GetId(0)].&]
[s7; [*/ Возвратное значение]-|идентификатор 
индекса первичного ключа.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddColumn`(const char`*`,int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* AddColumn]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 text]_`=_NULL, 
[@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Добавляет в таблицу новую пару колонка`-инде
кс. Функция добавляет индекс (источника) 
и колонку (вывода) и устанавливает 
этот индекс как источник данных для 
этой колонки. Это самый общий метод 
добавдения колонок в массив.&]
[s7; [*C@3 text]-|имя колонки (отображается в 
заголовочнике массива)&]
[s7; [*C@3 w]-|логическая относительная ширина 
колонки&]
[s7; [*/ Возвратное значение]-|Ссылка на структуру 
[* Column], описывающую вновь добавляемую 
колонку. Может использоваться для 
установки дополнительных свойств 
вновь добавленной колонки и соответствующей
 вкладки`-заголовочника.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddColumn`(const Id`&`,const char`*`,int`): [_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* AddColumn]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], 
[@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 text], [@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Добавляет в таблицу новую пару колонка`-инде
кс. Эквивалентна версии выше с двумя 
параметрами, но, в дополнение, устанавливает
 идентификатор [* Id] для вновь созданного 
индекса.&]
[s7; [*C@3 id]-|новый идентификатор индекса&]
[s7; [*C@3 text]-|имя колонки отображается в 
заголовочнике)&]
[s7; [*C@3 w]-|логическая относительная ширина 
колонки&]
[s7; [*/ Возвратное значение]-|Ссылка на структуру 
[* Column], описывающую вновь добавляемую 
колонку массива.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddColumnAt`(int`,const char`*`,int`): [_^ArrayCtrl`:`:Column^ Column
][@(0.0.255) `&]_[* AddColumnAt]([@(0.0.255) int]_[*@3 ii], [@(0.0.255) const]_[@(0.0.255) ch
ar]_`*[*@3 text], [@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Добавляет в таблицу новую колонку 
и привязывает её к данному индексу 
источника данных.&]
[s7; [*C@3 ii]-|порядковый номер индекса (с нулевым 
основанием), используемого в качестве 
источника для этой колонки&]
[s7; [*C@3 text]-|имя колонки (отображаемое в 
заголовочнике)&]
[s7; [*C@3 w]-|логическая относительная ширина 
колонки&]
[s7; [*/ Возвратное значение]-|Ссылка на структуру 
[* Column], описывающую вновь добавляемую 
колонку массива.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddColumnAt`(const Id`&`,const char`*`,int`): [_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* AddColumnAt]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], 
[@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 text], [@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Добавляет в таблицу новую колонку 
и прявязывает её к указанному индексу 
исходных данных.&]
[s7; [*C@3 id]-|идентификатор индекса, используемого 
в качестве источника для вновь добавленной 
колонки&]
[s7; [*C@3 text]-|имя колонки (отображаемое в 
заголовочнике)&]
[s7; [*C@3 w]-|логическая относительная ширина 
колонки&]
[s7; [*/ Возвратное значение]-|Ссылка на структуру 
[* Column], описывающую вновь добавляемую 
колонку массива.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddRowNumColumn`(const char`*`,int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* AddRowNumColumn]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 text], 
[@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Добавляет в таблицу новую колонку. 
У вновь добавленной колонки нет индекса 
источника, предполагается, что у неё 
внешний источник данных. Вместо объекта 
исходных данных [* Value], методам колонки 
[* Convert] / [* Display ]передаётся текущий номер 
ряда (с нулевым основанием). Это позволяет 
хостовому приложению каким`-то образом 
декодировать внешние данные, основываясь 
на номере ряда. В текущей версии U`+`+, 
невозможно добавить [/ RowNum колонок] 
(используя стандартный механизм инлайн`-реда
ктирования массива).&]
[s7; [*C@3 text]-|имя колонки (отображаемое в 
заголовочнике)&]
[s7; [*C@3 w]-|логическая относительная ширина 
колонки&]
[s7; [*/ Возвратное значение]-|Ссылка на структуру 
[* Column], описывающую вновь добавляемую 
колонку массива.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddCtrl`(Ctrl`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* AddC
trl]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; Добавляет в таблицу новую пару индекс`-контр
ол; этот индекс хранит исходные данные, 
а внешний контрол используется для 
их редактирования. Этот ArrayCtrl обрабатывает 
обмен данными между матрицей исходных 
данных и внешним контролом. Метод 
возвращает ссылку на описательную 
структуру [* IdInfo] для вновь добавленного 
индекса.&]
[s2; [* Примечание:] Полезно знать о том, 
что между простыми редакторами ячеек 
массива и отдельными контролами`-редакторам
и есть некоторые важные отличия. В 
отличие от первых, которые появляются 
только при открытии ряда для редактирования
, второй присутствует постоянно. Например, 
ArrayCtrl автоматически отключает эти 
контролы, когда курсор покидает таблицу 
(используя [* KillCursor]) и включает их вновь, 
когда он возвращается. Это важно, 
например, если нужно реализовать 
дополнительную логику, включающую 
некоторые контролы только по обстоятельства
м; в таких случаях нужно использовать 
один из уведомительных обрвызовов 
(типа  [* WhenEnterRow]), чтобы применять над 
контролами дополнительное поведение.&]
[s7; [*C@3 ctrl]-|контрол, прикрепляемый к данному 
индексу&]
[s7; [*/ Возвратное значение]-|ссылка на структуру 
IdInfo, описывающую вновь добавляемый 
индекс&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddCtrl`(const Id`&`,Ctrl`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&
]_[* AddCtrl]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl
])&]
[s2; Добавляет в таблицу новую пару индекс`-контр
ол. Идентично версии выше, единственное 
различие в том, что вновь добавляемому 
индексу одновременно присваивается 
идентификатор [* Id].&]
[s7; [*C@3 id]-|идентификатор, присваиваемый 
вновь добавляемому индексу&]
[s7; [*C@3 ctrl]-|отдельный контрол, используемый 
для редактирования данного индекса&]
[s7; [*/ Возвратное значение]-|ссылка на структуру 
IdInfo, описывающую вновь добавляемый 
индекс&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddIdCtrl`(Ctrl`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* Ad
dIdCtrl]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; То же, что и AddCtrl(ctrl.GetLayoutId(), ctrl). Полезна 
при добавлении виджетов`-диалогов, 
идентификаторы которых совпадают 
с идентификатором переменной виджета.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddCtrlAt`(int`,Ctrl`&`): [@(0.0.255) void]_[* AddCtrlAt]([@(0.0.255) int
]_[*@3 ii], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; Добавляет в таблицу новый контрол 
и привязывает его к индексу с указанным 
порядковым номером. Можно использовать 
для создания привязки между контролом 
и произвольным индексом источника.&]
[s7; [*C@3 ii]-|порядковый номер индекса, с нулевым 
основанием, привязываемый к данному 
контролу&]
[s7; [*C@3 ctrl]-|отдельный контрол, используемый 
для редактирования [/ ii]`-ного индекса&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddCtrlAt`(const Id`&`,Ctrl`&`): [@(0.0.255) void]_[* AddCtrlAt]([@(0.0.255) c
onst ][_^Id^ Id]`&_[*@3 id], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; Добавляет новый контрол в таблицу 
и привязывает его к индексу с указанным 
идентификатором.&]
[s7; [*C@3 id]-|идентификатор индекса, привязываемого 
к этому контролу&]
[s7; [*C@3 ctrl]-|отдельный контрол, используемый 
для редактирования индекса с идентификаторо
м [/ id]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddRowNumCtrl`(Ctrl`&`): [@(0.0.255) void]_[* AddRowNumCtrl]([_^Ctrl^ Ctr
l][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; Добавляет в таблицу новый отдельный 
контрол. Контрол не привязывается 
ни к какому индексу исходных данных. 
При движении курсора в массиве, используется
 метод контрола [* SetData], для установки 
его в номер текущего ряда. Контрол 
должен быть к этому готов и использовать 
значение номера ряда для декодирования 
неких внешне расположенных данных, 
чтобы отобразить их. В текущей версии 
U`+`+, такие контролы для редактирования 
использовать нельзя (пока нет ясного 
метода сохранения отредактированных 
данных назад во внешнее хранилище).&]
[s7; [*C@3 ctrl]-|отдельный контрол`-редактор 
на основе [/ RowNum (номера ряда)]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetColumnCount`(`)const: [@(0.0.255) int]_[* GetColumnCount]()_[@(0.0.255) c
onst]&]
[s2; Возвращает текущее число (выводных) 
колонок в массиве.&]
[s7; [*/ Возвратное значение]-|число колонок&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:FindColumnWithPos`(int`)const: [@(0.0.255) int]_[* FindColumnWithPos]([@(0.0.255) i
nt]_[*@3 pos])_[@(0.0.255) const]&]
[s2; Возвращает индекс первой колонки 
(с основанием ноль), основываясь на 
индексе её исходных данных, или `-1, 
если не найден. Заметьте, что может 
быть несколько колонок, связанных 
с единичным источником, `- в этом случае 
функция возвращает индекс первой, 
обнаруженной. Используйте FindColumnsWithPos, 
если нужны все.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:FindColumnWithId`(const Id`&`)const: [@(0.0.255) int]_[* FindColumnWith
Id]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Возвращает индекс первой колонки 
(с основанием ноль), основываясь на 
идентификаторе её исходных данных, 
или `-1, если не найден.  Заметьте, что 
может быть несколько колонок, связанных 
с единичным источником, `- в этом случае 
функция возвращает индекс первой, 
обнаруженной. Используйте FindColumnsWithId, 
если нужны все.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:FindColumnsWithPos`(int`)const:%- [_^Upp`:`:Vector^ Vector]<[@(0.0.255) i
nt]>_[* FindColumnsWithPos]([@(0.0.255) int]_[*@3 pos])_[@(0.0.255) const]&]
[s2; Возвращает индексы всех колонок 
с основанием ноль, основанные на индексе 
исходных данных или `-1, если он не 
найден.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:FindColumnsWithId`(const Upp`:`:Id`&`)const:%- [_^Upp`:`:Vector^ V
ector]<[@(0.0.255) int]>_[* FindColumnsWithId]([@(0.0.255) const]_[_^Upp`:`:Id^ Id][@(0.0.255) `&
]_[*@3 id])_[@(0.0.255) const]&]
[s2; Возвращает индексы всех колонок, 
с основанием ноль, основанные на идентификат
оре исходных данных [%-*@3 id], или `-1, если 
он не найден.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnAt`(int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* Column
At]([@(0.0.255) int]_[*@3 i])&]
[s2; Возвращает структуру [* Column], описывающую 
данную колонку.&]
[s7; [*C@3 i]-|индекс колонки с основанием ноль&]
[s7; [*/ Возвратное значение]-|ссылка на структуру 
[* Column, ]описывающую данную колонку&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnAt`(const Id`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_
[* ColumnAt]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s7; [*C@3 i]-|индекс колонки с основанием ноль&]
[s7; [*/ Возвратное значение]-|константная 
ссылка на структуру [* Column, ]описывающую 
данную колонку&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnAt`(int`)const: [@(0.0.255) const]_[_^ArrayCtrl`:`:Column^ Column
][@(0.0.255) `&]_[* ColumnAt]([@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2; Возвращает структуру [* Column], описывающую 
колонку с данным индексом источника. 
Это const`-версия метода выше; её можно 
использовать для опроса свойств колонки.&]
[s7; [*C@3 id]-|идентификатор индекса, используемого 
как источник для колонки&]
[s7; [*/ Возвратное значение]-|ссылка на структуру 
[* Column], описывающую данную колонку&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnAt`(const Id`&`)const: [@(0.0.255) const]_[_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* ColumnAt]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) cons
t]&]
[s2; Возвращает константную ссылку на 
структуру [* Column], описывающую колонку 
с данным исходным индексом. Это константная 
версия метода выше; её можно использовать 
для опроса свойств колонки.&]
[s7; [*C@3 id]-|идентификатор индекса, используемого 
как источник для колонки&]
[s7; [*/ Возвратное значение]-|константная 
ссылка на структуру [* Column], описывающую 
данную колонку&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderTab`(int`): [_^HeaderCtrl`:`:Column^ HeaderCtrl`::Column][@(0.0.255) `&
]_[* HeaderTab]([@(0.0.255) int]_[*@3 i])&]
[s2; Возвращает описательную структуру 
[*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`_ru`-ru`#Upp`:`:HeaderCtrl`:`:Column`:`:Min`(int`)^ H
eaderCtrl`::Column]  для данной колонки. Соответствие 
между колонками массива и вкладками 
заголовочниками равно 1:1, так что индексы 
обоих всегда одинаковы ([* array.GetColumnCount() 
`=`= array.HeaderObject().GetCount()] сохраняется 
всегда).&]
[s7; [*C@3 i]-|индекс колонки с основанием ноль&]
[s7; [*/ Возвратное значение]-|ссылка на структуру 
[* HeaderCtrl`::Column]. Может использоваться 
для установки дополнительных свойств 
колонки`-заголовочника (напр., колонки 
с констрейнтами, шрифтом и иконкой 
для титула колонки и проч.)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderTab`(int`)const: [@(0.0.255) const]_[_^HeaderCtrl`:`:Column^ Head
erCtrl`::Column][@(0.0.255) `&]_[* HeaderTab]([@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2; Возвращает константную ссылку на 
структуру [* HeaderCtrl`::Column] для данной колонки.&]
[s7; [*C@3 i]-|индекс колонки с основанием ноль&]
[s7; [*/ Возвратное значение]-|ссылка на структуру 
[* HeaderCtrl`::Column]. Может использоваться 
для установки дополнительных свойств 
колонки`-заголовочника (напр., колонки 
с констрейнтами, шрифтом и иконкой 
для титула колонки и проч.)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderTab`(const Id`&`): [_^HeaderCtrl`:`:Column^ HeaderCtrl`::Column][@(0.0.255) `&
]_[* HeaderTab]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s2; Возвращает ссылку на описательную 
структуру [* HeaderCtrl`::Column] для колонки, 
привязанной к данному индексу источника.&]
[s7; [*C@3 id]-|идентификатор индекса, используемый 
как источник для этой колонки&]
[s7; [*/ Возвратное значение]-|ссылка на структуру 
[* HeaderCtrl`::Column]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderTab`(const Id`&`)const: [@(0.0.255) const]_[_^HeaderCtrl`:`:Column^ H
eaderCtrl`::Column][@(0.0.255) `&]_[* HeaderTab]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) c
onst]&]
[s2; Возвращает константную ссылку на 
описательную структуру [* HeaderCtrl`::Column] 
для колонки, привязанной к данному 
индексу источника.&]
[s7; [*C@3 id]-|идентификатор индекса, используемый 
как источник для этой колонки&]
[s7; [*/ Возвратное значение]-|константная 
ссылка на структуру [* HeaderCtrl`::Column]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderObject`(`)const: [@(0.0.255) const]_[_^HeaderCtrl^ HeaderCtrl][@(0.0.255) `&
]_[* HeaderObject]()_[@(0.0.255) const]&]
[s2; Возвращает неконстантную ссылку 
на объект [* HeaderCtrl] для этой таблицы. 
Эту ссылку далее можно использовать 
для изменения свойств заголовочника 
таблицы (видимости вкладки, режима 
видимости заголовочника и проч.).&]
[s7; [*/ Возвратное значение]-|Неконстантная 
ссылка на объект таблицы HeaderCtrl.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderObject`(`): [_^HeaderCtrl^ HeaderCtrl][@(0.0.255) `&]_[* HeaderObje
ct]()&]
[s2; Константная версия метода выше; при 
вызове из константной ссылки на [* ArrayCtrl], 
возвращает константную ссылку на 
лежащий под ним объект HeaderCtrl, который 
затем можно использовать для запроса 
дополнительной информации о заголовочнике.&]
[s7; [*/ Возвратное значение]-|Константная 
ссылка на объект таблицы HeaderCtrl.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SerializeHeader`(Stream`&`): [@(0.0.255) void]_[* SerializeHeader]([_^Stream^ S
tream][@(0.0.255) `&]_[*@3 s])&]
[s2; Сериализует всю информацию, касающуюся 
заголовочника массива (в основном 
установленных пользователем ширин 
колонок). Эквивалентно вызову [* HeaderObject().Serialize(
s)]. Основное назначение этой функции 
`- позволить сохранить конфигурацию 
заголовочника, чтобы восстановить 
её при открытии диалогового окна 
или приложения в следующий раз. Сейчас 
эта функция депрекирована в пользу 
SerializeSettings.&]
[s7; [*C@3 s]-|объект потока [*^topic`:`/`/Core`/src`/Stream`$en`-us^ Stream] 
для сериализации/десериализации 
заголовочника&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SerializeSettings`(Stream`&`): [@(0.0.255) void]_[* SerializeSettings](
[_^Stream^ Stream][@(0.0.255) `&]_[*@3 s])&]
[s2; Сериализует всю информацию, касающуюся 
заголовочника массива (в основном 
установленных пользователем ширин 
колонок) и настроек колонки сортировки. 
Основное назначение этой функции 
`- позволить сохранить конфигурацию 
заголовочника, чтобы восстановить 
её при открытии диалогового окна 
или приложения в следующий раз.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetDisplay`(int`,int`,const Display`&`): [@(0.0.255) void]_[* SetDispla
y]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col], [@(0.0.255) const]_[_^Display^ Displ
ay][@(0.0.255) `&]_[*@3 d])&]
[s2; Устанавливает объект [* Display] для данной 
ячейки массива.&]
[s2;* &]
[s2; [* Примечание:] владение объектом Display 
этим вызовом не передаётся. Данный 
ArrayCtrl сохраняет лишь указатель на 
него, сохранять объект Display столько, 
сколько нужно, должен программист 
(пока массив не свёрнут или отображение 
ячейки не изменено ещё одним вызовом 
SetDisplay). Фактически, большинство объектов 
класса Display вообще не поддерживает 
копирование данных. В любом случае, 
копирование дисплеев `- не самая лучшая 
практика и часто приводит к срезанию(slicing) 
(так как болшинство дисплеев в реале 
представляют собой производные классы 
с дополнительными членами данных).&]
[s2; &]
[s2; В большинстве случаев относительно 
безопасно полагать, что Display не используется
, если массив реально не отрисован 
(напр., когда контрол не привязан к 
родителю или у его области видимости 
нулевой размер), но это не вполне разумная 
практика, которая при некоторых обстоятельс
твах может привести к сбою (например, 
при захвате скриншотов или экспорте 
графики из контрола массива).&]
[s2; &]
[s7; [*C@3 i]-|индекс ряда с нулевым основанием&]
[s7; [*C@3 j]-|индекст колонки с нулевым основанием&]
[s7; [*C@3 d]-|используемый дисплей&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SetRowDisplay`(int`,const Upp`:`:Display`&`):%- [@(0.0.255) vo
id]_[* SetRowDisplay]([@(0.0.255) int]_[*@3 i], [@(0.0.255) const]_[_^Upp`:`:Display^ Displ
ay][@(0.0.255) `&]_[*@3 d])&]
[s2; Устанавливает Display [%-*@3 d] для каждой 
ячейки строки [%-*@3 i].&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SetColumnDisplay`(int`,const Upp`:`:Display`&`):%- [@(0.0.255) v
oid]_[* SetColumnDisplay]([@(0.0.255) int]_[*@3 j], [@(0.0.255) const]_[_^Upp`:`:Display^ D
isplay][@(0.0.255) `&]_[*@3 d])&]
[s2; Устанавливает Display [%-*@3 d] для каждой 
ячейки колонки j.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetDisplay`(int`,int`): [@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&
]_[* GetDisplay]([@(0.0.255) int]_[*@3 row], [@(0.0.255) int]_[*@3 col])&]
[s2; Возвращает ссылку на объект Display 
для данной ячейки массива.&]
[s7; [*C@3 row]-|индекс ряда с нулевым основанием&]
[s7; [*C@3 col]-|индекс колонки с нулевым основанием&]
[s7; [*/ Возвратное значение]-|ссылка на объект 
Display.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetDisplay`(int`): [@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_
[* GetDisplay]([@(0.0.255) int]_[*@3 col])&]
[s2; Возвращает ссылку на объект Display 
для данной колонки массива.&]
[s7; [*C@3 col]-|индекс колонки с нулевым основанием&]
[s7; [*/ Возвратное значение]-|константная 
ссылка на Display колонки&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetCtrl`(int`,int`,Ctrl`&`,bool`): [@(0.0.255) void]_[* SetCtrl]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) int]_[*@3 col], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl], 
[@(0.0.255) bool]_[*@3 value]_`=_[@(0.0.255) true])&]
[s2; Устанавливает внеешний контрол, 
используемый в качестве редактора 
для единичной ячейки массива. Естественно, 
что один и тот же объект Ctrl нельзя 
использовать для редактирования 
множества ячеек массива. Если позиция 
Ктрла эквивалентна `'SetRect(0, 0, 0, 0)`', 
что является дефолтным значением, 
то Ctrl меняется в размере, пока точно 
не помещается в ячейку ArrayCtrl, спанируя 
всю ширину и используя STDSIZE для высоты, 
иначе эта позиция представляет позицию 
внутри ячейки. Если [*@3 value] равно true, 
то Ctrl представляет собой значение 
ячейки, иначе он не зависит от него.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCtrl`(int`,int`): [_^Ctrl^ Ctrl]_`*[* GetCtrl]([@(0.0.255) int]_[*@3 i],
 [@(0.0.255) int]_[*@3 col])&]
[s2; Возвращает указатель на контрол 
в ряду [*@3 i] и колонке [*@3 col], если таковая 
имеется, NULL `- в противном случае.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:CreateCtrl`(int`,int`,bool`): [@(0.0.255) template]_<[@(0.0.255) class]_
[*@4 T]>_[*@4 T][@(0.0.255) `&]_[* CreateCtrl]([@(0.0.255) int]_[*@3 i], 
[@(0.0.255) int]_[*@3 col], [@(0.0.255) bool]_[*@3 value]_`=_[@(0.0.255) true])&]
[s2; Создаёт контрол (которым владеет 
ArrayCtrl) для единичной ячейки массива. 
Если [*@3 value] равно true, то этот контрол 
представляет собой значение этой 
ячейки, иначе он независим от него. 
Если позиция контрола эквивалентна 
`'SetRect(0, 0, 0, 0)`', что является дефолтным 
значением, то Ctrl перемеривается, пока 
не поместится в ячейку ArrayCtrl, спанируя 
всю ширину и используя STDSIZE для высоты, 
иначе эта позиция представляет собой 
позицию внутри этой ячейки. &]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetTotalCy`(`)const: [@(0.0.255) int]_[* GetTotalCy]()_[@(0.0.255) const]&]
[s2; Возвращает общую высоту массива 
(сумму высот индивидуальных строк 
для всех рядов массива)&]
[s7; [*/ Возвратное значение]-|высота массива 
в пикселях&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetLineAt`(int`)const: [@(0.0.255) int]_[* GetLineAt]([@(0.0.255) int]_[*@3 y
])_[@(0.0.255) const]&]
[s2; Лоцирует ряд массива, согласно указанной 
координате (такой ряд массива [/ r], для 
которого [* GetLineY(r) <`= y `&`& GetLineY(r) `+ GetLineCy(r) 
> y]).&]
[s7; [*C@3 y]-|вертикальная пиксельная координата 
для лоцирования&]
[s7; [*/ Возвратное значение]-|номер ряда 
с основанием ноль или `-1, если не найден&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SetLineColor`(int`,Upp`:`:Color`):%- [@(0.0.255) void]_[* SetLin
eColor]([@(0.0.255) int]_[*@3 i], [_^Upp`:`:Color^ Color]_[*@3 c])&]
[s2; Устанавливает фоновый цвет строки 
[%-*@3 i] в [%-*@3 c].&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetCellRect`(int`,int`)const:%- [_^Upp`:`:Rect^ Rect]_[* GetCell
Rect]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Возвращает прямоугольник ячейки 
по [%-*@3 i],[%-*@3  col] в координатах видимости. 
Левая и правая кромки ячейки включаются 
в него.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetCellRectM`(int`,int`)const:%- [_^Upp`:`:Rect^ Rect]_[* GetCel
lRectM]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Возвращает прямоугольник ячейки 
по [%-*@3 i],[%-*@3  col] в координатах видимости. 
Левая и правая кромки ячейки не включаются 
в него.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetScreenCellRect`(int`,int`)const:%- [_^Upp`:`:Rect^ Rect]_[* G
etScreenCellRect]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Возвращает прямоугольник ячейки 
по [%-*@3 i],[%-*@3  col] в координатах экрана. 
Левая и правая кромки ячейки включаются 
в него.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetScreenCellRectM`(int`,int`)const:%- [_^Upp`:`:Rect^ Rect]_[* G
etScreenCellRectM]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Возвращает прямоугольник ячейки 
по [%-*@3 i],[%-*@3  col] в координатах экрана. 
Левая и правая кромки ячейки не включаются 
в него.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetClickColumn`(`)const: [@(0.0.255) int]_[* GetClickColumn]()_[@(0.0.255) c
onst]&]
[s2; Возвращает индекс колонки последней 
кликнутой колонки в массиве. Если 
клик происходит за последним рядом 
массива, возвращается Null.&]
[s7; [*/ Возвратное значение]-|индекс соответствующ
ей колонки с нулевым основанием&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetClickRow`(`)const: [@(0.0.255) int]_[* GetClickRow]()_[@(0.0.255) cons
t]&]
[s2; Возвращает индекс колонки последнего 
кликнутого ряда в массиве. Если клик 
происходит за последним рядом массива, 
возвращается Null.&]
[s7; [*/ Возвратное значение]-|индекс соответствующ
ей колонки с нулевым основанием&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetClickPos`(`)const: [_^Point^ Point]_[* GetClickPos]()_[@(0.0.255) cons
t]&]
[s7; [*/ Возвратное значение]-|[* Point(GetClickColumn(), 
GetClickRow())].&]
[s3; &]
[s0;* &]
[s0; [*@(229)$(0.128.128)3 Установка и получение 
данных]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:SetCount`(int`): [@(0.0.255) void]_[* SetCount]([@(0.0.255) int]_[*@3 c])&]
[s2; Устанавливает число рядов в массиве. 
При необходимости расширяет или уменьшает 
исходную матрицу. При использовании 
индивидуальных редакторов ячеек 
на базе Ктрла, могут конструироваться 
или разрушаться некоторые контролы 
в качестве побочного эфекта этого 
вызова&]
[s7; [*C@3 c]-|новый счёт рядов&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetVirtualCount`(int`): [@(0.0.255) void]_[* SetVirtualCount]([@(0.0.255) i
nt]_[*@3 c])&]
[s2; Устанавливает число рядов в массиве 
с внешними данными. Имеет смысл только 
тогда, когда все [/ Column`'ы и] [/ Ctrl`'ы] этого 
массива основаны на [/ rownum (номере ряда)]. 
Эта функция физически не размещает 
никакого пространства под матрицу 
исходных данных, просто заставляет 
этот массив `'думать`', что у него [*/@3 c] 
рядов (это, конечно же, необходимо 
для процедуры Paint, для управления 
курсором / выделением и проч.).&]
[s2; [* Примечание:] в текущей реализации, 
флаги выделения для индивидуальных 
рядов хранятся в их объектах. Следовательно,
 не очень разумно использовать мультивыбор 
для массивов с внешними данными, так 
как, как только выделен последний 
ряд, все структуры хранения рядов 
размещаются в памяти, в качестве побочного 
эффекта, чтобы сохранить флаги выделения.&]
[s7; [*C@3 c]-|новое `'виртуальное`' число рядов&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCount`(`)const: [@(0.0.255) int]_[* GetCount]()_[@(0.0.255) const]&]
[s2; Возвращает число рядов в массиве. 
Фактически, возвращается максимум 
числа `'реальных`' рядов исходной матрицы 
(установленной методами SetCount / Add / 
Insert) и `'виртуальное`' число рядов (установлен
ное методом SetVirtualCount). Это легко обнаруживает
ся, если проверить реализацию данного 
метода,&]
[s2; &]
[s2; [C int ArrayCtrl`::GetCount() const `{]&]
[s2; [C -|-|return max(virtualcount, array.GetCount());]&]
[s2; [C `}]&]
[s2; &]
[s7; [*/ Возвратное значение]-|Число рядов 
в массиве.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Clear`(`): [@(0.0.255) void]_[* Clear]()&]
[s2; Очищает матрицу исходных данных 
массива и устанавливает виртуальное 
число рядов в 0.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Shrink`(`): [@(0.0.255) void]_[* Shrink]()&]
[s2; Сжимает массив исходных данных, т.е. 
реаллоцирует данные в пределах минимального
 требуемого пространства памяти.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Get`(int`,int`)const: [_^Value^ Value]_[* Get]([@(0.0.255) int]_[*@3 i], 
[@(0.0.255) int]_[*@3 ii])_[@(0.0.255) const]&]
[s2; Возвращает значение по заданной 
локации в матрице исходных данных.&]
[s7; [*C@3 i]-|номер ряда с основанием ноль&]
[s7; [*C@3 ii]-|порядковый номер индекса с основанием 
ноль&]
[s7; [*/ Возвратное значение]-|значение по 
заданной локации в матрице исходных 
данных&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Get`(int`,const Id`&`)const: [_^Value^ Value]_[* Get]([@(0.0.255) int]_[*@3 i
], [@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Возвращает значение по заданной 
локации в матрице исходных данных. 
В этой версии, адресация к исходным 
индексам ведётся по их идентификаторам.&]
[s7; [*C@3 i]-|номер ряда с нулевым основанием&]
[s7; [*C@3 id]-|идентификатор исходного индекса&]
[s7; [*/ Возвратное значение]-|значение по 
заданной локации в матрице исходных 
данных&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Get`(int`)const: [_^Value^ Value]_[* Get]([@(0.0.255) int]_[*@3 ii])_[@(0.0.255) c
onst]&]
[s2; Возвращает значение указанного исходного 
индекса в текущем активном курсорном 
ряде. Эквивалентно [* Get(GetCursor(), ii)]. Если 
ряд в настоящее время редактируется, 
то эта функция возвращает `'новое`' 
значение (текущее значение соответствующего
 контрола`-редактора, т.е. потенциально 
отредактированное).&]
[s2; [* Примечание:] когда курсорный ряд 
не установлен (при [* !IsCursor()]), у этой 
функции не срабатывает [* ASSERT].&]
[s7; [*C@3 ii]-|порядковый номер индекса с нулевым 
основанием&]
[s7; [*/ Возвратное значение]-|значение по 
заданной локации в курсорном ряде&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Get`(const Id`&`)const: [_^Value^ Value]_[* Get]([@(0.0.255) const 
][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Возвращает значение заданного исходного 
индекса в текущем активном курсорном 
ряде. Эквивалентно [* Get(GetCursor(), id)].&]
[s7; [*C@3 id]-|идентификатор исходного индекса&]
[s7; [*/ Возвратное значение]-|значение по 
указанной локации в курсорном ряде&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetOriginal`(int`)const: [_^Value^ Value]_[* GetOriginal]([@(0.0.255) int
]_[*@3 ii])_[@(0.0.255) const]&]
[s2; Возвращает `'оригинальное`' значение 
заданного исходного индекса в текущем 
активном курсорном ряде. Когда ряд 
открыт для редактирования, эта функция 
возвращает `'старое`' значение, которое 
было до начала всякого редактирования.&]
[s7; [*C@3 ii]-|порядковый номер индекса с нулевым 
основанием&]
[s7; [*/ Возвратное значение]-|значение по 
указанной локации в курсорном ряде&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetOriginal`(const Id`&`)const: [_^Value^ Value]_[* GetOriginal]([@(0.0.255) c
onst ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Возвращает `'оригинальное`' значение 
(т.е., без применения какого`-либо редактирова
ния) указанного исходного индекса 
в текущем активном курсорном ряде.&]
[s7; [*C@3 id]-|идентификатор исходного индекса&]
[s7; [*/ Возвратное значение]-|значение по 
заданной локации в курсорном ряде&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetKey`(`)const: [_^Value^ Value]_[* GetKey]()_[@(0.0.255) const]&]
[s2; Возвращает значение первичного ключа 
текущего ряда. Эквивалентно [* Get(0)].&]
[s7; [*/ Возвратное значение]-|значение по 
индексу #0 в курсорном ряде&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetOriginalKey`(`)const: [_^Value^ Value]_[* GetOriginalKey]()_[@(0.0.255) c
onst]&]
[s2; Возвращает оригинальное значение 
первичного ключа текущего ряда. При 
редактировании, эта функция возвращает 
значение, которое было при открытии 
ряда для редактирования, т.е. без применения 
изменений редактирования. Эквивалентно 
[* GetOriginal(0)].&]
[s7; [*/ Возвратное значение]-|значение по 
индексу #0 в курсорном ряде&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,int`,const Value`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) int
]_[*@3 i], [@(0.0.255) int]_[*@3 ii], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v
])&]
[s2; Устанавливает значение по указанной 
локации в матрице исходных данных.&]
[s7; [*C@3 i]-|номер ряда с основанием ноль&]
[s7; [*C@3 ii]-|порядковый номер индекса с основанием 
ноль&]
[s7; [*C@3 v]-|значение, устанавливаемое в данную 
ячейку&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,const Id`&`,const Value`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&
]_[*@3 v])&]
[s2; Устанавливает значение по заданной 
локации в матрице исходных данных. 
&]
[s7; [*C@3 i]-|номер ряда с основанием ноль&]
[s7; [*C@3 id]-|идентификатор исходного индекса&]
[s7; [*C@3 v]-|значение, устанавливаемое в данную 
ячейку&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,const Value`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) int]_[*@3 i
i], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2; Изменяет значение по заданной локации 
в курсорном ряде. Когда этот ряд открыт 
для редактирования, функция тотчас 
же меняет значение в соответствующем 
контроле`-редакторе.&]
[s7; [*C@3 ii]-|порядковый номер индекса с основанием 
ноль&]
[s7; [*C@3 v]-|устанавливаемое значение&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(const Id`&`,const Value`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) c
onst ][_^Id^ Id]`&_[*@3 id], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2; Изменяет значение по заданной локации 
в курсорном ряде. Эта перегруженная 
версия использует идентификатор 
[* Id] для адресации к соответствующему 
индексу.&]
[s7; [*C@3 id]-|идентификатор индекса&]
[s7; [*C@3 v]-|устанавливаемое значение&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetColumn`(int`,int`)const: [_^Value^ Value]_[* GetColumn]([@(0.0.255) in
t]_[*@3 row], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Возвращает значение указанной колонки. 
Оно зависит от маппинга `"колонка`-индекс`", 
установленного при добавлении колонок 
в таблицу. Когда колонка типа [/ rownum] 
(не привязана к каким`-либо исходным 
индексам), эта функция возвращает 
просто параметр [/ row]. Для колонок с 
единственным исходным индексом, функция 
возвращает значение маппированного 
исходного индекса. Для колонок с несколькими
 исходными индексами, функция возвращает 
[* ValueArray], содержащий значения его исходных 
индексов.&]
[s7; [*C@3 row]-|индекс ряда с основанием ноль&]
[s7; [*C@3 col]-|индекс колонки с основанием 
ноль&]
[s7; [*/ Возвратное значение]-|значение данной 
колонки&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetConvertedColumn`(int`,int`): [_^Value^ Value]_[* GetConvertedColumn](
[@(0.0.255) int]_[*@3 row], [@(0.0.255) int]_[*@3 col])&]
[s2; Возвращает значение указанной колонки 
после применения [* Convert]. В целях обеспечения 
производительности, значения, полученные 
вызовами методов [* Convert`::Format], кэшируются 
внутренне внутри объекта ArrayCtrl. Кэшем 
преобразования можно манипулировать 
посредством методов [*^topic`:`/`/CtrlLib`/src`/ArrayCtrl`_ru`-ru`#ArrayCtrl`:`:ClearCache`(`)^ C
learCache] и[*  ][*^topic`:`/`/CtrlLib`/src`/ArrayCtrl`_ru`-ru`#ArrayCtrl`:`:InvalidateCache`(int`)^ I
nvalidateCache].&]
[s7; [*C@3 row]-|индекс ряда с основанием ноль&]
[s7; [*C@3 col]-|индекс колонки с основанием 
ноль&]
[s7; [*/ Возвратное значение]-|преобразованное 
значение ячейки&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ReadRow`(int`)const: [_^Vector^ Vector]<[_^Value^ Value]>_[* ReadRow]([@(0.0.255) i
nt]_[*@3 i])_[@(0.0.255) const]&]
[s2; Возвращает [* Vector], содержащий значения 
всех исходных индексов в указанном 
ряде. Инвариантно, [* GetCount()] возвращенного 
массива равен [* GetIndexCount()] исходного 
ArrayCtrl.&]
[s7; [*C@3 i]-|индекс ряда с основанием ноль&]
[s7; [*/ Возвратное значение]-|массив из всех 
исходных значений в указанном ряде&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,const Vector`<Value`>`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[_^Vector^ Vector]<[_^Value^ Value]>`&_[*@3 v])&]
[s5;:Upp`:`:ArrayCtrl`:`:Set`(int`,Upp`:`:Vector`<Upp`:`:Value`>`&`&`):%- [@(0.0.255) v
oid]_[* Set]([@(0.0.255) int]_[*@3 i], [_^Upp`:`:Vector^ Vector]<[_^Upp`:`:Value^ Value]>`&
`&_[*@3 v])&]
[s2; Изменяет указанный ряд, устанавливая 
все значения исходных индексов в 
значения, переданные в параметре 
[/ v].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetArray`(int`,const ValueArray`&`): [@(0.0.255) void]_[* SetArray]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[_^ValueArray^ ValueArray][@(0.0.255) `&]_[*@3 va])&]
[s2; Устанавливает ряд [*@3 i] в [*@3 va].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(`): [@(0.0.255) void]_[* Add]()&]
[s2; Добавляет пустой ряд в матрицу исходных 
данных.&]
[s2; [* Примечание:] свойство [* InsertValue] структуры 
[* IdInfo] определяет метод для генерации 
/ получения дефолтных значений для 
вновь вставленных рядов. Однако, эти 
значения используются только в методе 
[* DoInsert] (основанном на ГИП) и не применяются 
к методу [* Add]. Если нужно установить 
вновь добавленный ряд исходной матрицы 
в какие`-то не`-null дефолты, нужно изменить 
вручную соответствующие ячейки.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(const Vector`<Value`>`&`): [@(0.0.255) void]_[* Add]([@(0.0.255) con
st]_[_^Vector^ Vector]<[_^Value^ Value]>`&_[*@3 v])&]
[s5;:Upp`:`:ArrayCtrl`:`:Add`(Upp`:`:Vector`<Upp`:`:Value`>`&`&`):%- [@(0.0.255) void]_
[* Add]([_^Upp`:`:Vector^ Vector]<[_^Upp`:`:Value^ Value]>`&`&_[*@3 v])&]
[s2; Добавляет новый ряд в конце матрицы 
исходных данных. Параметр [*^topic`:`/`/Core`/src`/Vector`_ru`-ru^ V
ector] содержит значения, используемые 
при инициализации нового ряда матрицы.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddArray`(const ValueArray`&`): [@(0.0.255) void]_[* AddArray]([@(0.0.255) c
onst]_[_^ValueArray^ ValueArray][@(0.0.255) `&]_[*@3 va])&]
[s2; Добавляет новый ряд в конец источника, 
со значением [*@3 va].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetArray`(int`)const: [_^ValueArray^ ValueArray]_[* GetArray]([@(0.0.255) i
nt]_[*@3 i])_[@(0.0.255) const]&]
[s2; Возвращает ряд как ValueArray.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,const VectorMap`<String`,Value`>`&`): [@(0.0.255) void]_[* Se
t]([@(0.0.255) int]_[*@3 i], [@(0.0.255) const]_[_^VectorMap^ VectorMap]<[_^String^ String],
 [_^Value^ Value]>`&_[*@3 m])&]
[s2; Устанавливает ряд на основе мапа. 
Ключи соответствуют идентификаторам 
рядов, ненайденные ключи игнорируются, 
найденным присваиваются соответствующие 
значения мапа.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(const VectorMap`<String`,Value`>`&`): [@(0.0.255) void]_[* Add]([@(0.0.255) c
onst]_[_^VectorMap^ VectorMap]<[_^String^ String], [_^Value^ Value]>`&_[*@3 m])&]
[s2; Добавляет ряд на основе мапа. Ключи 
соответствуют идентификаторам рядов, 
ненайденные ключи игнорируются, найденным 
присваиваются соответствующие значения 
мапа.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetMap`(int`,const ValueMap`&`): [@(0.0.255) void]_[* SetMap]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[_^ValueMap^ ValueMap][@(0.0.255) `&]_[*@3 m])&]
[s2; Устанавливает ряд на основе мапа. 
Ключи соответствуют идентификаторам 
рядов, ненайденные ключи игнорируются, 
найденным присваиваются соответствующие 
значения мапа.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddMap`(const ValueMap`&`): [@(0.0.255) void]_[* AddMap]([@(0.0.255) cons
t]_[_^ValueMap^ ValueMap][@(0.0.255) `&]_[*@3 m])&]
[s2; Добавляет ряд на основе мапа. Ключи 
соответствуют идентификаторам рядов, 
ненайденные ключи игнорируются, найденным 
присваиваются соответствующие значения 
мапа.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetMap`(int`)const: [_^ValueMap^ ValueMap]_[* GetMap]([@(0.0.255) int]_[*@3 i
])_[@(0.0.255) const]&]
[s2; Возвращает ряд как мап идентификаторов 
рядов к его значениям. Добавляются 
только непустые идентификаторы рядов.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(const Value`&`[`,const Value`&`]`.`.`.`): [@(0.0.255) void]_[* Add
]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_`[, [@(0.0.255) const]_[_^Value^ Value
][@(0.0.255) `&]_`]...)&]
[s2; Добавляет новый ряд внизу матрицы 
исходных данных. Фактически это серия 
функций (сгенерированная автоматически 
макросом [* Expand]), которая принимает 
произвольное число аргументов. Её 
аргументы используются при инициализации 
исходных индексов во вновь добавленном 
ряде.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(const Nuller`&`): [@(0.0.255) void]_[* Add]([@(0.0.255) const]_[_^Nuller^ N
uller][@(0.0.255) `&]_[*@3 null])&]
[s2; Вспомогательный метод, необходимый 
для корректной перегрузки Add(Null).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Insert`(int`): [@(0.0.255) void]_[* Insert]([@(0.0.255) int]_[*@3 i])&]
[s2; Вставляет новый ряд в исходный массив. 
Все индексы инициализируются в значения 
[* Null]. Свойство [* InsertValue] не применяется; 
если нужно установить вновь созданный 
ряд в нетривиальные значения, это 
нужно сделать вручную.&]
[s7; [*C@3 i]-|позиция вновь созданного ряда 
с основанием ноль&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Insert`(int`,const Vector`<Value`>`&`): [@(0.0.255) void]_[* Insert]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[_^Vector^ Vector]<[_^Value^ Value]>`&_[*@3 v])&]
[s2; Вставляет новый ряд в массив по указанной 
позиции. Второй параметр, [/ v], используется 
для инициализации исходных индексов 
вновь созданного ряда.&]
[s7; [*C@3 i]-|индекс ряда с основанием ноль&]
[s7; [*C@3 v]-|вектор значений, используемый 
для инициализации исходных индексов 
указанного ряда&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Remove`(int`): [@(0.0.255) void]_[* Remove]([@(0.0.255) int]_[*@3 i])&]
[s2; Удаляет указанный ряд исходных данных.&]
[s2; [* Примечание:] свойство [* AskRemove] объекта 
[* ArrayCtrl] говорит о том, будет ли появляться 
всплывающее диалоговое окно при каждом 
намерении пользователя удалить ряд. 
Однако, этот метод применим только 
к удалению ряда на базе ГИП; метод 
[* Remove] всегда удаляет требуемый ряд, 
не выводя никаких диалоговых окон 
подтверждения.&]
[s7; [*C@3 i]-|индекс удаляемого ряда с основанием 
ноль&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SwapUp`(`): [@(0.0.255) void]_[* SwapUp]()&]
[s2; Обменивает курсорный ряд на предыдущий 
ряд, эффективно поднимая его.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SwapDown`(`): [@(0.0.255) void]_[* SwapDown]()&]
[s2; Обменивает курсорный ряд со следующим 
рядом, эффективно опуская его.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:ReArrange`(const Upp`:`:Vector`<int`>`&`):%- [@(0.0.255) void]_
[* ReArrange]([@(0.0.255) const]_[_^Upp`:`:Vector^ Vector]<[@(0.0.255) int]>`&_[*@3 order])
&]
[s2; Реорганизует строки массива в порядке 
[%-*@3 order] индексов предыдущей строки. 
Счёт элементов в [%-*@3 order] должен быть 
таким же, что и GetCount у ArrayCtrl`'а, и должен 
содержать все индексы от нуля до GetCount() 
`- 1. [%-*@3 order] устанавливает новый порядок, 
выраженный в прежних индексах строк.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(Gate2`<int`,int`>`): [@(0.0.255) void]_[* Sort]([_^Gate2^ Gate2]<[@(0.0.255) i
nt], [@(0.0.255) int]>_[*@3 order])&]
[s5;:ArrayCtrl`:`:Sort`(int`,int`,Gate2`<int`,int`>`): [@(0.0.255) void]_[* Sort]([@(0.0.255) i
nt]_[*@3 from], [@(0.0.255) int]_[*@3 count], [_^Gate2^ Gate2]<[@(0.0.255) int], 
[@(0.0.255) int]>_[*@3 order])&]
[s2; Сортирует ряды массива, согласно 
заданному предикату упорядочивания. 
Объект [*@3 order] определяет предикат 
упорядочивания; два параметра `- это 
индексы строк ArrayCtrl`'а; должно возвращаться 
true, если они в требуемом порядке.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(const ArrayCtrl`:`:Order`&`): [@(0.0.255) void]_[* Sort]([@(0.0.255) c
onst]_[_^ArrayCtrl`:`:Order^ ArrayCtrl`::Order][@(0.0.255) `&]_[*@3 order])&]
[s2; Сортирует ряды массива, согласно 
заданному предикату упорядочивания. 
Объект [* ArrayCtrl`::Order] определяет предикат 
упорядочивания; его [* operator ()] должен 
вернуть [* true] всякий раз, когда его 
первый параметр (вектор, содержащий 
значения всех исходных индексов в 
ряде) меньше, чем его второй параметр.&]
[s7; &]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(int`,int`,const ArrayCtrl`:`:Order`&`): [@(0.0.255) void]_[* Sort
]([@(0.0.255) int]_[*@3 from], [@(0.0.255) int]_[*@3 count], [@(0.0.255) const]_[_^ArrayCtrl`:`:Order^ A
rrayCtrl`::Order][@(0.0.255) `&]_[*@3 order])&]
[s2; Сортирует порцию массива, используя 
заданный предикат упорядочивания.&]
[s7; [*C@3 from]-|индекс первого сортируемого 
ряда (с основанием ноль)&]
[s7; [*C@3 count]-|число сортируемых рядов&]
[s7; [*C@3 order]-|объект предиката упорядочивания. 
Должен быть производным от [* ArrayCtrl`::Order] 
и должен переписывать метод [* operator 
()]. Этот метод должен возвращать [* true 
]всякий раз, когда его первый параметр 
(вектор, содержащий все значения исходных 
индексов для определённого ряда) 
меньше, чем его второй параметр.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(int`(`*`)`(const Vector`<Value`>`&v1`,const Vector`<Value`>`&v2`)`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) const]_Vector<Value>`&_v1, 
[@(0.0.255) const]_Vector<Value>`&_v2))&]
[s2; Сортирует ряды массива, согласно 
порядку, определённому заданным предикатом 
упорядочивания [/ compare]. Предполагается, 
что это глобальная функция, возвращающая 
[* true] всякий раз, когда её первый параметр 
([/ v1], массив, состоящий из всех исходных 
индексов внутри ряда) меньше, чем 
второй параметр [/ v2] (согласно желаемому 
упорядочиванию).&]
[s7; [*C@3 compare]-|предикат упорядочивания; 
предполагается, что эта функция возвращает 
[* true] всякий раз, когда её первый параметр 
([/ v1]) меньше, чем второй ([/ v2]), согласно 
желаемому упорядочиванию.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) int]_[*@3 ii], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) const
]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueCompa
re)&]
[s2; Сортирует ряды массива, согласно 
заданному предикату упорядочивания 
для исходного индекса с заданным 
порядковым номером. Когда явно не 
указан, используется функция [* StdValueCompare] 
в качестве дефолтного предиката сравнения.&]
[s7; [*C@3 ii]-|порядковый номер (с основанием 
ноль) исходного индекса, используемого 
для сортировки&]
[s7; [*C@3 compare]-|функция предиката сортировки: 
предполагается возвращение ею [* true] 
всякий раз, когда её первый параметр 
([/ v1]) меньше, чем второй ([/ v2]), согласно 
желаемому упорядочиванию.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(const Id`&`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueC
ompare)&]
[s2; Сортирует ряды массива, согласно 
заданному предикату упорядочивания 
для исходного индекса с заданным 
идентификатором. Когда явно не указан, 
используется функция [* StdValueCompare] в 
качестве дефолтного предиката сравнения.&]
[s7; [*C@3 id]-|идентификатор исходного индекса, 
используемый для сортировки&]
[s7; [*C@3 compare]-|функция предиката сортировки: 
предполагается возвращение ею [* true] 
всякий раз, когда её первый параметр 
([/ v1]) меньше, чем второй ([/ v2]), согласно 
желаемому упорядочиванию.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(`): [@(0.0.255) void]_[* Sort]()&]
[s2; Сортирует массив, согласно с дефолтным 
предикатом упорядочивания для первого 
индекса источника. Эквивалентно вызову 
[* Sort(0)].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnSort`(int`,Gate2`<int`,int`>`): [@(0.0.255) void]_[* ColumnSort](
[@(0.0.255) int]_[*@3 column], [_^Gate2^ Gate2]<[@(0.0.255) int], [@(0.0.255) int]>_[*@3 orde
r])&]
[s2; Сортирует по колонке, используя упорядочива
ние, основанное на индексах строки. 
Почти то же самое, что простая Sort, 
за исключением того, что принимаются 
во внимание флаги ColumnSortSecondary и ColumnSortFindKey.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnSort`(int`,const ValueOrder`&`): [@(0.0.255) void]_[* ColumnSort](
[@(0.0.255) int]_[*@3 column], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_
[*@3 order])&]
[s2; Сотирует по колонке. Заметьте, что 
есть отличие от Sort, так как используется 
финальное преобразованное значение 
колонки (которое может быть даже сочетанием 
других индексов).&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:ColumnSort`(int`,int`(`*`)`(const Valua`&a`,const Upp`:`:Value`&b`)`):%- [@(0.0.255) v
oid]_[* ColumnSort]([@(0.0.255) int]_[*@3 column], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Valua[@(0.0.255) `&]_a, [@(0.0.255) const]_Value[@(0.0.255) `&]_b))&]
[s2; Сортирует по колонке. Заметьте, что 
есть отличие от Sort, так как используется 
финальное преобразованное значение 
колонки (которое может быть даже сочетанием 
других индексов).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetSortColumn`(int`,bool`): [@(0.0.255) void]_[* SetSortColumn]([@(0.0.255) i
nt]_[*@3 ii], [@(0.0.255) bool]_[*@3 descending]_`=_[@(0.0.255) false])&]
[s2; Устанавливает `"сортируемую`" колонку 
и вызывает DoColumnSort. Эта настройка используетс
я DoColumnSort.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ToggleSortColumn`(int`): [@(0.0.255) void]_[* ToggleSortColumn]([@(0.0.255) i
nt]_[*@3 ii])&]
[s2; Подобно SetSortColumn, но, если колонка 
уже установлена, флаг низхождения 
инвертируется; иначе флаг низхождения 
(descending) устанавливается в false (указывая 
на восходящую (ascending) сортировку ).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoColumnSort`(`): [@(0.0.255) void]_[* DoColumnSort]()&]
[s2; Сортирует массив по сортируемой 
колонке и указывает её, устанавливая 
в заголовочнике изображение.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetSortColumn`(`)const: [@(0.0.255) int]_[* GetSortColumn]()_[@(0.0.255) c
onst]&]
[s2; Возвращает колонку, которая сортирует 
ArrayCtrl (пользователь кликнул на ней 
и у неё отображена стрелка вверх или 
вниз).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsSortDescending`(`)const: [@(0.0.255) bool]_[* IsSortDescending]()_[@(0.0.255) c
onst]&]
[s2; Возвращает true, если текущая сортировка 
колонки низходящая.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ClearCache`(`): [@(0.0.255) void]_[* ClearCache]()&]
[s2; Повреждает весь [/ кэш преобразования]. 
Кэш преобразования сохраняет результаты 
метода [* Convert`::Format], применяемые к индивидуальн
ым ячейкам данных из соображений 
производительности. При всяком вызове 
метода [* ClearCache], все записи кэша помечаются 
как отработанные (obsolete) и вызывается 
метод [* Convert]`'а [* Format], как только потребуется 
преобразованное значение ячейки 
таблицы (обычно при следующем [* Paint]).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:InvalidateCache`(int`): [@(0.0.255) void]_[* InvalidateCache]([@(0.0.255) i
nt]_[*@3 i])&]
[s2; Повреждает указанный ряд в [/ кэше 
преобразования]. По соображениям 
производительности, результаты метода 
[* Convert`::Format], применяемые к индивидуальным 
ячейкам данных, хранятся в кэше. Эта 
функция метит указанный ряд кэша 
как отработанный (obsolete); это означает, 
что при последующем использовании 
этого конвертированного значения 
(обычно внутри процедуры [* Paint] или 
при установке контролов редактирования 
ряда), объекты [* Convert] вновь используются 
для генерирования актуальных выходных 
значений.&]
[s7; [*C@3 i]-|индекс ряда с основанием ноль&]
[s3; &]
[s0; &]
[s0; [*@(229)$(0.128.128)3 Управление курсором и 
выделением]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:ScrollUp`(`): [@(0.0.255) void]_[* ScrollUp]()&]
[s5;:ArrayCtrl`:`:ScrollDown`(`): [@(0.0.255) void]_[* ScrollDown]()&]
[s5;:ArrayCtrl`:`:ScrollPageUp`(`): [@(0.0.255) void]_[* ScrollPageUp]()&]
[s5;:ArrayCtrl`:`:ScrollPageDown`(`): [@(0.0.255) void]_[* ScrollPageDown]()&]
[s5;:ArrayCtrl`:`:ScrollEnd`(`): [@(0.0.255) void]_[* ScrollEnd]()&]
[s5;:ArrayCtrl`:`:ScrollBegin`(`): [@(0.0.255) void]_[* ScrollBegin]()&]
[s2; Проматывает содержимое ArrayCtrl`'а.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetSelectCount`(`)const: [@(0.0.255) int]_[* GetSelectCount]()_[@(0.0.255) c
onst]&]
[s2; Возвращает номер выделенного ряда 
в таблице.&]
[s7; [*/ Возвратное значение]-|число выделенных 
записей (в диапазоне [/ `[0 .. GetCount()`]])&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsSelection`(`)const: [@(0.0.255) bool]_[* IsSelection]()_[@(0.0.255) con
st]&]
[s2; Проверяет, есть ли выделенные ряды. 
Эквивалентно [* GetSelectCount() > 0].&]
[s7; [*/ Возвратное значение]-|[* true] `= есть 
хотя бы один выделенный ряд, [* false] `= 
нет ни одного.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Select`(int`,bool`): [@(0.0.255) void]_[* Select]([@(0.0.255) int]_[*@3 i],
 [@(0.0.255) bool]_[*@3 sel]_`=_[@(0.0.255) true])&]
[s2; Выделяет / снимает выделение с указанного 
ряда.&]
[s7; [*C@3 i]-|индекс ряда с основанием ноль&]
[s7; [*C@3 sel]-|[* true] `= добавляет ряд к текущему 
выделению, [* false] `= удалить ряд из выделения&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Select`(int`,int`,bool`): [@(0.0.255) void]_[* Select]([@(0.0.255) int]_[*@3 i
], [@(0.0.255) int]_[*@3 count], [@(0.0.255) bool]_[*@3 sel]_`=_[@(0.0.255) true])&]
[s2; Выделяет/ снимает выделение с указанного 
диапазона рядов.&]
[s7; [*C@3 i]-|индекс первого выделяемого/ отменяемого
 ряда (с основанием ноль)&]
[s7; [*C@3 count]-|число рялов для выделения / 
отмены выделения&]
[s7; [*C@3 sel]-|[* true] `= выделить ряды, [* false] `= отменить 
выделение рядов&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsSelected`(int`)const: [@(0.0.255) bool]_[* IsSelected]([@(0.0.255) int]_
[*@3 i])_[@(0.0.255) const]&]
[s7; Проверяет, выделен ли данный ряд.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsSel`(int`)const: [@(0.0.255) bool]_[* IsSel]([@(0.0.255) int]_[*@3 i])_[@(0.0.255) c
onst]&]
[s2; Если в виджете есть выделение, возвращает 
true, если [*@3 i] выделен, иначе возвращает 
true, если курсор находится по [*@3 i].&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetSelKeys`(`)const:%- [_^Upp`:`:Vector^ Vector]<[@(0.0.255) int
]>_[* GetSelKeys]()_[@(0.0.255) const]&]
[s2; Возвращает ключи (элементы с индексом 
0) всех выделенных строк (упорядоченных 
в строчном порядке).&]
[s3;%- &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:EnableLine`(int`,bool`): [@(0.0.255) void]_[* EnableLine]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) bool]_[*@3 e])&]
[s2; Активирует строку, выделяемую курсором. 
Строки активированы по дефолту.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:DisableLine`(int`): [@(0.0.255) void]_[* DisableLine]([@(0.0.255) i
nt]_[*@3 i])&]
[s2; То же, что и EnableLine(false).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:IsLineEnabled`(int`)const: [@(0.0.255) bool]_[* IsLineEnabled]([@(0.0.255) i
nt]_[*@3 i])_[@(0.0.255) const]&]
[s2; Возвращает true, если строка активирована. 
Заметьте, что, в дополнение к методу 
EnableLine, на этот статус также влияет 
обрвыз WhenLineEnabled.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:IsLineDisabled`(int`)const: [@(0.0.255) bool]_[* IsLineDisabled](
[@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2; То же, что и !IsLineEnabled([*@3 i]).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:ShowLine`(int`,bool`): [@(0.0.255) void]_[* ShowLine]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) bool]_[*@3 visible])&]
[s2; Устанавливает видимость строки. 
Скрытые строки отсутствуют в списке.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:HideLine`(int`): [@(0.0.255) void]_[* HideLine]([@(0.0.255) int]_[*@3 i
])&]
[s2; То же, что и ShowLine([*@3 i], false).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:IsLineVisible`(int`)const: [@(0.0.255) bool]_[* IsLineVisible]([@(0.0.255) i
nt]_[*@3 i])_[@(0.0.255) const]&]
[s2; Возвращает true, если строка видима. 
Заметьте, что, в дополнение к методу 
EnableLine, на видимость также влияет обрвыз 
WhenLineVisible.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ClearSelection`(`): [@(0.0.255) void]_[* ClearSelection]()&]
[s2; Очищает текущее выделение (снимает 
выделение со всех выделенных строк).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsCursor`(`)const: [@(0.0.255) bool]_[* IsCursor]()_[@(0.0.255) const]&]
[s2; Проверяет, находится ли курсор в 
пределах таблицы. Эквивалентно [* GetCursor()_>`=_0].&]
[s7; [*/ Возвратное значение]-|&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetCursor`(int`): [@(0.0.255) bool]_[* SetCursor]([@(0.0.255) int]_[*@3 i])
&]
[s2; Устанавливает текущий курсорный 
ряд. Когда ряд массива открыт для 
редактирования, функция вначале коммитит 
отредактированный ряд, а затем курсор 
перемещается на следующий. Когда 
отредактированный ряд не коммитится, 
функция возвращает [* false] и положение 
курсора не меняется.&]
[s7; [*C@3 i]-|индекс ряда с нулевым основанием&]
[s7; [*/ Возвратное значение]-|[* true] `= куроср 
перемещён, [* false ]когда нет (когда коммит 
предыдущего отредактированного ряда 
неудачен)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:KillCursor`(`): [@(0.0.255) bool]_[* KillCursor]()&]
[s2; Перемещает курсор прочь от массива. 
Когда ряд массива открыт для редактирования
, функция вначале коммитит отредактированны
й ряд, а затем перемещает курсор прочь 
от массива. Когда отредактированный 
ряд не удаётся закоммитить, функция 
возвращает [* false] и положение курсора 
не меняется.&]
[s7; [*/ Возвратное значение]-|[* true] `= курсор 
перемещён прочь от массива, [* false] когда 
нет (когда коммит предыдущего отредактирова
нного ряда неудачен)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:CancelCursor`(`): [@(0.0.255) void]_[* CancelCursor]()&]
[s2; Отменяет редактирование текущего 
редактируемого ряда. Все изменения, 
сделанные в редакторах индивидуальных 
колонок, отвергаются.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCursor`(`)const: [@(0.0.255) int]_[* GetCursor]()_[@(0.0.255) const]&]
[s2; Возвращает текущий курсорный ряд, 
`-1, если его нет.&]
[s7; [*/ Возвратное значение]-|индекс курсорного 
ряда с основанием ноль, `-1 `= курсор 
не в массиве&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GoBegin`(`): [@(0.0.255) void]_[* GoBegin]()&]
[s2; Перемещает курсор к первому ряду 
в массиве (эквивалентно [* SetCursor(0)]).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GoEnd`(`): [@(0.0.255) void]_[* GoEnd]()&]
[s2; Перемещает курсор к последнему ряду 
в массиве (эквивалентно [* SetCursor(GetCount() 
`- 1)]).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCursorSc`(`)const: [@(0.0.255) int]_[* GetCursorSc]()_[@(0.0.255) cons
t]&]
[s2; Возвращает визуальную вертикальную 
позицию курсорного ряда относительно 
текущей области видимости. Этот метод, 
в комбинации с [* ScCursor], можно использовать 
для репозиционирования курсорного 
ряда с поддержкой той же визуальной 
позиции ряда в области видимости.&]
[s7; [*/ Возвратное значение]-|целое число, 
описывающее вертикальную позицию 
курсорного ряда относительно области 
видимости массива&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ScCursor`(int`): [@(0.0.255) void]_[* ScCursor]([@(0.0.255) int]_[*@3 a])&]
[s2; Изменяет позицию полосы промотки 
так, чтобы текущий курсорный ряд оказался 
в заданной вертикальной позиции относительн
о области видимости массива. Выполнив 
следующую цепочку операций: [* GetCursorSc], 
затем репозиционируя курсорный ряд, 
затем [* ScCursor], можно достичь релокации 
курсора, сохраняя его визуальное 
положение в пределах области видимости 
массива.&]
[s7; [*C@3 a]-|целое, описывающее вертикальную 
позицию курсорного ряда (как правило, 
число, возвращенное при предыдущем 
вызове [* GetCursorSc])&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:CenterCursor`(`): [@(0.0.255) void]_[* CenterCursor]()&]
[s2; Изменяет позицию полосы промотки 
так, чтобы текущий курсорный ряд оказался 
по середине области видимости массива.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ScrollInto`(int`): [@(0.0.255) void]_[* ScrollInto]([@(0.0.255) int]_[*@3 l
ine])&]
[s2; Перемещает полосу промотки на наименьшее 
возможное количество, чтобы указанный 
ряд массива стал видимым. Когда указанный 
ряд массива уже виден, функция не 
делает ничего.&]
[s7; [*C@3 line]-|индекс ряда с основанием ноль, 
который нужно сделать видимым&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ScrollIntoCursor`(`): [@(0.0.255) void]_[* ScrollIntoCursor]()&]
[s2; Перемещает полосу промотки на наименьшее 
возможное количество, чтобы курсорный 
ряд стал видимым. Эквивалентно [* ScrollInto(GetCursor())
].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCursor`(`)const: [@(0.0.255) int]_[* GetCursor]()_[@(0.0.255) const]&]
[s2; Возвращает текущую вертикальную 
позицию полосы промотки.&]
[s7; [*/ Возвратное значение]-|Пиксельная 
позиция вертикальной полосы промотки. 
Позиция 0 находится в самом верху 
(верхний ряд массива полностью виден).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ScrollTo`(int`): [@(0.0.255) void]_[* ScrollTo]([@(0.0.255) int]_[*@3 sc])&]
[s2; Перемещает вертикальную полосу промотки 
массива в указанную позицию.&]
[s7; [*C@3 sc]-|Пиксельная позиция полосы промотки 
(scrollbar, скроллбар). Видимую порцию 
этого массива, в принципе, можно получить, 
взяв стэк рядов массива, верх которого 
расположен у вершины области видимости, 
и двигая пиксели его скроллбара вверх.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Find`(const Value`&`,int`,int`)const: [@(0.0.255) int]_[* Find]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v], [@(0.0.255) int]_[*@3 ii]_`=_[@3 0], 
[@(0.0.255) int]_[*@3 from]_`=_[@3 0])_[@(0.0.255) const]&]
[s2; [*C@3 v]-|значение для поиска в указанном 
индексе источника.&]
[s7; [*C@3 ii]-|порядковый номер искомого индекса 
источника (нач. с нуля)&]
[s7; [*C@3 from]-|индекс ряда, с которого начинать 
поиск (нач. с нуля)&]
[s7; [*/ Возвратное значение]-|номер совпадающего 
ряда, `-1 если отсутствует&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Find`(const Value`&`,const Id`&`,int`)const: [@(0.0.255) int]_[* Find](
[@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v], [@(0.0.255) const 
][_^Id^ Id]`&_[*@3 id], [@(0.0.255) int]_[*@3 from]_`=_[@3 0])_[@(0.0.255) const]&]
[s2; Находит ряд (используя линейный поиск, 
начиная с ряда [/ from]), в котором значение 
исходного индекса, идентифицируемого 
идентификатором [/ id,] равно [/ val]. Если 
такой ряд найден, функция возвратит 
его индекс. Если совпадений нет, возвращает 
`-1.&]
[s7; [*C@3 v]-|значение, которое нужно искать 
в указанном индексе источника&]
[s7; [*C@3 id]-|идентификатор индекса источника&]
[s7; [*C@3 from]-|индекс ряда, с которого начинается 
поиск&]
[s7; [*/ Возвратное значение]-|номер совпадающего 
ряда, `-1 если отсутствует&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:FindSetCursor`(const Value`&`,int`,int`): [@(0.0.255) bool]_[* FindSetC
ursor]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 val], 
[@(0.0.255) int]_[*@3 ii]_`=_[@3 0], [@(0.0.255) int]_[*@3 from]_`=_[@3 0])&]
[s2; Находит ряд (используя линейный поиск, 
начиная с ряда [/ from]), в котором значение 
исходного индекса, идентифицируемого 
его порядковым номером [/ ii], равно [/ val]. 
Если такой ряд найден, автоматически 
вызывается [* SetCursor], перемещая курсор 
на этот ряд.&]
[s7; [*C@3 val]-|значение, которое нужно искать 
в указанном индексе источника&]
[s7; [*C@3 ii]-|порядковый номер искомого индекса 
источника&]
[s7; [*C@3 from]-|индекс ряда, с которого начинать 
поиск&]
[s7; [*/ Возвратное значение]-|номер совпадающего 
ряда, `-1 если отсутствует&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:FindSetCursor`(const Value`&`,const Id`&`,int`): [@(0.0.255) bool]_[* F
indSetCursor]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 val], 
[@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], [@(0.0.255) int]_[*@3 from]_`=_[@3 0])&]
[s2; Находит ряд (используя линейный поиск, 
начиная с ряда [/ from]), в котором значение 
индекса источника, идентифицируемое 
идентификатором [/ id], равно [/ val]. Если 
такой ряд найден, автоматически вызывается 
[* SetCursor], перемещая курсор на этот ряд.&]
[s7; [*C@3 val]-|значение, которое нужно искать 
в указанном индексе источника&]
[s7; [*C@3 id]-|идентификатор индекса источника&]
[s7; [*C@3 from]-|индекс ряда, с которого начинается 
поиск&]
[s7; [*/ Возвратное значение]-|[* true] `= требуемый 
ряд найден (и курсор установлен), [* false] 
если нет&]
[s3; &]
[s0;* &]
[s0; [*@(229)$(0.128.128)3 Элементы пользовательского 
интерфейса]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:StdBar`(Bar`&`): [@(0.0.255) void]_[* StdBar]([_^Bar^ Bar][@(0.0.255) `&]_[*@3 m
enu])&]
[s2; Дефолтное локальное меню массива. 
Дефолтное локальное меню состоит 
из стандартных действий по редактированию 
(вставка / приставление / дублирование 
ряда, редактирование ряда, удаление 
ряда, перемещение ряда, выделить все 
ряды), отфильтрованных по свойствам 
массива, включая / выключая различные 
элементы ГИП (вставка / удаление элемента 
и проч.). &]
[s7; [*C@3 menu]-|объект [* Bar], представляющий собой 
генерируемое меню&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsModified`(int`)const: [@(0.0.255) bool]_[* IsModified]([@(0.0.255) int]_
[*@3 ii])_[@(0.0.255) const]&]
[s2; Проверяет индекс источника в текущем 
редактируемом ряде на изменения.&]
[s7; [*C@3 ii]-|индекс ряда&]
[s7; [*/ Возвратное значение]-|[* true] `= индекс 
был модифицирован, [* false] `= индекс в 
его исходном состоянии&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsModified`(const Id`&`)const: [@(0.0.255) bool]_[* IsModified]([@(0.0.255) c
onst ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Проверяет индекс источника в текущем 
редактируемом ряде на изменения.&]
[s7; [*C@3 id]-|source index identifier&]
[s7; [*/ Возвратное значение]-|[* true] `= индекс 
источника модифицирован, [* false ]если 
нет&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:StartEdit`(int`): [@(0.0.255) bool]_[* StartEdit]([@(0.0.255) int]_[*@3 d]_
`=_[@3 0])&]
[s2; Открывает текущий курсорный ряд 
для редактирования и устанавливает 
фокус на [/ d]`-ную колонку.&]
[s7; [*C@3 d]-|индекс колонки&]
[s7; [*/ Возвратное значение]-|[* true] `= редактирование 
успешно инициализировано, [* false] если 
нет (когда массив в режиме [* ReadOnly] или 
у него нет редактируемых колонок)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetEditColumn`(`)const: [@(0.0.255) int]_[* GetEditColumn]()_[@(0.0.255) c
onst]&]
[s2; Возвращает текущую редактируемую 
колонку.&]
[s7; [*/ Возвратное значение]-|индекс редактируемой
 колонки, `-1 `= отсутствует&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoEdit`(`): [@(0.0.255) void]_[* DoEdit]()&]
[s2; Открывает текущий курсорный ряд 
для редактирования.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoInsert`(int`): [@(0.0.255) void]_[* DoInsert]([@(0.0.255) int]_[*@3 curso
r])&]
[s2; Начинает ГИП`-вставку нового ряда 
по заданной позиции.&]
[s7; [*C@3 cursor]-|позиция нового ряда&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoInsertBefore`(`): [@(0.0.255) void]_[* DoInsertBefore]()&]
[s2; Начинает ГИП`-вставку нового ряда 
над текущим рядом.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoInsertAfter`(`): [@(0.0.255) void]_[* DoInsertAfter]()&]
[s2; Начинает ГИП`-вставку нового ряда 
под текущим рядом.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoAppend`(`): [@(0.0.255) void]_[* DoAppend]()&]
[s2; Начинает ГИП`-вставку нового ряда 
в конце массива.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoRemove`(`): [@(0.0.255) virtual] [@(0.0.255) bool]_[* DoRemove]()&]
[s2; Выполняет ГИП`-удаление текущего 
курсорного ряда. Если установлено 
свойство [* kRemove] в [* true], и пользователь 
отменяет диалог подтверждения, функция 
возвращает [* false] и текущий ряд не удаляется.&]
[s7; [*/ Возвратное значение]-|[* true] `= ряд успешно 
удалён, [* false] `=  пользователь отменил 
удаление ряда&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoDuplicate`(`): [@(0.0.255) void]_[* DoDuplicate]()&]
[s2; Дублирует текущий ряд и открывает 
его для редактирования.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoSelectAll`(`): [@(0.0.255) void]_[* DoSelectAll]()&]
[s2; Отмечает все ряды массива выделенными.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AcceptEnter`(`): [@(0.0.255) bool]_[* AcceptEnter]()&]
[s2; Выполняет все необходимые ГИП`-действия, 
эквивалентные нажатию пользователем 
клавиши [* Enter]. Текущий редактируемый 
ряд `"коммитится`", а в случае, если 
этот ряд был вновь добавленным, а 
свойство [* NoInsertAppend] не установлено, 
то в массив добавляется дополнительный 
ряд и он открывается для редактирования.&]
[s7; [*/ Возвратное значение]-|[* true] `= текущий 
ряд успешно `"закоммичен`", [* false] если 
нет&]
[s3; &]
[s0; &]
[s0; &]
[s0; [*@(229)$(0.128.128)3 Экспорт (вывод) контента]&]
[s0;* &]
[s3; &]
[s5;:ArrayCtrl`:`:AsText`(String`(`*`)`(const Value`&`)`,bool`,const char`*`,const char`*`,const char`*`,const char`*`)const: [_^String^ S
tring]_[* AsText]([_^String^ String]_(`*[*@3 format])([@(0.0.255) const]_Value[@(0.0.255) `&
]), [@(0.0.255) bool]_[*@3 sel]_`=_[@(0.0.255) false], [@(0.0.255) const]_[@(0.0.255) char]_
`*[*@3 tab]_`=_`"`\t`", [@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 row]_`=_`"`\r`\n`", 
[@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 hdrtab]_`=_`"`\t`", [@(0.0.255) const]_[@(0.0.255) c
har]_`*[*@3 hdrrow]_`=_`"`\r`\n`")_[@(0.0.255) const]&]
[s2; Генерная функция для преобразования 
контента ArrayCtrl`'а в текст. Экспортируется 
видимый на экране контент (то есть, 
колонки, определённые с помощью AddColumn, 
а не индексы). Ячейки преобразовываются 
в формат вывода функцией [*@3 format]. Если 
[*@3 sel] равно true, то экспортируются только 
ряды с IsSel true. [*@3 tab] представляет собой 
текст`-разделитель между ячейками 
ряда [*@3 row] `- разделитель рядов. [*@3 hdrtab] 
`- разделитель заголовочных ячеек 
(текстов в звголовочнике ArrayCtrl`'а) 
`- если NULL, то заголовочник не экспортируется
. [*@3 hdrrow].`= разделитель заголовочного 
и рядов с данными.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetClipboard`(bool`,bool`)const: [@(0.0.255) void]_[* SetClipboard]([@(0.0.255) b
ool]_[*@3 sel]_`=_[@(0.0.255) false], [@(0.0.255) bool]_[*@3 hdr]_`=_[@(0.0.255) true])_[@(0.0.255) c
onst]&]
[s2; Помещает контент ArrayCtrl`'а в буфер 
обмена в текстовом формате, `"`\t`" и 
`"`\r`\n`" `- в качестве разделителей. Если 
[*@3 sel] равно true, то экспортируются только 
ряды с IsSel true, [*@3 hdr] контролирует экспорт 
заголовочника.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AsQtf`(bool`,bool`): [_^String^ String]_[* AsQtf]([@(0.0.255) bool]_[*@3 se
l]_`=_[@(0.0.255) false], [@(0.0.255) bool]_[*@3 hdr]_`=_[@(0.0.255) true])&]
[s2; Возвращает контент ArrayCtrl`'а в формате 
QTF. Если [*@3 sel] равно true, то экспортируются 
только ряды с IsSel true, [*@3 hdr] контролирует 
экспорт заголовочника.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AsCsv`(bool`,int`,bool`): [_^String^ String]_[* AsCsv]([@(0.0.255) bool]_
[*@3 sel]_`=_[@(0.0.255) false], [@(0.0.255) int]_[*@3 sep]_`=_`';`', 
[@(0.0.255) bool]_[*@3 hdr]_`=_[@(0.0.255) true])&]
[s2; Возвращает контент ArrayCtrl`'а в формате 
csv, используя разделитель [*@3 sep]. Если 
[*@3 sel] равно true, то экспортируются только 
ряды с IsSel true, [*@3 hdr] контролирует экспорт 
заголовочника.&]
[s0; &]
[s0; &]
[s0; [*@(229)$(0.128.128)3 Обратные уведомительные 
вызовы]&]
[s3; &]
[s3; &]
[s5;:ArrayCtrl`:`:WhenSel: [_^Callback^ Callback]_[* WhenSel]&]
[s2; Вызывается при всяком изменении 
курсора или выделения. Вероятно, это 
самый используемый обратный вызов 
ArrayCtrl`'а. Рекомендуем начинать с него, 
используя другие только при надобности.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenLeftClick: [_^Callback^ Callback]_[* WhenLeftClick]&]
[s2; Этот обратный вызов вызывается при 
всяком нажатии пользователем ячейки 
массива.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenLeftDouble: [_^Callback^ Callback]_[* WhenLeftDouble]&]
[s2; Этот обрвыз вызывается при всяком 
двойном клике пользователя на ячейке 
массива.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenMouseMove: [_^Callback1^ Callback1]<[_^Point^ Point]>_[* WhenMouseMov
e]&]
[s2; Вызывается при движении мыши над 
ArrayCtrl`'ом или выходе из ArrayCtrl`'а. Point`::y 
`- номер строки, Point`::x `- индекс колонки. 
Если мышь вышла за ArrayCtrl, параметр 
равен Null.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenEnterKey: [_^Callback^ Callback]_[* WhenEnterKey]&]
[s2; Вызывается, когда пользователь нажал 
клавишу Enter, в то время как фокус был 
в ArrayCtrl`'е, на какой`-то строке ArrayCtrl`'а 
был курсоор и клавиша Enter не была `'съедена`' 
другим действием, типа приёма ввода. 
Когда этот Callback не пустой, нажатие 
Enter никогда не передаётся родительскому 
контролу.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenBar: [_^Callback1^ Callback1]<Bar[@(0.0.255) `&]>_[* WhenBar]&]
[s2; Этот обрвыз вызывается при каждой 
регенерации локального меню массива. 
Установив этот обрвыз на другую функцию 
/ метод, можно снабдить массив кастомным 
локальным меню. Аргумент [* Bar`&] `- это 
ссылка на генерируемое меню.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenEnterRow: [_^Callback^ Callback]_[* WhenEnterRow]&]
[s0; [* -|][*/ Депрекирован]&]
[s2; This callback is called every time the cursor location changes 
to a different row of the array.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenAcceptRow: [_^Gate^ Gate]_[* WhenAcceptRow]&]
[s2; This gate is called every time an array row (open for editing) 
needs to be validated. When the gate returns [* false], the validation 
process is assumed to have failed, when it returns [* true], it 
is assumed to have succeeded. You can use this callback to add 
your own validation algorithms relevant to the array context 
within your application.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenUpdateRow: [_^Callback^ Callback]_[* WhenUpdateRow]&]
[s2; This callback is called whenever an array row has been updated. 
You can use this callback e.g. to project the changes to a database 
or generally to an external data source.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenKillCursor: [_^Callback^ Callback]_[* WhenKillCursor]&]
[s0; [* -|][*/ Депрекирован]&]
[s2; This callback is called whenever the cursor is moved away from 
the table.&]
[s2; [* Note:] internally, when moving the cursor (e.g. by calling the 
[* SetCursor ]method), after committing the previous row the cursor 
is removed from the table using [* KillCursor] and placed to the 
new location afterwards. Therefore every time the cursor is moved, 
the [* WhenKillCursor] callback is called as a by`-product.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenCursor: [_^Callback^ Callback]_[* WhenCursor]&]
[s0; [* -|][*/ Депрекирован]&]
[s2; This callback is called every time the cursor row number changes 
(either when the cursor is removed from the table, or when it 
has been moved to a different row).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenArrayAction: [_^Callback^ Callback]_[* WhenArrayAction]&]
[s2; This callback is called every time the source array data changes 
(typically after accepting changes to a certain row or after 
deleting a row).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenStartEdit: [_^Callback^ Callback]_[* WhenStartEdit]&]
[s2; This callback is called whenever the array row editing process 
is initiated. It can be used e.g. to set up some additional properties 
of the column editor objects, to fill in drop`-down lists pertaining 
to certain column editors etc.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenAcceptEdit: [_^Callback^ Callback]_[* WhenAcceptEdit]&]
[s2; This callback is called whenever the currently edited line has 
been committed.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenSelection: [_^Callback^ Callback]_[* WhenSelection]&]
[s0; [* -|][*/ Депрекирован]&]
[s2; This callback is called whenever the current array selection 
changes. This includes changes to the cursor location as the 
cursor is automatically considered part of the selection.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenCtrlsAction: [_^Callback^ Callback]_[* WhenCtrlsAction]&]
[s2; This callback is called whenever some of the editor controls 
constructed automatically via the column editing [/ factory] calls 
its [* WhenAction] method. It can be used to watch out for changes 
in the cell editors and react to specific situations accordingly.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenScroll: [_^Callback^ Callback]_[* WhenScroll]&]
[s2; Called when scrolling of ArrayCtrl content happened.&]
[s3; &]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenHeaderLayout: [_^Callback^ Callback]_[* WhenHeaderLayout]&]
[s2; Called when header changes.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:WhenColumnSorted:%- [_^Upp`:`:Event^ Event]<>_[* WhenColumnSorte
d]&]
[s2; Invoked at the end of DoColumnSort. This allows to react to 
user sorting ArrayCtrl by clicking on column header marked as 
Sorting.&]
[s3;%- &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenLineEnabled: [_^Callback2^ Callback2]<[@(0.0.255) int], 
[@(0.0.255) bool`&]>_[* WhenLineEnabled]&]
[s2; Provides additional means to enable/disable lines in addition 
to `"EnableLine`" interface. This is especially useful when using 
SetVirtualCount. First parameter is the line number, second is 
reference to enable status.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:WhenLineVisible: [_^Upp`:`:Callback2^ Callback2]<[@(0.0.255) int
], [@(0.0.255) bool`&]>_[* WhenLineVisible]&]
[s2; Provides additional means to show/hide lines in addition to 
`"ShowLine`" interface. This is especially useful when using 
SetVirtualCount. First parameter is the line number, second is 
reference to visibility status.&]
[s3; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 ArrayCtrl`::IdInfo]]}}&]
[s3; &]
[s1;:ArrayCtrl`:`:IdInfo`:`:struct: [@(0.0.255)3 struct][3 _][*3 IdInfo]&]
[s9; Структура [* IdInfo] содержит свойства 
всех индексов исходного массива. 
Её можно применять для настройки 
дополнительных свойств, относящихся 
к данным исходного массива.&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0; [* Список Публичных Членов]]}}&]
[s3; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:InsertValue`(const Value`&`): [_^ArrayCtrl`:`:IdInfo^ IdInf
o][@(0.0.255) `&]_[* InsertValue]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])
&]
[s2; The method sets up the default source index value for newly 
created rows. This is used only when the row insertion is GUI`-based 
(like using the [* DoInsert] method for instance). When a row is 
added to the array programmatically (e.g. using [* Add] or [* Insert]), 
these default values are not used.&]
[s7; [*C@3 v]-|default source index value&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:InsertValue`(ValueGen`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&
]_[* InsertValue]([_^ValueGen^ ValueGen][@(0.0.255) `&]_[*@3 g])&]
[s2; The method sets up a factory for generating default index values 
for newly created rows. This is used only when the row insertion 
is GUI`-based (like using the [* DoInsert] method for instance). 
When a row is added to the array programmatically (e.g. using 
[* Add] or [* Insert]), the [* InserValue] property is not consulted.&]
[s7; [*C@3 g]-|a reference to the value generation factory. The ownership 
to the factory is not passed by this call; the caller must insure 
the existence of the factory object throughout the array duration.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:Accel`(int`(`*`)`(int`)`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&
]_[* Accel]([@(0.0.255) int]_(`*[*@3 filter])([@(0.0.255) int]))&]
[s2; This method sets up the source index accelerator function. The 
accelerator is used to quickly locate rows using the keyboard 
key presses.&]
[s7; [*C@3 filter]-|a [* CharFilter ]function for keypress filtering&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:Accel`(`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* Ac
cel]()&]
[s2; This method sets up keyboard acceleration for the given source 
index. The `'trivial`' [/ CharConvert] is used for character translation.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:GetInsertValue`(`): [_^Value^ Value]_[* GetInsertValue]()&]
[s2; Uses the [* InsertValue] property to generate a new source index 
value (either using a fixed default value or the value creation 
factory).&]
[s7; [*/ Возвратное значение]-|the generated value 
to be used as the default for the newly inserted row.&]
[s3; &]
[s0; &]
[s0; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 ArrayCtrl`::Column]]}}&]
[s3; &]
[s1;:ArrayCtrl`:`:Column`:`:class: [@(0.0.255)3 class][3 _][*3 Column][3 _:_][@(0.0.255)3 privat
e][3 _][*@3;3 FormatConvert]&]
[s2; &]
[s0; [/ Производный от] FormatConvert&]
[s0;3 &]
[s0; Структура [* ArrayCtrl`::Column] описывает колонку 
массива вывода. Её методы используются 
для установки или запроса её свойств, 
некоторые из которых устанавливаются 
также методами ArrayCtrl.&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0; [* Список Публичных Членов]]}}&]
[s3; &]
[s5;:ArrayCtrl`:`:Column`:`:Add`(int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* A
dd]([@(0.0.255) int]_[*@3 `_pos])&]
[s2; Adds another source data index to the list of source indices 
used as the data for the given output column.&]
[s7; [*C@3 `_pos]-|zero`-based ordinal number of the source index&]
[s7; [*/ Возвратное значение]-|[* `*this].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Add`(const Id`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* Add](const [_^Id^ Id]`&_[*@3 id])&]
[s2; Adds another source data index to the list of source indices 
used as the data for the given output column.&]
[s7; [*C@3 id]-|the [* Id] identifier of the source index&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:AddIndex`(const Id`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* AddIndex]([@(0.0.255) const]_[_^Id^ Id][@(0.0.255) `&]_[*@3 id])&]
[s2; Adds another source index to the array and adds it to the list 
of source indices bound to this output column. The newly created 
index is assigned the given identifier.&]
[s7; [*C@3 id]-|the identifier for the newly created index&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:AddIndex`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_
[* AddIndex]()&]
[s2; Adds another source index to the array and adds it to the list 
of source indices bound to this output column.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:SetConvert`(const Convert`&`): [_^ArrayCtrl`:`:Column^ Colu
mn][@(0.0.255) `&]_[* SetConvert]([@(0.0.255) const]_[_^Convert^ Convert][@(0.0.255) `&]_[*@3 c
])&]
[s2; Устанавливает объект [* Convert] для указанной 
колонки. This object is used to convert the source values 
(obtained from the source data matrix) to the values displayable 
and/or editable by the respective column display / editor object.&]
[s2; [* Note:] the ownership of the [* Convert] object is not transferred 
by this function. The array merely stores a pointer to the Convert 
object. It is up to the host application to keep the Convert 
object alive as long as necessary (until the ArrayCtrl object 
is destroyed or all references to the Convert object obliterated 
by new calls to the [* SetConvert] method). In any case, most Convert`-based 
object do not support copying at all; moreover, as the Convert`-based 
objects are mostly derived from the basic class, their copying 
is normally prone to slicing.&]
[s7; [*C@3 c]-|a constant reference to the Convert object to use for 
the given column&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:ConvertBy`(Upp`:`:Function`<Upp`:`:Value`(const Upp`:`:Value`&`)`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* ConvertBy]([_^Upp`:`:Function^ Function]<Value([@(0.0.255) c
onst]_Value[@(0.0.255) `&])>_[*@3 cv])&]
[s2; Similar to SetConvert, but using [%-*@3 cv] instead of class for 
conversion.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:SetFormat`(const char`*`): [@(0.0.255) virtual] 
[_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* SetFormat]([@(0.0.255) const]_[@(0.0.255) c
har]_`*[*@3 fmt])&]
[s2; Устанавливает строку формата, используемую
 для дефолтного форматирования значения. 
When no Convert object is set for the column, the source value 
is normally passed to the [* NFormat] function where the [/ fmt] 
argument defines the desired formatting pattern.&]
[s7; [*C@3 fmt]-|a [* NFormat]`-compatible formatting pattern&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:SetDisplay`(const Display`&`): [_^ArrayCtrl`:`:Column^ Colu
mn][@(0.0.255) `&]_[* SetDisplay]([@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_[*@3 d
])&]
[s2; Устанавливает дефолтный Display, используемый 
для этой колонки. The column Display can be overridden 
for certain array cells by calls to the [*^topic`:`/`/CtrlLib`/src`/ArrayCtrl`_ru`-ru`#ArrayCtrl`:`:SetDisplay`(int`,int`,const Display`&`)^ A
rrayCtrl`::SetDisplay] method.&]
[s2; [* Note:] the ownership to the Display object is not transferred 
by this function. The array merely stores a pointer to the Display; 
it is up to the host application to keep the Display object alive 
as long as necessary.&]
[s7; [*C@3 d]-|a reference to the Display object&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Edit`(Ctrl`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* Edit]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 e])&]
[s2; Устанавливает up the Ctrl`-based object to use 
for inline array column editing.&]
[s7; [*C@3 e]-|a reference to the editor control object&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Ctrls`(void`(`*`)`(One`<Ctrl`>`&`)`): [_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* Ctrls]([@(0.0.255) void]_(`*[*@3 factory])(One<Ctrl>`&))&]
[s2; The methods sets up a factory which the ArrayCtrl uses as necessary 
to create new Ctrl`'s for editing a given column. The argument 
of this function is a function pointer, which, upon execution, 
should allocate (normally using the One`::Create method) the desired 
editor object and set it to its argument. If the position of 
Ctrl is equivalent to `'SetRect(0, 0, 0, 0)`', which is the default 
value, Ctrl is resized to fit the ArrayCtrl cell accurately, 
spanning the whole width and using STDSIZE for height, otherwise 
the position represents the position within the cell.&]
[s7; [*C@3 factory]-|a global function used for editor control creation&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Ctrls`(`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* Ctrls]()&]
[s2; This member template sets up a default factory for creating 
editor controls of a given type. Every time the ArrayCtrl needs 
to create a new editor control, an object of the type [* T] is 
created automatically (using the [* new] operator). If the position 
of Ctrl is equivalent to `'SetRect(0, 0, 0, 0)`', which is the 
default value, Ctrl is resized to fit the ArrayCtrl cell accurately, 
spanning the whole width and using STDSIZE for height, otherwise 
the position represents the position within the cell.&]
[s7; [*C@4 T]-|the desired object editor type &]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:WithLined`(Upp`:`:Event`<int`,Upp`:`:One`<Upp`:`:Ctrl`>`&`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* WithLined]([_^Upp`:`:Event^ Event]<[@(0.0.255) int], 
[_^Upp`:`:One^ One]<[_^Upp`:`:Ctrl^ Ctrl]>`&>_[*@3 factory])&]
[s2; This method sets up a factory which the ArrayCtrl uses to create 
new Ctrl`'s for editing a given column. The argument, a global 
function, is supposed to create a new editor control in the second 
argument (usually using the One`::Create method). The first argument 
of Event is the line index. If the position of Ctrl is equivalent 
to `'SetRect(0, 0, 0, 0)`', which is the default value, Ctrl 
is resized to fit the ArrayCtrl cell accurately, spanning the 
whole width and using STDSIZE for height, otherwise the position 
represents the position within the cell.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:With`(Upp`:`:Event`<Upp`:`:One`<Upp`:`:Ctrl`>`&`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* With]([_^Upp`:`:Event^ Event]<[_^Upp`:`:One^ One]<[_^Upp`:`:Ctrl^ C
trl]>`&>_[*@3 factory])&]
[s2; This method sets up a factory which the ArrayCtrl uses to create 
new Ctrl`'s for editing a given column. The argument, a global 
function, is supposed to create a new editor control in the argument 
(usually using the One`::Create method). If the position of Ctrl 
is equivalent to `'SetRect(0, 0, 0, 0)`', which is the default 
value, Ctrl is resized to fit the ArrayCtrl cell accurately, 
spanning the whole width and using STDSIZE for height, otherwise 
the position represents the position within the cell.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:InsertValue`(const Value`&`): [_^ArrayCtrl`:`:Column^ Colum
n][@(0.0.255) `&]_[* InsertValue]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])
&]
[s2; Instructs the ArrayCtrl object to initialize this column in 
newly created rows to the given value [/ v]. (This applies only 
to GUI`-based row insertion using methods like [* DoInsert] etc., 
the low`-level, programmer`-controlled row insertion methods 
like [* Add] or [* Insert] always initialize the source data matrix 
with [* Null]`'s).&]
[s7; [*C@3 v]-|the value to use as the default for newly inserted rows&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:InsertValue`(ValueGen`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* InsertValue]([_^ValueGen^ ValueGen][@(0.0.255) `&]_[*@3 g])&]
[s2; Programs the ArrayCtrl object to use the given [* ValueGen] factory 
for default value generation for newly created rows. This can 
be used e.g. to generate unique UUID`'s or primary keys using 
an Oracle SEQUENCE object for a primary key column.&]
[s7; [*C@3 g]-|a reference to the ValueGen object used for default value 
generation&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:NoClickEdit`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* NoClickEdit]()&]
[s2; Disables entering the editing mode when clicking the respective 
column.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Cache`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* Ca
che]()&]
[s2; Enables using the cache to store the converted values of this 
column. By default, converted value caching is turned off to 
make cell value conversion entirely dynamic; however, very often 
it is advisable to enable using the cache, especially when the 
conversion is relatively slow (for instance, when the conversion 
queries a database connection to convert the value).&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Accel`(int`(`*`)`(int`)`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* Accel]([@(0.0.255) int]_(`*[*@3 filter])([@(0.0.255) int]))&]
[s2; Устанавливаетup the accelerator for the given column. 
A given filtering function is used to convert keystrokes before 
acceleration.&]
[s7; [*C@3 filter]-|a [* CharConvert]`-style function to use for keystroke 
conversion&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Accel`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* Ac
cel]()&]
[s2; Устанавливает акселератор для данной 
колонки. Преобразований нажатий клавиш 
не выполняется.&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Margin`(int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_
[* Margin]([@(0.0.255) int]_[*@3 m])&]
[s2; Устанавливает ширину кромки для 
данной колонки. Равноценно вызову 
метода [*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`_ru`-ru^ SetMargin] 
`"подлежащего`" [* HeaderTab].&]
[s7; [*C@3 m]-|&]
[s7; [*/ Возвратное значение]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Sorting`(const ValueOrder`&`): [_^ArrayCtrl`:`:Column^ Colu
mn][@(0.0.255) `&]_[* Sorting]([@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_
[*@3 o])&]
[s5;:ArrayCtrl`:`:Column`:`:Sorting`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* S
orting]()&]
[s2; Activates sorting of ArrayCtrl column by clicking on its header 
tab. Parameterless version uses default Value ordering using 
StdValueCompare.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:SortingLined`(Upp`:`:Gate`<int`,int`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* SortingLined]([_^Upp`:`:Gate^ Gate]<[@(0.0.255) int],
 [@(0.0.255) int]>_[*@3 aorder])&]
[s2; Activates sorting of ArrayCtrl column by clicking on its header 
tab. This variant uses a Gate2 predicate that is supposed to 
compare two lines (it has indicies as parameters). Note that 
this variant ignores ascending/descending order, it has to be 
implemented in predicate, using ArrayCtrl`::IsSortDescending to 
determine the order.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:SortingBy`(Upp`:`:Function`<int`(const Upp`:`:Value`&a`,const Upp`:`:Value`&b`)`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* SortingBy]([_^Upp`:`:Function^ Function]<[@(0.0.255) i
nt]_([@(0.0.255) const]_Value[@(0.0.255) `&]_a, [@(0.0.255) const]_Value[@(0.0.255) `&]_b
)>_[*@3 c])&]
[s2; Activates sorting of ArrayCtrl column by clicking on its header 
tab, using [%-*@3 c] to compare values of column. [%-*@3 c] should 
return `-1, 0, 1 for <, `=, >.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:SortDefault`(bool`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* SortDefault]([@(0.0.255) bool]_[*@3 desc] 
`= [@(0.0.255) false])&]
[s2;%- [%RU-RU Устанавливает this column to be initial 
sorting column (calls SetSortColumn of ArrayCtrl). If none of 
Sorting/SortingBy/SortingLines methods was called on this column 
yet, calls default Sorting for the column too. If ][*@3 desc] is 
true, sorting is in descending order.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:HeaderTab`(`): [_^HeaderCtrl`:`:Column^ HeaderCtrl`::Column][@(0.0.255) `&
]_[* HeaderTab]()&]
[s5;:ArrayCtrl`:`:Column`:`:HeaderTab`(`)const: [@(0.0.255) const]_[_^HeaderCtrl`:`:Column^ H
eaderCtrl`::Column][@(0.0.255) `&]_[* HeaderTab]()_[@(0.0.255) const]&]
[s2; Возвращает the [* HeaderCtrl`::Column] object describing 
the given column. This object can be used to set up additional 
column properties (like column width constraints or the [*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`_ru`-ru^ W
henAction] callback).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Tip`(const char`*`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* Tip]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 tip])&]
[s2; Assigns a [*@3 tip] to header tab column.&]
[s3; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 Структура ArrayCtrl`::Order]]}}&]
[s3; &]
[s1;:ArrayCtrl`:`:Order`:`:struct: [@(0.0.255)3 struct][3 _][*3 Order]&]
[s9; Объект [* Order] используется для сортировки 
рядов массива. The overloaded [* operator ()] acts 
as the sorting predicate, which is consulted within the sorting 
method to determine which of a given pair of row is `'less`' 
according to the desired sorting.&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0; [* Список Публичных Членов]]}}&]
[s3; &]
[s5;:ArrayCtrl`:`:Order`:`:operator`(`)`(const Vector`<Value`>`&`,const Vector`<Value`>`&`)const: [@(0.0.255) v
irtual] [@(0.0.255) bool]_[* operator()]([@(0.0.255) const]_[_^Vector^ Vector]<[_^Value^ Va
lue]>`&_[*@3 row1], [@(0.0.255) const]_[_^Vector^ Vector]<[_^Value^ Value]>`&_[*@3 row2])_[@(0.0.255) c
onst]_`=_[@3 0]&]
[s2; The sorting predicate. This method should return [* true] when 
its first argument ([/ row1]) is less than the second argument 
([/ row2]) according to the desired ordering.&]
[s7; [*C@3 row1]-|an array of source data index values for the first 
of the rows to compare&]
[s7; [*C@3 row2]-|an array of source data index values for the other 
row to compare&]
[s7; [*/ Возвратное значение]-|[* true] `= row1 < row2, 
[* false] `= row1 >`= row2&]
[s3; &]
[s0; ]]