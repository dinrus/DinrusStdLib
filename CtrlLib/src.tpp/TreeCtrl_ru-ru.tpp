topic "Класс TreeCtrl (ДеревоКтрл)";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,0#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_} 
[ {{10000@3 [s0; [*@(229)4 Класс TreeCtrl (ДеревоКтрл)]]}}&]
[s3;%RU-RU &]
[s1;:TreeCtrl`:`:class: [@(0.0.255)3 class][3 _][*3 TreeCtrl][3 _:_][@(0.0.255)3 public][3 _][*@3;3 C
trl]&]
[s2;%RU-RU &]
[s2;%RU-RU 
@@image:1212&1156
(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)
&]
[s0;%RU-RU &]
[s9;%RU-RU Управление иерархией TreeCtrl`'а основано 
на целочисленных номерах`-идентификаторах. 
Каждый узел в дереве (item, элемент) 
имеет ассоциированный с ним целочисленный 
идентификатор, уникальный для данного 
дерева. Узлы`-отпрыски элемента организованы
 как массив. TreeCtrl предоставляет операцию 
по вставке узлов`-отпрысков в заданной 
позиции массива и для опроса узлов 
отпрысков и родителей. У корневого 
элемента фиксированный идентификатор 
0.&]
[s3;%RU-RU &]
[s0;%RU-RU &]
[ {{10000F(128)G(128)@1 [s0;%RU-RU [* Список Публичных Членов]]}}&]
[s3; &]
[s5;:TreeCtrl`:`:WhenOpen: [_^Callback1^ Callback1][@(0.0.255) <int>]_[* WhenOpen]&]
[s2;%RU-RU Элемент дерева был открыт, параметр 
`- его идентификатор.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenClose: [_^Callback1^ Callback1][@(0.0.255) <int>]_[* WhenClose]&]
[s2;%RU-RU Элемент дерева был закрыт, параметр 
`- его идентификатор.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenLeftClick: [_^Callback^ Callback]_[* WhenLeftClick]&]
[s2;%RU-RU Элемент дерева был кликнут. Курсор 
идентифицирует нажатый элемент. Можно 
получить позицию клика внутри элемента 
с помощью метода GetItemClickPos.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenLeftDouble: [_^Callback^ Callback]_[* WhenLeftDouble]&]
[s2;%RU-RU Элемент дерева был кликнут дважды. 
Курсор идентифицирует нажатый элемент. 
Можно получить позицию клика внутри 
элемента с помощью метода GetItemClickPos.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenBar: [_^Callback1^ Callback1][@(0.0.255) <]Bar[@(0.0.255) `&>]_[* WhenBa
r]&]
[s2;%RU-RU Используется для обеспечения 
контекстным меню.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:WhenSel: [_^Callback^ Callback]_[* WhenSel]&]
[s2;%RU-RU Курсор или выделение изменены 
(включая KillCursor).&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenDrag: [_^Callback^ Callback]_[* WhenDrag]&]
[s2;%RU-RU Триггируется при попытке пользователя 
перетягивать элемент.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenDropItem: [_^Callback2^ Callback2][@(0.0.255) <int], 
[_^PasteClip^ PasteClip][@(0.0.255) `&>]_[* WhenDropItem]&]
[s2;%RU-RU Этот обрвыз следит за тягом`&бросом 
в элементы TreeCtrl`'а. Первый параметр 
`- идентификатор элемента. Смотрите 
[^PasteClip^ PasteClip] для получения дополнительной 
информации.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenDropInsert: [_^Callback3^ Callback3][@(0.0.255) <int], 
[@(0.0.255) int], [_^PasteClip^ PasteClip][@(0.0.255) `&>]_[* WhenDropInsert]&]
[s2;%RU-RU Этот обрвыз следит за тягом`&бросом 
в позициях вставки между элементами 
TreeCtrl`'а. Первый параметр `- идентификатор 
родительского элемента, второй `- 
индекс вставки в списке отпрысков 
родителя. Смотрите [^PasteClip^ PasteClip] для 
получения дополнительной информации.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenDrop: [_^Callback1^ Callback1][@(0.0.255) <]PasteClip[@(0.0.255) `&>]_
[* WhenDrop]&]
[s2;%RU-RU Этот обрвыз управляет тягом`&бросом, 
когда WhenDropItem и WhenDropInsert неприменимы 
`- брос в пустую область. Смотрите 
[^PasteClip^ PasteClip] для получения дополнительной 
информации.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:WhenStartEdit: [_^Upp`:`:Event^ Event]<[@(0.0.255) int]>_[* WhenSta
rtEdit]&]
[s2;%RU-RU Вызывается перед тем, как в TreeCtrl 
запускается редактирование узла 
(`"ноды`"). Первый параметр `- курсор 
редактируемого элемента.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:WhenEdited: [_^Upp`:`:Event^ Event]<[@(0.0.255) int][%RU-RU ,][@(0.0.255)  
const]_Value[@(0.0.255) `&]>_[* WhenEdited]&]
[s2;%RU-RU Когда определено, TreeCtrl начнёт 
редактирование значения узла при 
клике на уже выделенном (но не сразу), 
таким же образом, как, например, происходит 
переименование файла в. FileSel. Когда 
значение принято, WhenEdit вызывается 
с новым значением. Значение в TreeCtrl`'е 
не меняе,тся, если так нужно, `- за это 
отвечает код, присвоенный этому WhenEdited. 
Дефолтный редактор EditString. Его можно 
изменить методом`- модификатором 
Editor. Первый параметр `- курсор редактируемого
 элемента.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenCursor: [_^Callback^ Callback]_[* WhenCursor]&]
[s2;%RU-RU Курсор изменился (включая KillCursor). 
Депрекирован.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenSelection: [_^Callback^ Callback]_[* WhenSelection]&]
[s2;%RU-RU Выделение изменилось. Депрекирован.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetRoot`(const TreeCtrl`:`:Node`&`): [@(0.0.255) void]_[* SetRoot]([@(0.0.255) c
onst]_[_^TreeCtrl`:`:Node^ TreeCtrl`::Node][@(0.0.255) `&]_[*@3 n])&]
[s2;%RU-RU Устанавливает контент корневого 
элемента в [%-*@3 n]. Выполняется полная 
глубокая копия [%-*@3 n].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetRoot`(const Image`&`,Value`): [@(0.0.255) void]_[* SetRoot]([@(0.0.255) c
onst]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 v])&]
[s2;%RU-RU Устанавливает рисунок, ключ и 
значение корневого элемента. [%-*@3 v] 
используется и для ключа, и для значения.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetRoot`(const Image`&`,Value`,Value`): [@(0.0.255) void]_[* SetRoot]([@(0.0.255) c
onst]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 key], 
[_^Value^ Value]_[*@3 text])&]
[s2;%RU-RU Устанавливает рисунок, ключ и 
значение корневого элемента.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:SetRoot`(const Image`&`,Ctrl`&`,int`,int`): [@(0.0.255) void]_[* SetRoot
]([@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Ctrl^ Ctrl][@(0.0.255) `&]_
[*@3 ctrl], [@(0.0.255) int]_[*@3 cx]_`=_[@3 0], [@(0.0.255) int]_[*@3 cy]_`=_[@3 0])&]
[s2;%RU-RU Устанавливает виджет в корневом 
элементе. Сохраняется только ссылка 
на [%-*@3 ctrl] `-> время жизни объекта виджета 
должно превышать срок существования 
TreeCtrl`'а. Размерами виджета должны 
быть [%-*@3 cx], [%-*@3 cy]. Если либо [%-*@3 cx], или 
[%-*@3 cy] равен нулю, используется размер 
GetMinSize.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const TreeCtrl`:`:Node`&`): [@(0.0.255) int]_[* Insert
]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], [@(0.0.255) const]_[_^TreeCtrl`:`:Node^ T
reeCtrl`::Node][@(0.0.255) `&]_[*@3 n])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`): [@(0.0.255) int]_[* Insert]([@(0.0.255) int]_[*@3 parent
id], [@(0.0.255) int]_[*@3 i])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Value`,bool`): [@(0.0.255) int]_[* Inse
rt]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], [@(0.0.255) const]_[_^Image^ I
mage][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 value], [@(0.0.255) bool]_[*@3 withopen
]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Value`,Value`,bool`): [@(0.0.255) int
]_[* Insert]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], 
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 key], 
[_^Value^ Value]_[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Ctrl`&`,int`,int`,bool`): [@(0.0.255) i
nt]_[* Insert]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], 
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 c
], [@(0.0.255) int]_[*@3 cx]_`=_[@3 0], [@(0.0.255) int]_[*@3 cy]_`=_[@3 0], 
[@(0.0.255) bool]_[*@3 wo]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Value`,const String`&`,bool`): [@(0.0.255) i
nt]_[* Insert]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], 
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 key], 
[@(0.0.255) const]_[_^String^ String][@(0.0.255) `&]_[*@3 value], [@(0.0.255) bool]_[*@3 with
open]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Value`,const char`*`,bool`): [@(0.0.255) i
nt]_[* Insert]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], 
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 key], 
[@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) f
alse])&]
[s2; Вставляет элемент`-отпрыск родителю, 
заданному по идентификатору. Отдельные 
варианты устанавливают различные 
атрибуты в TreeCtrl`::Node вставляемого элемента. 
Возвращает идентификатор нового 
элемента. Заметка: две последние перегрузки 
`- для устранения перегрузочной неоднозначно
сти.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:Add`(int`,const TreeCtrl`:`:Node`&`): [@(0.0.255) int]_[* Add]([@(0.0.255) i
nt]_[*@3 parentid], [@(0.0.255) const]_[_^TreeCtrl`:`:Node^ TreeCtrl`::Node][@(0.0.255) `&
]_[*@3 n])&]
[s5;:TreeCtrl`:`:Add`(int`): [@(0.0.255) int]_[* Add]([@(0.0.255) int]_[*@3 parentid])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Value`,bool`): [@(0.0.255) int]_[* Add]([@(0.0.255) i
nt]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], 
[_^Value^ Value]_[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Value`,Value`,bool`): [@(0.0.255) int]_[* Add](
[@(0.0.255) int]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img],
 [_^Value^ Value]_[*@3 key], [_^Value^ Value]_[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=
_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Ctrl`&`,int`,int`,bool`): [@(0.0.255) int]_[* A
dd]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 i
mg], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl], [@(0.0.255) int]_[*@3 cx]_`=_[@3 0], 
[@(0.0.255) int]_[*@3 cy]_`=_[@3 0], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Value`,const String`&`,bool`): [@(0.0.255) in
t]_[* Add]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&
]_[*@3 img], [_^Value^ Value]_[*@3 key], [@(0.0.255) const]_[_^String^ String][@(0.0.255) `&]_
[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Value`,const char`*`,bool`): [@(0.0.255) int]_
[* Add]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 i
mg], [_^Value^ Value]_[*@3 key], [@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 value], 
[@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s2; -|Вставляет элемент`-отпрыск в конец 
списка элементов`-отпрысков родителя. 
Родитель указывается по идентификатору. 
Отдельные варианты устанавливают 
различные атрибуты в TreeCtrl`::Node вставляемого 
элемента. Возвращает идентификатор 
нового элемента. Заметка: две последние 
перегрузки `- для устранения перегрузочной 
неоднозначности.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Remove`(int`): [@(0.0.255) void]_[* Remove]([@(0.0.255) int]_[*@3 id])&]
[s2;%RU-RU Удаляет элемент с идентификатором 
[%-*@3 id] из этого дерева.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:RemoveChildren`(int`): [@(0.0.255) void]_[* RemoveChildren]([@(0.0.255) in
t]_[*@3 id])&]
[s2;%RU-RU Удаляет все элементы`-отпрыски 
из родительского элемента с идентификатором
 [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Swap`(int`,int`): [@(0.0.255) void]_[* Swap]([@(0.0.255) int]_[*@3 id1], 
[@(0.0.255) int]_[*@3 id2])&]
[s2;%RU-RU Меняет местами два элемента дерева.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:SwapChildren`(int`,int`,int`): [@(0.0.255) void]_[* SwapChildren]([@(0.0.255) i
nt]_[*@3 parentid], [@(0.0.255) int]_[*@3 i1], [@(0.0.255) int]_[*@3 i2])&]
[s2;%RU-RU Меняет местами отрыски родителя 
[%-*@3 parentid] с индексами [%-*@3 i1] и [%-*@3 i2].&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:GetChildCount`(int`)const: [@(0.0.255) int]_[* GetChildCount]([@(0.0.255) i
nt]_[*@3 id])_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает число элеметов`-отпрысков 
родительского элемента с идентификатором 
[%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetChild`(int`,int`)const: [@(0.0.255) int]_[* GetChild]([@(0.0.255) int]_
[*@3 id], [@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает идентификатор отпрыска 
по индексу [%-*@3 i] родительского элемента 
с идентификатором [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetChildIndex`(int`,int`)const: [@(0.0.255) int]_[* GetChildIndex]([@(0.0.255) i
nt]_[*@3 parentid], [@(0.0.255) int]_[*@3 childid])_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает индекс элемента`-отпрыска 
[%-*@3 parentid] с идентификатором [%-*@3 childid].&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:GetParent`(int`)const: [@(0.0.255) int]_[* GetParent]([@(0.0.255) int]_[*@3 i
d])_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает родительский идентификатор 
отпрыска с идентификатором [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Get`(int`)const: [_^Value^ Value]_[* Get]([@(0.0.255) int]_[*@3 id])_[@(0.0.255) c
onst]&]
[s3;^Value^ &]
[s4;^Value^ &]
[s5;:TreeCtrl`:`:GetValue`(int`)const: [_^Value^ Value]_[* GetValue]([@(0.0.255) int]_[*@3 id
])_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает значение элемента 
с идентификатором [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:operator`[`]`(int`)const: [_^Value^ Value]_[* operator`[`]]([@(0.0.255) in
t]_[*@3 id])_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает ключ элемента с идентификато
ром [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Set`(int`,Value`): [@(0.0.255) void]_[* Set]([@(0.0.255) int]_[*@3 id], 
[_^Value^ Value]_[*@3 v])&]
[s2;%RU-RU Устанавливает значение и ключ 
элемента с идентификатором [%-*@3 id].&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:Set`(int`,Value`,Value`): [@(0.0.255) void]_[* Set]([@(0.0.255) int]_[*@3 id
], [_^Value^ Value]_[*@3 key], [_^Value^ Value]_[*@3 value])&]
[s2;%RU-RU Устанавливает значение и ключ 
элемента с идентификатором [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetValue`(const Value`&`): [@(0.0.255) void]_[* SetValue]([@(0.0.255) cons
t]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2;%RU-RU Устанавливает значение элемента 
с курсором, ключ не меняется.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:SetDisplay`(int`,const Display`&`): [@(0.0.255) void]_[* SetDisplay]([@(0.0.255) i
nt]_[*@3 id], [@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_[*@3 display])&]
[s2;%RU-RU Устанавливает дисплей элемента 
[%-*@3 id].&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:RefreshItem`(int`): [@(0.0.255) void]_[* RefreshItem]([@(0.0.255) int]_[*@3 i
d])&]
[s2;%RU-RU Принудительно перерисовывает 
элемент (напр., когда его внешний вид 
меняется способом, который не распознаётся 
виджетом TreeCtrl).&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:GetLineCount`(`): [@(0.0.255) int]_[* GetLineCount]()&]
[s2;%RU-RU Получает текущее число строк 
`- видимых элементов `- в TreeCtrl`'е.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetItemAtLine`(int`): [@(0.0.255) int]_[* GetItemAtLine]([@(0.0.255) int]_
[*@3 i])&]
[s2;%RU-RU Получает идентификатор элемента 
на строке i.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetLineAtItem`(int`): [@(0.0.255) int]_[* GetLineAtItem]([@(0.0.255) int]_
[*@3 id])&]
[s2;%RU-RU Получает строку элемента с идентификато
ром [%-*@3 id]. Если элемент не виден, возвращает 
отрицательное значение.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetNode`(int`)const: [_^TreeCtrl`:`:Node^ Node]_[* GetNode]([@(0.0.255) in
t]_[*@3 id])_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает атрибуты элемента 
с идентификатором [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetNode`(int`,const TreeCtrl`:`:Node`&`): [@(0.0.255) void]_[* SetNode](
[@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^TreeCtrl`:`:Node^ TreeCtrl`::Node][@(0.0.255) `&
]_[*@3 n])&]
[s2;%RU-RU Устанавливает атрибуты.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:IsValid`(int`)const: [@(0.0.255) bool]_[* IsValid]([@(0.0.255) int]_
[*@3 id])_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает true, если [%-*@3 id] представляет 
полноценный идентификатор узла.&]
[s3;%RU-RU &]
[s4;%RU-RU &]
[s5;:TreeCtrl`:`:IsOpen`(int`)const: [@(0.0.255) bool]_[* IsOpen]([@(0.0.255) int]_[*@3 id])_
[@(0.0.255) const]&]
[s2;%RU-RU Проверяет, открыт ли элемент.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Open`(int`,bool`): [@(0.0.255) void]_[* Open]([@(0.0.255) int]_[*@3 id], 
[@(0.0.255) bool]_[*@3 open]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Открывает или закрывает (если 
[%-*@3 open] равно false) элемент с идентификатором 
id `- делает все элементы`-отпрыски 
видимыми.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Close`(int`): [@(0.0.255) void]_[* Close]([@(0.0.255) int]_[*@3 id])&]
[s2;%RU-RU То же, что и Open(id, false).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:GetOpenIds`(`)const: [_^Upp`:`:Vector^ Vector]<[@(0.0.255) int]>_
[* GetOpenIds]()_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает все открытые идентификаторы 
узла.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:OpenIds`(const Upp`:`:Vector`<int`>`&`): [@(0.0.255) void]_[* Ope
nIds]([@(0.0.255) const]_[_^Upp`:`:Vector^ Vector]<[@(0.0.255) int]>`&_[*@3 ids])&]
[s2;%RU-RU Открывает все полноценные идентификатор
ы [%-*@3 ids].&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:OpenDeep`(int`,bool`): [@(0.0.255) void]_[* OpenDeep]([@(0.0.255) int]_[*@3 i
d], [@(0.0.255) bool]_[*@3 open]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Открывает/закрывает элемент с 
идентификатором [%-*@3 id] и все его элементы`-отп
рыски.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:CloseDeep`(int`): [@(0.0.255) void]_[* CloseDeep]([@(0.0.255) int]_[*@3 id])
&]
[s2;%RU-RU То же, что и OpenDeep([%-*@3 id], false).&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:MakeVisible`(int`): [@(0.0.255) void]_[* MakeVisible]([@(0.0.255) int]_[*@3 i
d])&]
[s2;%RU-RU Открывает все родительские элементы 
элемента с идентификатором [%-*@3 id], 
делая его видимым.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetCursorLine`(int`): [@(0.0.255) void]_[* SetCursorLine]([@(0.0.255) int]_
[*@3 i])&]
[s2;%RU-RU Устанавливает курсор в дереве 
на строку видимого элемента [%-*@3 i].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetCursorLine`(`)const: [@(0.0.255) int]_[* GetCursorLine]()_[@(0.0.255) c
onst]&]
[s2;%RU-RU Возвращает строку видимого элемента.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:KillCursor`(`): [@(0.0.255) void]_[* KillCursor]()&]
[s2;%RU-RU Удаляет курсор из дерева.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetCursor`(int`): [@(0.0.255) void]_[* SetCursor]([@(0.0.255) int]_[*@3 id])
&]
[s2;%RU-RU Устанавливает курсор на элемент 
с идентификатором [%-*@3 id]. Если элемент 
невидим, то предварительно вызывается 
MakeVisible(id).&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetCursor`(`)const: [@(0.0.255) int]_[* GetCursor]()_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает идентификатор элемента, 
у которого на данный момент есть курсор, 
или отрицательное значение, если 
такового нет.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:IsCursor`(`)const: [@(0.0.255) bool]_[* IsCursor]()_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает true, если в дереве есть 
курсор.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetItemClickPos`(`)const: [_^Point^ Point]_[* GetItemClickPos]()_[@(0.0.255) c
onst]&]
[s2;%RU-RU Возвращает текущую позицию мыши 
в прямоугольнике показа элемента, 
когда он кликнут.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetScroll`(`)const: [_^Point^ Point]_[* GetScroll]()_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает позицию промотки дерева.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:ScrollTo`(Point`): [@(0.0.255) void]_[* ScrollTo]([_^Point^ Point]_[*@3 sc])
&]
[s2;%RU-RU Проматывает дерево обратно, на 
значение, ранее возвращённое GetScroll.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Get`(`)const: [_^Value^ Value]_[* Get]()_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает ключ элемента с курсором 
или Null, если он отсутствует.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetValue`(`)const: [_^Value^ Value]_[* GetValue]()_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает значение элемента 
с курсором илиr Null, если оно отсутствует.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Find`(Value`): [@(0.0.255) int]_[* Find]([_^Value^ Value]_[*@3 key])&]
[s2;%RU-RU Возвращает идентификатор элемента 
с ключом [%-*@3 key] или отрицательное значение, 
если он не найден.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:FindSetCursor`(Value`): [@(0.0.255) bool]_[* FindSetCursor]([_^Value^ Valu
e]_[*@3 key])&]
[s2;%RU-RU Помещает курсор на первый элемент 
с ключом [%-*@3 key], возвращает true, если 
он найден.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Sort`(int`,const ValueOrder`&`,bool`): [@(0.0.255) void]_[* Sort]([@(0.0.255) i
nt]_[*@3 id], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_[*@3 order], 
[@(0.0.255) bool]_[*@3 byvalue]_`=_[@(0.0.255) false])&]
[s2;%RU-RU Сортирует элементы`-отпрыски 
элемента с идентификатором [%-*@3 id], 
используя предикат сортировки [%-*@3 order]. 
Если [%-*@3 byvalue] равно false, элементы сортируются 
по ключам, если true, то по значениям.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SortDeep`(int`,const ValueOrder`&`,bool`): [@(0.0.255) void]_[* SortDeep
]([@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_[*@3 o
rder], [@(0.0.255) bool]_[*@3 byvalue]_`=_[@(0.0.255) false])&]
[s2;%RU-RU Сортирует элементы`-отпрыски 
элемента с идентификатором [%-*@3 id], 
используя предикат сортировки [%-*@3 order]. 
Если [%-*@3 byvalue] равно false, элементы сортируются 
по ключам, если true, то по значениям. 
После сортировки, рекурсивно вызывается 
SortDeep для всех элементов`-отпрысков.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Sort`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`,bool`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) const
]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueCompa
re, [@(0.0.255) bool]_[*@3 byvalue]_`=_[@(0.0.255) false])&]
[s2;%RU-RU Сортирует с упрощённым предикатом 
[%-*@3 compare].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SortDeep`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`,bool`): [@(0.0.255) v
oid]_[* SortDeep]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueC
ompare, [@(0.0.255) bool]_[*@3 byvalue]_`=_[@(0.0.255) false])&]
[s2;%RU-RU SortDeep с упрощённым предикатом 
[%-*@3 compare].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SortByValue`(int`,const ValueOrder`&`): [@(0.0.255) void]_[* SortByValue
]([@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_[*@3 o
rder])&]
[s5;:TreeCtrl`:`:SortDeepByValue`(int`,const ValueOrder`&`): [@(0.0.255) void]_[* SortDee
pByValue]([@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&
]_[*@3 order])&]
[s5;:TreeCtrl`:`:SortByValue`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* SortByValue]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueC
ompare)&]
[s5;:TreeCtrl`:`:SortDeepByValue`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* SortDeepByValue]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueC
ompare)&]
[s2;%RU-RU Варианты для удобства, вызывающие 
свои базовые контрчасти с byvalue, равным 
true.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Sort`(int`,const ValuePairOrder`&`): [@(0.0.255) void]_[* Sort]([@(0.0.255) i
nt]_[*@3 id], [@(0.0.255) const]_[_^ValuePairOrder^ ValuePairOrder][@(0.0.255) `&]_[*@3 ord
er])&]
[s5;:TreeCtrl`:`:Sort`(int`,int`(`*`)`(const Value`&k1`,const Value`&v1`,const Value`&k2`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) const
]_Value[@(0.0.255) `&]_k1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v1, 
[@(0.0.255) const]_Value[@(0.0.255) `&]_k2, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2))&]
[s2;%RU-RU Сортирует список отпрысков родителя 
[%-*@3 id]. Заметьте, что если [%-*@3 id] равен 
0, сотрируется всё дерево. `"Внуки`" 
остаются незатронутыми.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:SortDeep`(int`,const ValuePairOrder`&`): [@(0.0.255) void]_[* SortDeep](
[@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^ValuePairOrder^ ValuePairOrder][@(0.0.255) `&
]_[*@3 order])&]
[s5;:TreeCtrl`:`:SortDeep`(int`,int`(`*`)`(const Value`&k1`,const Value`&v1`,const Value`&k2`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* SortDeep]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_k1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v1, 
[@(0.0.255) const]_Value[@(0.0.255) `&]_k2, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2))&]
[s2;%RU-RU Сортирует поддерево родителя 
[%-*@3 id]. Заметьте, что если [%-*@3 id] равен 
0, сортируется всё дерево. `"Внуки`" 
также сортируются.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:Clear`(`): [@(0.0.255) void]_[* Clear]()&]
[s2;%RU-RU Удаляет из дерева все элементы.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:ClearSelection`(`): [@(0.0.255) void]_[* ClearSelection]()&]
[s2;%RU-RU Удаляет любое выделение.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SelectOne`(int`,bool`): [@(0.0.255) void]_[* SelectOne]([@(0.0.255) int]_[*@3 i
d], [@(0.0.255) bool]_[*@3 sel])&]
[s2;%RU-RU Выделяет/снимает выделение с 
единичного элемента с идентификатором 
id.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:IsSelected`(int`)const: [@(0.0.255) bool]_[* IsSelected]([@(0.0.255) int]_
[*@3 id])_[@(0.0.255) const]&]
[s2;%RU-RU Возвращает true, если элемент с 
идентификатором [%-*@3 id] выделен.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:IsSel`(int`)const: [@(0.0.255) bool]_[* IsSel]([@(0.0.255) int]_[*@3 id])_[@(0.0.255) c
onst]&]
[s2;%RU-RU Возвращает true, если элемент с 
идентификатором [%-*@3 id] выделен [*/ или 
имеет курсор][/ .]&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetSelectCount`(`)const: [@(0.0.255) int]_[* GetSelectCount]()_[@(0.0.255) c
onst]&]
[s2;%RU-RU Число выделенных элементов.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:IsSelDeep`(int`)const: [@(0.0.255) bool]_[* IsSelDeep]([@(0.0.255) int]_[*@3 i
d])_[@(0.0.255) const]&]
[s2;%RU-RU True, если IsSel равен true для элемента 
или если IsSelDeep равен true для его родителя 
(если выделен любой элемент в цепочке 
родства).&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:GetSel`(`)const: [_^Vector^ Vector][@(0.0.255) <int>]_[* GetSel]()_[@(0.0.255) c
onst]&]
[s2;%RU-RU Возвращает идентификаторы всех 
элементов с IsSel, равным true (заметьте, 
что в это входит и элемент с курсором, 
если отсутствует выделение).&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Remove`(const Vector`<int`>`&`): [@(0.0.255) void]_[* Remove]([@(0.0.255) c
onst]_[_^Vector^ Vector][@(0.0.255) <int>`&]_[*@3 id])&]
[s2;%RU-RU Удаляет набор элементов, [%-*@3 id 
]`- список идентификаторов удаляемых 
элементов.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:RemoveSelection`(`): [@(0.0.255) void]_[* RemoveSelection]()&]
[s2;%RU-RU То же, что и Remove(GetSel()) `- удаляет 
все выделенные элементы.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:OkEdit`(`): [@(0.0.255) void]_[* OkEdit]()&]
[s2;%RU-RU Если местный редактор активен 
(смотрите WhenEdited, WhenStartEdit и Editor), принимает 
новое значение и заканчивает режим.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:EndEdit`(`): [@(0.0.255) void]_[* EndEdit]()&]
[s2;%RU-RU Если местный редактор активен 
(смотрите WhenEdited, WhenStartEdit и Editor), завершает 
режим без принятия значения.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Dump`(`): [@(0.0.255) void]_[* Dump]()&]
[s2;%RU-RU Диагностический дамп контента 
дерева в стандартный лог. Существует 
только в отладочном режиме.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:NoCursor`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* NoCursor]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Курсов в дереве не допускается.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:NoRoot`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* NoRoot]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Корневой элемент не отображается.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:LevelCx`(int`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* LevelCx]([@(0.0.255) i
nt]_[*@3 cx])&]
[s2;%RU-RU Отступ на один иерархический 
уровень. Дефолтное значение равно 
16 пикселей.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:MultiSelect`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* MultiSelect](
[@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Разрешает выделение элементов.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:NoBackground`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* NoBackgroun
d]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Белый фон дерева не отрисовывается.&]
[s0;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:PopUpEx`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* PopUpEx]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%RU-RU В случае, если размер отображения 
значения узла больше текущей доступной 
площади, пытается отобразить полное 
значение, когда курсор находится 
над узлом.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:NoPopUpEx`(`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* NoPopUpEx]()&]
[s2;%RU-RU То же, что и PopUpEx(false).&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:MouseMoveCursor`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* MouseMov
eCursor]([@(0.0.255) bool]_[*@3 m]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Курсор мыши перемещает курсор 
дерева без клика, просто перемещая 
мышь над деревом.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:Accel`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* Accel]([@(0.0.255) b
ool]_[*@3 a]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Активирует простой клавиатурный 
акселератор. Значения узла преобразуются 
в текст посредством StdFormat, и затем 
для поиска соответствующего элемента 
используется первая буква.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:SetDisplay`(const Display`&`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* Se
tDisplay]([@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_[*@3 d])&]
[s2;%RU-RU Устанавливает универсальный 
дисплей, используемый для всех значений 
узла. Может переписываться для отдельного 
узла, присваивая ему специфичный 
Display.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:HighlightCtrl`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* HighlightC
trl]([@(0.0.255) bool]_[*@3 a]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Отрисовывает фоновую область 
внедрённого виджета тем же цветом, 
который используется для обычных 
значений, `- отдаёт должное выделению, 
позиции курсора и проч.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:RenderMultiRoot`(bool`): [_^Upp`:`:TreeCtrl^ TreeCtrl][@(0.0.255) `&
]_[* RenderMultiRoot]([@(0.0.255) bool]_[*@3 a]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Когда активен, не отрисовываются 
линии, соединяющие узлы нулевого 
уровня (это выглядить, как`-будто имеется 
несколько корней).&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:EmptyNodeIcon`(const Upp`:`:Image`&`): [_^Upp`:`:TreeCtrl^ Tree
Ctrl][@(0.0.255) `&]_[* EmptyNodeIcon]([@(0.0.255) const]_[_^Upp`:`:Image^ Image][@(0.0.255) `&
]_[*@3 a])&]
[s2;%RU-RU Когда RenderMultiRoot активен и есть 
узел нулевого уровня без элементов, 
[%-*@3 a] отрисовывается слева, указывая 
на то, что он пуст.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:Editor`(Upp`:`:Ctrl`&`): [_^Upp`:`:TreeCtrl^ TreeCtrl][@(0.0.255) `&
]_[* Editor]([_^Upp`:`:Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 e])&]
[s2;%RU-RU Присваивает альтернативный редактор 
для функционала WhenEdited.&]
[s3;%RU-RU &]
[s4; &]
[s5;:TreeCtrl`:`:SetScrollBarStyle`(const ScrollBar`:`:Style`&`): [_^TreeCtrl^ TreeCtrl
][@(0.0.255) `&]_[* SetScrollBarStyle]([@(0.0.255) const]_[_^ScrollBar`:`:Style^ ScrollBa
r`::Style][@(0.0.255) `&]_[*@3 s])&]
[s2;%RU-RU Присваивает визуальный стиль 
`"Хамелеон`" полосе промотки TreeCtrl`'а.&]
[s3;%RU-RU &]
[s0;%RU-RU &]
[s0; &]
[s0; &]
[ {{10000@3 [s0; [*@(229)4 Класс TreeCtrl`::Node]]}}&]
[s3; &]
[s1;:TreeCtrl`:`:Node`:`:class: [@(0.0.255)3 class][3 _][*3 Node]&]
[s9;%RU-RU Этот класс представляет содержимое 
и внешний вид единичного элемента`-узла 
TreeCtrl`'а.&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0;%RU-RU [* Детали Конструктора]]}}&]
[s3; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(`): [* Node]()&]
[s2;%RU-RU Дефолтный конструктор.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Image`&`,const Value`&`): [* Node]([@(0.0.255) const
]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&
]_[*@3 v])&]
[s2;%RU-RU Присваивает иконку, ключ и значение.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Image`&`,const Value`&`,const Value`&`): [* Node](
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [@(0.0.255) const]_[_^Value^ Va
lue][@(0.0.255) `&]_[*@3 v], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 t])&]
[s2;%RU-RU Присваивает иконку, ключ и значение.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Value`&`): [* Node]([@(0.0.255) const]_[_^Value^ Value
][@(0.0.255) `&]_[*@3 v])&]
[s2;%RU-RU Присваивает ключ и значение.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Value`&`,const Value`&`): [* Node]([@(0.0.255) const
]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_
[*@3 t])&]
[s2;%RU-RU Присваивает ключ и значение.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(Ctrl`&`): [* Node]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2;%RU-RU Присваивает виджет.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Image`&`,Ctrl`&`,int`,int`): [* Node]([@(0.0.255) co
nst]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl], 
[@(0.0.255) int]_[*@3 cx]_`=_[@3 0], [@(0.0.255) int]_[*@3 cy]_`=_[@3 0])&]
[s2;%RU-RU Присваивает иконку, виджет и его 
размеры.&]
[s3;%RU-RU &]
[s0;%RU-RU &]
[ {{10000F(128)G(128)@1 [s0;%RU-RU [* Список Публичных Членов]]}}&]
[s3; &]
[s5;:TreeCtrl`:`:Node`:`:image: [_^Image^ Image]_[* image]&]
[s2;%RU-RU Иконка узла.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:margin: [@(0.0.255) int]_[* margin]&]
[s2;%RU-RU Пространство между иконкой и 
значением элемента, либо виджет элемента. 
Дефолтно равно 2.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:key: [_^Value^ Value]_[* key]&]
[s2;%RU-RU Ключ элемента. Не отображается.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:value: [_^Value^ Value]_[* value]&]
[s2;%RU-RU Значение элемента.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:display: [@(0.0.255) const]_[_^Display^ Display]_`*[* display]&]
[s2;%RU-RU Дисплей, используемый для отображения 
значения. Дефолт равен NULL, что обозначает 
использование StdDisplay.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:size: [_^Size^ Size]_[* size]&]
[s2;%RU-RU Размер области значения. Дефолт 
равен Null `- в этом случае размер области 
значения определяется по display`->GetStdSize(value) 
или ctrl`->GetMinSize(), если используется 
виджет для элемента.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:ctrl: [_^Ptr^ Ptr][@(0.0.255) <][_^Ctrl^ Ctrl][@(0.0.255) >]_[* ctrl]&]
[s2;%RU-RU Виджет, ассоциированный с элементом.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:canopen: [@(0.0.255) bool]_[* canopen]&]
[s2;%RU-RU Элемент можно открыть.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:canselect: [@(0.0.255) bool]_[* canselect]&]
[s2;%RU-RU Элемент можно выделить.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:SetImage`(const Image`&`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&
]_[* SetImage]([@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img])&]
[s2;%RU-RU Устанавливает рисунок.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Set`(const Value`&`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_
[* Set]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2;%RU-RU Устанавливает как ключ, так и 
значение в [%-*@3 v].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Set`(const Value`&`,const Value`&`): [_^TreeCtrl`:`:Node^ Node
][@(0.0.255) `&]_[* Set]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v], 
[@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 t])&]
[s2;%RU-RU Устанавливает ключ и значение.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:SetDisplay`(const Display`&`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&
]_[* SetDisplay]([@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_[*@3 d])&]
[s2;%RU-RU Устанавливает дисплей.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:SetSize`(Size`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_[* SetS
ize]([_^Size^ Size]_[*@3 sz])&]
[s2;%RU-RU Устанавливает размер.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:SetCtrl`(Ctrl`&`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_[* Se
tCtrl]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 `_ctrl])&]
[s2;%RU-RU Устанавливает виджет.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:CanOpen`(bool`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_[* CanO
pen]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%RU-RU Устанавливает флаг canopen.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:CanSelect`(bool`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_[* Ca
nSelect]([@(0.0.255) bool]_[*@3 b])&]
[s2;%RU-RU Устанавливает флаг canselect.&]
[s3; &]
[s0; ]]